/*
 * jsrsasign(all) 10.8.6 (2023-04-26) (c) 2010-2023 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
var VERSION = "10.8.6";
var VERSION_FULL = "jsrsasign(all) 10.8.6 (2023-04-26) (c) 2010-2023 Kenji Urushima | kjur.github.io/jsrsasign/license";

/*! CryptoJS v3.1.2 core-fix.js
 * code.google.com/p/crypto-js
 * (c) 2009-2013 by Jeff Mott. All rights reserved.
 * code.google.com/p/crypto-js/wiki/License
 * THIS IS FIX of 'core.js' to fix Hmac issue.
 * https://code.google.com/p/crypto-js/issues/detail?id=84
 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
 */
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = (function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            } else {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512/32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    return C;
}(Math));

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var X32WordArray = C_lib.WordArray;

    /**
     * x64 namespace.
     */
    var C_x64 = C.x64 = {};

    /**
     * A 64-bit word.
     */
    var X64Word = C_x64.Word = Base.extend({
        /**
         * Initializes a newly created 64-bit word.
         *
         * @param {number} high The high 32 bits.
         * @param {number} low The low 32 bits.
         *
         * @example
         *
         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
         */
        init: function (high, low) {
            this.high = high;
            this.low = low;
        }

        /**
         * Bitwise NOTs this word.
         *
         * @return {X64Word} A new x64-Word object after negating.
         *
         * @example
         *
         *     var negated = x64Word.not();
         */
        // not: function () {
            // var high = ~this.high;
            // var low = ~this.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Bitwise ANDs this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to AND with this word.
         *
         * @return {X64Word} A new x64-Word object after ANDing.
         *
         * @example
         *
         *     var anded = x64Word.and(anotherX64Word);
         */
        // and: function (word) {
            // var high = this.high & word.high;
            // var low = this.low & word.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Bitwise ORs this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to OR with this word.
         *
         * @return {X64Word} A new x64-Word object after ORing.
         *
         * @example
         *
         *     var ored = x64Word.or(anotherX64Word);
         */
        // or: function (word) {
            // var high = this.high | word.high;
            // var low = this.low | word.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Bitwise XORs this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to XOR with this word.
         *
         * @return {X64Word} A new x64-Word object after XORing.
         *
         * @example
         *
         *     var xored = x64Word.xor(anotherX64Word);
         */
        // xor: function (word) {
            // var high = this.high ^ word.high;
            // var low = this.low ^ word.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Shifts this word n bits to the left.
         *
         * @param {number} n The number of bits to shift.
         *
         * @return {X64Word} A new x64-Word object after shifting.
         *
         * @example
         *
         *     var shifted = x64Word.shiftL(25);
         */
        // shiftL: function (n) {
            // if (n < 32) {
                // var high = (this.high << n) | (this.low >>> (32 - n));
                // var low = this.low << n;
            // } else {
                // var high = this.low << (n - 32);
                // var low = 0;
            // }

            // return X64Word.create(high, low);
        // },

        /**
         * Shifts this word n bits to the right.
         *
         * @param {number} n The number of bits to shift.
         *
         * @return {X64Word} A new x64-Word object after shifting.
         *
         * @example
         *
         *     var shifted = x64Word.shiftR(7);
         */
        // shiftR: function (n) {
            // if (n < 32) {
                // var low = (this.low >>> n) | (this.high << (32 - n));
                // var high = this.high >>> n;
            // } else {
                // var low = this.high >>> (n - 32);
                // var high = 0;
            // }

            // return X64Word.create(high, low);
        // },

        /**
         * Rotates this word n bits to the left.
         *
         * @param {number} n The number of bits to rotate.
         *
         * @return {X64Word} A new x64-Word object after rotating.
         *
         * @example
         *
         *     var rotated = x64Word.rotL(25);
         */
        // rotL: function (n) {
            // return this.shiftL(n).or(this.shiftR(64 - n));
        // },

        /**
         * Rotates this word n bits to the right.
         *
         * @param {number} n The number of bits to rotate.
         *
         * @return {X64Word} A new x64-Word object after rotating.
         *
         * @example
         *
         *     var rotated = x64Word.rotR(7);
         */
        // rotR: function (n) {
            // return this.shiftR(n).or(this.shiftL(64 - n));
        // },

        /**
         * Adds this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to add with this word.
         *
         * @return {X64Word} A new x64-Word object after adding.
         *
         * @example
         *
         *     var added = x64Word.add(anotherX64Word);
         */
        // add: function (word) {
            // var low = (this.low + word.low) | 0;
            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
            // var high = (this.high + word.high + carry) | 0;

            // return X64Word.create(high, low);
        // }
    });

    /**
     * An array of 64-bit words.
     *
     * @property {Array} words The array of CryptoJS.x64.Word objects.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var X64WordArray = C_x64.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.x64.WordArray.create();
         *
         *     var wordArray = CryptoJS.x64.WordArray.create([
         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
         *     ]);
         *
         *     var wordArray = CryptoJS.x64.WordArray.create([
         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
         *     ], 10);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 8;
            }
        },

        /**
         * Converts this 64-bit word array to a 32-bit word array.
         *
         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
         *
         * @example
         *
         *     var x32WordArray = x64WordArray.toX32();
         */
        toX32: function () {
            // Shortcuts
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;

            // Convert
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
                var x64Word = x64Words[i];
                x32Words.push(x64Word.high);
                x32Words.push(x64Word.low);
            }

            return X32WordArray.create(x32Words, this.sigBytes);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {X64WordArray} The clone.
         *
         * @example
         *
         *     var clone = x64WordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);

            // Clone "words" array
            var words = clone.words = this.words.slice(0);

            // Clone each X64Word object
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
                words[i] = words[i].clone();
            }

            return clone;
        }
    });
}());

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * Cipher core components.
 */
CryptoJS.lib.Cipher || (function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var Base64 = C_enc.Base64;
    var C_algo = C.algo;
    var EvpKDF = C_algo.EvpKDF;

    /**
     * Abstract base cipher template.
     *
     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
     */
    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         *
         * @property {WordArray} iv The IV to use for this operation.
         */
        cfg: Base.extend(),

        /**
         * Creates this cipher in encryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
         */
        createEncryptor: function (key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
        },

        /**
         * Creates this cipher in decryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
         */
        createDecryptor: function (key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
        },

        /**
         * Initializes a newly created cipher.
         *
         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
         */
        init: function (xformMode, key, cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Store transform mode and key
            this._xformMode = xformMode;
            this._key = key;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this cipher to its initial state.
         *
         * @example
         *
         *     cipher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-cipher logic
            this._doReset();
        },

        /**
         * Adds data to be encrypted or decrypted.
         *
         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
         *
         * @return {WordArray} The data after processing.
         *
         * @example
         *
         *     var encrypted = cipher.process('data');
         *     var encrypted = cipher.process(wordArray);
         */
        process: function (dataUpdate) {
            // Append
            this._append(dataUpdate);

            // Process available blocks
            return this._process();
        },

        /**
         * Finalizes the encryption or decryption process.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
         *
         * @return {WordArray} The data after final processing.
         *
         * @example
         *
         *     var encrypted = cipher.finalize();
         *     var encrypted = cipher.finalize('data');
         *     var encrypted = cipher.finalize(wordArray);
         */
        finalize: function (dataUpdate) {
            // Final data update
            if (dataUpdate) {
                this._append(dataUpdate);
            }

            // Perform concrete-cipher logic
            var finalProcessedData = this._doFinalize();

            return finalProcessedData;
        },

        keySize: 128/32,

        ivSize: 128/32,

        _ENC_XFORM_MODE: 1,

        _DEC_XFORM_MODE: 2,

        /**
         * Creates shortcut functions to a cipher's object interface.
         *
         * @param {Cipher} cipher The cipher to create a helper for.
         *
         * @return {Object} An object with encrypt and decrypt shortcut functions.
         *
         * @static
         *
         * @example
         *
         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
         */
        _createHelper: (function () {
            function selectCipherStrategy(key) {
                if (typeof key == 'string') {
                    return PasswordBasedCipher;
                } else {
                    return SerializableCipher;
                }
            }

            return function (cipher) {
                return {
                    encrypt: function (message, key, cfg) {
                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                    },

                    decrypt: function (ciphertext, key, cfg) {
                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                    }
                };
            };
        }())
    });

    /**
     * Abstract base stream cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
     */
    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
        _doFinalize: function () {
            // Process partial blocks
            var finalProcessedBlocks = this._process(!!'flush');

            return finalProcessedBlocks;
        },

        blockSize: 1
    });

    /**
     * Mode namespace.
     */
    var C_mode = C.mode = {};

    /**
     * Abstract base block cipher mode template.
     */
    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
        /**
         * Creates this mode for encryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
         */
        createEncryptor: function (cipher, iv) {
            return this.Encryptor.create(cipher, iv);
        },

        /**
         * Creates this mode for decryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
         */
        createDecryptor: function (cipher, iv) {
            return this.Decryptor.create(cipher, iv);
        },

        /**
         * Initializes a newly created mode.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
         */
        init: function (cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
        }
    });

    /**
     * Cipher Block Chaining mode.
     */
    var CBC = C_mode.CBC = (function () {
        /**
         * Abstract base CBC mode.
         */
        var CBC = BlockCipherMode.extend();

        /**
         * CBC encryptor.
         */
        CBC.Encryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // XOR and encrypt
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);

                // Remember this block to use with next block
                this._prevBlock = words.slice(offset, offset + blockSize);
            }
        });

        /**
         * CBC decryptor.
         */
        CBC.Decryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // Remember this block to use with next block
                var thisBlock = words.slice(offset, offset + blockSize);

                // Decrypt and XOR
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);

                // This block becomes the previous block
                this._prevBlock = thisBlock;
            }
        });

        function xorBlock(words, offset, blockSize) {
            // Shortcut
            var iv = this._iv;

            // Choose mixing block
            if (iv) {
                var block = iv;

                // Remove IV for subsequent blocks
                this._iv = undefined;
            } else {
                var block = this._prevBlock;
            }

            // XOR blocks
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= block[i];
            }
        }

        return CBC;
    }());

    /**
     * Padding namespace.
     */
    var C_pad = C.pad = {};

    /**
     * PKCS #5/7 padding strategy.
     */
    var Pkcs7 = C_pad.Pkcs7 = {
        /**
         * Pads data using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to pad.
         * @param {number} blockSize The multiple that the data should be padded to.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
         */
        pad: function (data, blockSize) {
            // Shortcut
            var blockSizeBytes = blockSize * 4;

            // Count padding bytes
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

            // Create padding word
            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

            // Create padding
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
                paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);

            // Add padding
            data.concat(padding);
        },

        /**
         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to unpad.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
         */
        unpad: function (data) {
            // Get number of padding bytes from last byte
            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

            // Remove padding
            data.sigBytes -= nPaddingBytes;
        }
    };

    /**
     * Abstract base block cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
     */
    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
        /**
         * Configuration options.
         *
         * @property {Mode} mode The block mode to use. Default: CBC
         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
         */
        cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
        }),

        reset: function () {
            // Reset cipher
            Cipher.reset.call(this);

            // Shortcuts
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;

            // Reset block mode
            if (this._xformMode == this._ENC_XFORM_MODE) {
                var modeCreator = mode.createEncryptor;
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                var modeCreator = mode.createDecryptor;

                // Keep at least one block in the buffer for unpadding
                this._minBufferSize = 1;
            }
            this._mode = modeCreator.call(mode, this, iv && iv.words);
        },

        _doProcessBlock: function (words, offset) {
            this._mode.processBlock(words, offset);
        },

        _doFinalize: function () {
            // Shortcut
            var padding = this.cfg.padding;

            // Finalize
            if (this._xformMode == this._ENC_XFORM_MODE) {
                // Pad data
                padding.pad(this._data, this.blockSize);

                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');

                // Unpad data
                padding.unpad(finalProcessedBlocks);
            }

            return finalProcessedBlocks;
        },

        blockSize: 128/32
    });

    /**
     * A collection of cipher parameters.
     *
     * @property {WordArray} ciphertext The raw ciphertext.
     * @property {WordArray} key The key to this ciphertext.
     * @property {WordArray} iv The IV used in the ciphering operation.
     * @property {WordArray} salt The salt used with a key derivation function.
     * @property {Cipher} algorithm The cipher algorithm.
     * @property {Mode} mode The block mode used in the ciphering operation.
     * @property {Padding} padding The padding scheme used in the ciphering operation.
     * @property {number} blockSize The block size of the cipher.
     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
     */
    var CipherParams = C_lib.CipherParams = Base.extend({
        /**
         * Initializes a newly created cipher params object.
         *
         * @param {Object} cipherParams An object with any of the possible cipher parameters.
         *
         * @example
         *
         *     var cipherParams = CryptoJS.lib.CipherParams.create({
         *         ciphertext: ciphertextWordArray,
         *         key: keyWordArray,
         *         iv: ivWordArray,
         *         salt: saltWordArray,
         *         algorithm: CryptoJS.algo.AES,
         *         mode: CryptoJS.mode.CBC,
         *         padding: CryptoJS.pad.PKCS7,
         *         blockSize: 4,
         *         formatter: CryptoJS.format.OpenSSL
         *     });
         */
        init: function (cipherParams) {
            this.mixIn(cipherParams);
        },

        /**
         * Converts this cipher params object to a string.
         *
         * @param {Format} formatter (Optional) The formatting strategy to use.
         *
         * @return {string} The stringified cipher params.
         *
         * @throws Error If neither the formatter nor the default formatter is set.
         *
         * @example
         *
         *     var string = cipherParams + '';
         *     var string = cipherParams.toString();
         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
         */
        toString: function (formatter) {
            return (formatter || this.formatter).stringify(this);
        }
    });

    /**
     * Format namespace.
     */
    var C_format = C.format = {};

    /**
     * OpenSSL formatting strategy.
     */
    var OpenSSLFormatter = C_format.OpenSSL = {
        /**
         * Converts a cipher params object to an OpenSSL-compatible string.
         *
         * @param {CipherParams} cipherParams The cipher params object.
         *
         * @return {string} The OpenSSL-compatible string.
         *
         * @static
         *
         * @example
         *
         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
         */
        stringify: function (cipherParams) {
            // Shortcuts
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;

            // Format
            if (salt) {
                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
            } else {
                var wordArray = ciphertext;
            }

            return wordArray.toString(Base64);
        },

        /**
         * Converts an OpenSSL-compatible string to a cipher params object.
         *
         * @param {string} openSSLStr The OpenSSL-compatible string.
         *
         * @return {CipherParams} The cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
         */
        parse: function (openSSLStr) {
            // Parse base64
            var ciphertext = Base64.parse(openSSLStr);

            // Shortcut
            var ciphertextWords = ciphertext.words;

            // Test for salt
            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                // Extract salt
                var salt = WordArray.create(ciphertextWords.slice(2, 4));

                // Remove salt from ciphertext
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
            }

            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
        }
    };

    /**
     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
     */
    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
        /**
         * Configuration options.
         *
         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
         */
        cfg: Base.extend({
            format: OpenSSLFormatter
        }),

        /**
         * Encrypts a message.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Encrypt
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);

            // Shortcut
            var cipherCfg = encryptor.cfg;

            // Create and return serializable cipher params
            return CipherParams.create({
                ciphertext: ciphertext,
                key: key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
            });
        },

        /**
         * Decrypts serialized ciphertext.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Decrypt
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

            return plaintext;
        },

        /**
         * Converts serialized ciphertext to CipherParams,
         * else assumed CipherParams already and returns ciphertext unchanged.
         *
         * @param {CipherParams|string} ciphertext The ciphertext.
         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
         *
         * @return {CipherParams} The unserialized ciphertext.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
         */
        _parse: function (ciphertext, format) {
            if (typeof ciphertext == 'string') {
                return format.parse(ciphertext, this);
            } else {
                return ciphertext;
            }
        }
    });

    /**
     * Key derivation function namespace.
     */
    var C_kdf = C.kdf = {};

    /**
     * OpenSSL key derivation function.
     */
    var OpenSSLKdf = C_kdf.OpenSSL = {
        /**
         * Derives a key and IV from a password.
         *
         * @param {string} password The password to derive from.
         * @param {number} keySize The size in words of the key to generate.
         * @param {number} ivSize The size in words of the IV to generate.
         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
         *
         * @return {CipherParams} A cipher params object with the key, IV, and salt.
         *
         * @static
         *
         * @example
         *
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
         */
        execute: function (password, keySize, ivSize, salt) {
            // Generate random salt
            if (!salt) {
                salt = WordArray.random(64/8);
            }

            // Derive key and IV
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

            // Separate key and IV
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;

            // Return params
            return CipherParams.create({ key: key, iv: iv, salt: salt });
        }
    };

    /**
     * A serializable cipher wrapper that derives the key from a password,
     * and returns ciphertext as a serializable cipher params object.
     */
    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
        /**
         * Configuration options.
         *
         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
         */
        cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
        }),

        /**
         * Encrypts a message using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Encrypt
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

            // Mix in derived params
            ciphertext.mixIn(derivedParams);

            return ciphertext;
        },

        /**
         * Decrypts serialized ciphertext using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Decrypt
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

            return plaintext;
        }
    });
}());

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo;

    // Lookup tables
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX_0 = [];
    var SUB_MIX_1 = [];
    var SUB_MIX_2 = [];
    var SUB_MIX_3 = [];
    var INV_SUB_MIX_0 = [];
    var INV_SUB_MIX_1 = [];
    var INV_SUB_MIX_2 = [];
    var INV_SUB_MIX_3 = [];

    // Compute lookup tables
    (function () {
        // Compute double table
        var d = [];
        for (var i = 0; i < 256; i++) {
            if (i < 128) {
                d[i] = i << 1;
            } else {
                d[i] = (i << 1) ^ 0x11b;
            }
        }

        // Walk GF(2^8)
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; i++) {
            // Compute sbox
            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;

            // Compute multiplication
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];

            // Compute sub bytes, mix columns tables
            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
            SUB_MIX_3[x] = t;

            // Compute inv sub bytes, inv mix columns tables
            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
            INV_SUB_MIX_3[sx] = t;

            // Compute next counter
            if (!x) {
                x = xi = 1;
            } else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
            }
        }
    }());

    // Precomputed Rcon lookup
    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

    /**
     * AES block cipher algorithm.
     */
    var AES = C_algo.AES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;

            // Compute number of rounds
            var nRounds = this._nRounds = keySize + 6

            // Compute number of key schedule rows
            var ksRows = (nRounds + 1) * 4;

            // Compute key schedule
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                    keySchedule[ksRow] = keyWords[ksRow];
                } else {
                    var t = keySchedule[ksRow - 1];

                    if (!(ksRow % keySize)) {
                        // Rot word
                        t = (t << 8) | (t >>> 24);

                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

                        // Mix Rcon
                        t ^= RCON[(ksRow / keySize) | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize == 4) {
                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                    }

                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                }
            }

            // Compute inv key schedule
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;

                if (invKsRow % 4) {
                    var t = keySchedule[ksRow];
                } else {
                    var t = keySchedule[ksRow - 4];
                }

                if (invKsRow < 4 || ksRow <= 4) {
                    invKeySchedule[invKsRow] = t;
                } else {
                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                }
            }
        },

        encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
        },

        decryptBlock: function (M, offset) {
            // Swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;

            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

            // Inv swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
        },

        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            // Shortcut
            var nRounds = this._nRounds;

            // Get input, add round key
            var s0 = M[offset]     ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];

            // Key schedule row counter
            var ksRow = 4;

            // Rounds
            for (var round = 1; round < nRounds; round++) {
                // Shift rows, sub bytes, mix columns, add round key
                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

                // Update state
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
            }

            // Shift rows, sub bytes, add round key
            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

            // Set output
            M[offset]     = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
        },

        keySize: 256/32
    });

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
     */
    C.AES = BlockCipher._createHelper(AES);
}());

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo;

    // Permuted Choice 1 constants
    var PC1 = [
        57, 49, 41, 33, 25, 17, 9,  1,
        58, 50, 42, 34, 26, 18, 10, 2,
        59, 51, 43, 35, 27, 19, 11, 3,
        60, 52, 44, 36, 63, 55, 47, 39,
        31, 23, 15, 7,  62, 54, 46, 38,
        30, 22, 14, 6,  61, 53, 45, 37,
        29, 21, 13, 5,  28, 20, 12, 4
    ];

    // Permuted Choice 2 constants
    var PC2 = [
        14, 17, 11, 24, 1,  5,
        3,  28, 15, 6,  21, 10,
        23, 19, 12, 4,  26, 8,
        16, 7,  27, 20, 13, 2,
        41, 52, 31, 37, 47, 55,
        30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53,
        46, 42, 50, 36, 29, 32
    ];

    // Cumulative bit shift constants
    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

    // SBOXes and round permutation constants
    var SBOX_P = [
        {
            0x0: 0x808200,
            0x10000000: 0x8000,
            0x20000000: 0x808002,
            0x30000000: 0x2,
            0x40000000: 0x200,
            0x50000000: 0x808202,
            0x60000000: 0x800202,
            0x70000000: 0x800000,
            0x80000000: 0x202,
            0x90000000: 0x800200,
            0xa0000000: 0x8200,
            0xb0000000: 0x808000,
            0xc0000000: 0x8002,
            0xd0000000: 0x800002,
            0xe0000000: 0x0,
            0xf0000000: 0x8202,
            0x8000000: 0x0,
            0x18000000: 0x808202,
            0x28000000: 0x8202,
            0x38000000: 0x8000,
            0x48000000: 0x808200,
            0x58000000: 0x200,
            0x68000000: 0x808002,
            0x78000000: 0x2,
            0x88000000: 0x800200,
            0x98000000: 0x8200,
            0xa8000000: 0x808000,
            0xb8000000: 0x800202,
            0xc8000000: 0x800002,
            0xd8000000: 0x8002,
            0xe8000000: 0x202,
            0xf8000000: 0x800000,
            0x1: 0x8000,
            0x10000001: 0x2,
            0x20000001: 0x808200,
            0x30000001: 0x800000,
            0x40000001: 0x808002,
            0x50000001: 0x8200,
            0x60000001: 0x200,
            0x70000001: 0x800202,
            0x80000001: 0x808202,
            0x90000001: 0x808000,
            0xa0000001: 0x800002,
            0xb0000001: 0x8202,
            0xc0000001: 0x202,
            0xd0000001: 0x800200,
            0xe0000001: 0x8002,
            0xf0000001: 0x0,
            0x8000001: 0x808202,
            0x18000001: 0x808000,
            0x28000001: 0x800000,
            0x38000001: 0x200,
            0x48000001: 0x8000,
            0x58000001: 0x800002,
            0x68000001: 0x2,
            0x78000001: 0x8202,
            0x88000001: 0x8002,
            0x98000001: 0x800202,
            0xa8000001: 0x202,
            0xb8000001: 0x808200,
            0xc8000001: 0x800200,
            0xd8000001: 0x0,
            0xe8000001: 0x8200,
            0xf8000001: 0x808002
        },
        {
            0x0: 0x40084010,
            0x1000000: 0x4000,
            0x2000000: 0x80000,
            0x3000000: 0x40080010,
            0x4000000: 0x40000010,
            0x5000000: 0x40084000,
            0x6000000: 0x40004000,
            0x7000000: 0x10,
            0x8000000: 0x84000,
            0x9000000: 0x40004010,
            0xa000000: 0x40000000,
            0xb000000: 0x84010,
            0xc000000: 0x80010,
            0xd000000: 0x0,
            0xe000000: 0x4010,
            0xf000000: 0x40080000,
            0x800000: 0x40004000,
            0x1800000: 0x84010,
            0x2800000: 0x10,
            0x3800000: 0x40004010,
            0x4800000: 0x40084010,
            0x5800000: 0x40000000,
            0x6800000: 0x80000,
            0x7800000: 0x40080010,
            0x8800000: 0x80010,
            0x9800000: 0x0,
            0xa800000: 0x4000,
            0xb800000: 0x40080000,
            0xc800000: 0x40000010,
            0xd800000: 0x84000,
            0xe800000: 0x40084000,
            0xf800000: 0x4010,
            0x10000000: 0x0,
            0x11000000: 0x40080010,
            0x12000000: 0x40004010,
            0x13000000: 0x40084000,
            0x14000000: 0x40080000,
            0x15000000: 0x10,
            0x16000000: 0x84010,
            0x17000000: 0x4000,
            0x18000000: 0x4010,
            0x19000000: 0x80000,
            0x1a000000: 0x80010,
            0x1b000000: 0x40000010,
            0x1c000000: 0x84000,
            0x1d000000: 0x40004000,
            0x1e000000: 0x40000000,
            0x1f000000: 0x40084010,
            0x10800000: 0x84010,
            0x11800000: 0x80000,
            0x12800000: 0x40080000,
            0x13800000: 0x4000,
            0x14800000: 0x40004000,
            0x15800000: 0x40084010,
            0x16800000: 0x10,
            0x17800000: 0x40000000,
            0x18800000: 0x40084000,
            0x19800000: 0x40000010,
            0x1a800000: 0x40004010,
            0x1b800000: 0x80010,
            0x1c800000: 0x0,
            0x1d800000: 0x4010,
            0x1e800000: 0x40080010,
            0x1f800000: 0x84000
        },
        {
            0x0: 0x104,
            0x100000: 0x0,
            0x200000: 0x4000100,
            0x300000: 0x10104,
            0x400000: 0x10004,
            0x500000: 0x4000004,
            0x600000: 0x4010104,
            0x700000: 0x4010000,
            0x800000: 0x4000000,
            0x900000: 0x4010100,
            0xa00000: 0x10100,
            0xb00000: 0x4010004,
            0xc00000: 0x4000104,
            0xd00000: 0x10000,
            0xe00000: 0x4,
            0xf00000: 0x100,
            0x80000: 0x4010100,
            0x180000: 0x4010004,
            0x280000: 0x0,
            0x380000: 0x4000100,
            0x480000: 0x4000004,
            0x580000: 0x10000,
            0x680000: 0x10004,
            0x780000: 0x104,
            0x880000: 0x4,
            0x980000: 0x100,
            0xa80000: 0x4010000,
            0xb80000: 0x10104,
            0xc80000: 0x10100,
            0xd80000: 0x4000104,
            0xe80000: 0x4010104,
            0xf80000: 0x4000000,
            0x1000000: 0x4010100,
            0x1100000: 0x10004,
            0x1200000: 0x10000,
            0x1300000: 0x4000100,
            0x1400000: 0x100,
            0x1500000: 0x4010104,
            0x1600000: 0x4000004,
            0x1700000: 0x0,
            0x1800000: 0x4000104,
            0x1900000: 0x4000000,
            0x1a00000: 0x4,
            0x1b00000: 0x10100,
            0x1c00000: 0x4010000,
            0x1d00000: 0x104,
            0x1e00000: 0x10104,
            0x1f00000: 0x4010004,
            0x1080000: 0x4000000,
            0x1180000: 0x104,
            0x1280000: 0x4010100,
            0x1380000: 0x0,
            0x1480000: 0x10004,
            0x1580000: 0x4000100,
            0x1680000: 0x100,
            0x1780000: 0x4010004,
            0x1880000: 0x10000,
            0x1980000: 0x4010104,
            0x1a80000: 0x10104,
            0x1b80000: 0x4000004,
            0x1c80000: 0x4000104,
            0x1d80000: 0x4010000,
            0x1e80000: 0x4,
            0x1f80000: 0x10100
        },
        {
            0x0: 0x80401000,
            0x10000: 0x80001040,
            0x20000: 0x401040,
            0x30000: 0x80400000,
            0x40000: 0x0,
            0x50000: 0x401000,
            0x60000: 0x80000040,
            0x70000: 0x400040,
            0x80000: 0x80000000,
            0x90000: 0x400000,
            0xa0000: 0x40,
            0xb0000: 0x80001000,
            0xc0000: 0x80400040,
            0xd0000: 0x1040,
            0xe0000: 0x1000,
            0xf0000: 0x80401040,
            0x8000: 0x80001040,
            0x18000: 0x40,
            0x28000: 0x80400040,
            0x38000: 0x80001000,
            0x48000: 0x401000,
            0x58000: 0x80401040,
            0x68000: 0x0,
            0x78000: 0x80400000,
            0x88000: 0x1000,
            0x98000: 0x80401000,
            0xa8000: 0x400000,
            0xb8000: 0x1040,
            0xc8000: 0x80000000,
            0xd8000: 0x400040,
            0xe8000: 0x401040,
            0xf8000: 0x80000040,
            0x100000: 0x400040,
            0x110000: 0x401000,
            0x120000: 0x80000040,
            0x130000: 0x0,
            0x140000: 0x1040,
            0x150000: 0x80400040,
            0x160000: 0x80401000,
            0x170000: 0x80001040,
            0x180000: 0x80401040,
            0x190000: 0x80000000,
            0x1a0000: 0x80400000,
            0x1b0000: 0x401040,
            0x1c0000: 0x80001000,
            0x1d0000: 0x400000,
            0x1e0000: 0x40,
            0x1f0000: 0x1000,
            0x108000: 0x80400000,
            0x118000: 0x80401040,
            0x128000: 0x0,
            0x138000: 0x401000,
            0x148000: 0x400040,
            0x158000: 0x80000000,
            0x168000: 0x80001040,
            0x178000: 0x40,
            0x188000: 0x80000040,
            0x198000: 0x1000,
            0x1a8000: 0x80001000,
            0x1b8000: 0x80400040,
            0x1c8000: 0x1040,
            0x1d8000: 0x80401000,
            0x1e8000: 0x400000,
            0x1f8000: 0x401040
        },
        {
            0x0: 0x80,
            0x1000: 0x1040000,
            0x2000: 0x40000,
            0x3000: 0x20000000,
            0x4000: 0x20040080,
            0x5000: 0x1000080,
            0x6000: 0x21000080,
            0x7000: 0x40080,
            0x8000: 0x1000000,
            0x9000: 0x20040000,
            0xa000: 0x20000080,
            0xb000: 0x21040080,
            0xc000: 0x21040000,
            0xd000: 0x0,
            0xe000: 0x1040080,
            0xf000: 0x21000000,
            0x800: 0x1040080,
            0x1800: 0x21000080,
            0x2800: 0x80,
            0x3800: 0x1040000,
            0x4800: 0x40000,
            0x5800: 0x20040080,
            0x6800: 0x21040000,
            0x7800: 0x20000000,
            0x8800: 0x20040000,
            0x9800: 0x0,
            0xa800: 0x21040080,
            0xb800: 0x1000080,
            0xc800: 0x20000080,
            0xd800: 0x21000000,
            0xe800: 0x1000000,
            0xf800: 0x40080,
            0x10000: 0x40000,
            0x11000: 0x80,
            0x12000: 0x20000000,
            0x13000: 0x21000080,
            0x14000: 0x1000080,
            0x15000: 0x21040000,
            0x16000: 0x20040080,
            0x17000: 0x1000000,
            0x18000: 0x21040080,
            0x19000: 0x21000000,
            0x1a000: 0x1040000,
            0x1b000: 0x20040000,
            0x1c000: 0x40080,
            0x1d000: 0x20000080,
            0x1e000: 0x0,
            0x1f000: 0x1040080,
            0x10800: 0x21000080,
            0x11800: 0x1000000,
            0x12800: 0x1040000,
            0x13800: 0x20040080,
            0x14800: 0x20000000,
            0x15800: 0x1040080,
            0x16800: 0x80,
            0x17800: 0x21040000,
            0x18800: 0x40080,
            0x19800: 0x21040080,
            0x1a800: 0x0,
            0x1b800: 0x21000000,
            0x1c800: 0x1000080,
            0x1d800: 0x40000,
            0x1e800: 0x20040000,
            0x1f800: 0x20000080
        },
        {
            0x0: 0x10000008,
            0x100: 0x2000,
            0x200: 0x10200000,
            0x300: 0x10202008,
            0x400: 0x10002000,
            0x500: 0x200000,
            0x600: 0x200008,
            0x700: 0x10000000,
            0x800: 0x0,
            0x900: 0x10002008,
            0xa00: 0x202000,
            0xb00: 0x8,
            0xc00: 0x10200008,
            0xd00: 0x202008,
            0xe00: 0x2008,
            0xf00: 0x10202000,
            0x80: 0x10200000,
            0x180: 0x10202008,
            0x280: 0x8,
            0x380: 0x200000,
            0x480: 0x202008,
            0x580: 0x10000008,
            0x680: 0x10002000,
            0x780: 0x2008,
            0x880: 0x200008,
            0x980: 0x2000,
            0xa80: 0x10002008,
            0xb80: 0x10200008,
            0xc80: 0x0,
            0xd80: 0x10202000,
            0xe80: 0x202000,
            0xf80: 0x10000000,
            0x1000: 0x10002000,
            0x1100: 0x10200008,
            0x1200: 0x10202008,
            0x1300: 0x2008,
            0x1400: 0x200000,
            0x1500: 0x10000000,
            0x1600: 0x10000008,
            0x1700: 0x202000,
            0x1800: 0x202008,
            0x1900: 0x0,
            0x1a00: 0x8,
            0x1b00: 0x10200000,
            0x1c00: 0x2000,
            0x1d00: 0x10002008,
            0x1e00: 0x10202000,
            0x1f00: 0x200008,
            0x1080: 0x8,
            0x1180: 0x202000,
            0x1280: 0x200000,
            0x1380: 0x10000008,
            0x1480: 0x10002000,
            0x1580: 0x2008,
            0x1680: 0x10202008,
            0x1780: 0x10200000,
            0x1880: 0x10202000,
            0x1980: 0x10200008,
            0x1a80: 0x2000,
            0x1b80: 0x202008,
            0x1c80: 0x200008,
            0x1d80: 0x0,
            0x1e80: 0x10000000,
            0x1f80: 0x10002008
        },
        {
            0x0: 0x100000,
            0x10: 0x2000401,
            0x20: 0x400,
            0x30: 0x100401,
            0x40: 0x2100401,
            0x50: 0x0,
            0x60: 0x1,
            0x70: 0x2100001,
            0x80: 0x2000400,
            0x90: 0x100001,
            0xa0: 0x2000001,
            0xb0: 0x2100400,
            0xc0: 0x2100000,
            0xd0: 0x401,
            0xe0: 0x100400,
            0xf0: 0x2000000,
            0x8: 0x2100001,
            0x18: 0x0,
            0x28: 0x2000401,
            0x38: 0x2100400,
            0x48: 0x100000,
            0x58: 0x2000001,
            0x68: 0x2000000,
            0x78: 0x401,
            0x88: 0x100401,
            0x98: 0x2000400,
            0xa8: 0x2100000,
            0xb8: 0x100001,
            0xc8: 0x400,
            0xd8: 0x2100401,
            0xe8: 0x1,
            0xf8: 0x100400,
            0x100: 0x2000000,
            0x110: 0x100000,
            0x120: 0x2000401,
            0x130: 0x2100001,
            0x140: 0x100001,
            0x150: 0x2000400,
            0x160: 0x2100400,
            0x170: 0x100401,
            0x180: 0x401,
            0x190: 0x2100401,
            0x1a0: 0x100400,
            0x1b0: 0x1,
            0x1c0: 0x0,
            0x1d0: 0x2100000,
            0x1e0: 0x2000001,
            0x1f0: 0x400,
            0x108: 0x100400,
            0x118: 0x2000401,
            0x128: 0x2100001,
            0x138: 0x1,
            0x148: 0x2000000,
            0x158: 0x100000,
            0x168: 0x401,
            0x178: 0x2100400,
            0x188: 0x2000001,
            0x198: 0x2100000,
            0x1a8: 0x0,
            0x1b8: 0x2100401,
            0x1c8: 0x100401,
            0x1d8: 0x400,
            0x1e8: 0x2000400,
            0x1f8: 0x100001
        },
        {
            0x0: 0x8000820,
            0x1: 0x20000,
            0x2: 0x8000000,
            0x3: 0x20,
            0x4: 0x20020,
            0x5: 0x8020820,
            0x6: 0x8020800,
            0x7: 0x800,
            0x8: 0x8020000,
            0x9: 0x8000800,
            0xa: 0x20800,
            0xb: 0x8020020,
            0xc: 0x820,
            0xd: 0x0,
            0xe: 0x8000020,
            0xf: 0x20820,
            0x80000000: 0x800,
            0x80000001: 0x8020820,
            0x80000002: 0x8000820,
            0x80000003: 0x8000000,
            0x80000004: 0x8020000,
            0x80000005: 0x20800,
            0x80000006: 0x20820,
            0x80000007: 0x20,
            0x80000008: 0x8000020,
            0x80000009: 0x820,
            0x8000000a: 0x20020,
            0x8000000b: 0x8020800,
            0x8000000c: 0x0,
            0x8000000d: 0x8020020,
            0x8000000e: 0x8000800,
            0x8000000f: 0x20000,
            0x10: 0x20820,
            0x11: 0x8020800,
            0x12: 0x20,
            0x13: 0x800,
            0x14: 0x8000800,
            0x15: 0x8000020,
            0x16: 0x8020020,
            0x17: 0x20000,
            0x18: 0x0,
            0x19: 0x20020,
            0x1a: 0x8020000,
            0x1b: 0x8000820,
            0x1c: 0x8020820,
            0x1d: 0x20800,
            0x1e: 0x820,
            0x1f: 0x8000000,
            0x80000010: 0x20000,
            0x80000011: 0x800,
            0x80000012: 0x8020020,
            0x80000013: 0x20820,
            0x80000014: 0x20,
            0x80000015: 0x8020000,
            0x80000016: 0x8000000,
            0x80000017: 0x8000820,
            0x80000018: 0x8020820,
            0x80000019: 0x8000020,
            0x8000001a: 0x8000800,
            0x8000001b: 0x0,
            0x8000001c: 0x20800,
            0x8000001d: 0x820,
            0x8000001e: 0x20020,
            0x8000001f: 0x8020800
        }
    ];

    // Masks that select the SBOX input
    var SBOX_MASK = [
        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
    ];

    /**
     * DES block cipher algorithm.
     */
    var DES = C_algo.DES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;

            // Select 56 bits according to PC1
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
                var keyBitPos = PC1[i] - 1;
                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
            }

            // Assemble 16 subkeys
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                // Create subkey
                var subKey = subKeys[nSubKey] = [];

                // Shortcut
                var bitShift = BIT_SHIFTS[nSubKey];

                // Select 48 bits according to PC2
                for (var i = 0; i < 24; i++) {
                    // Select from the left 28 key bits
                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

                    // Select from the right 28 key bits
                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
                }

                // Since each subkey is applied to an expanded 32-bit input,
                // the subkey can be broken into 8 values scaled to 32-bits,
                // which allows the key to be used without expansion
                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
                for (var i = 1; i < 7; i++) {
                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
                }
                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
            }

            // Compute inverse subkeys
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
                invSubKeys[i] = subKeys[15 - i];
            }
        },

        encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
        },

        decryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
        },

        _doCryptBlock: function (M, offset, subKeys) {
            // Get input
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];

            // Initial permutation
            exchangeLR.call(this, 4,  0x0f0f0f0f);
            exchangeLR.call(this, 16, 0x0000ffff);
            exchangeRL.call(this, 2,  0x33333333);
            exchangeRL.call(this, 8,  0x00ff00ff);
            exchangeLR.call(this, 1,  0x55555555);

            // Rounds
            for (var round = 0; round < 16; round++) {
                // Shortcuts
                var subKey = subKeys[round];
                var lBlock = this._lBlock;
                var rBlock = this._rBlock;

                // Feistel function
                var f = 0;
                for (var i = 0; i < 8; i++) {
                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                }
                this._lBlock = rBlock;
                this._rBlock = lBlock ^ f;
            }

            // Undo swap from last round
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;

            // Final permutation
            exchangeLR.call(this, 1,  0x55555555);
            exchangeRL.call(this, 8,  0x00ff00ff);
            exchangeRL.call(this, 2,  0x33333333);
            exchangeLR.call(this, 16, 0x0000ffff);
            exchangeLR.call(this, 4,  0x0f0f0f0f);

            // Set output
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
        },

        keySize: 64/32,

        ivSize: 64/32,

        blockSize: 64/32
    });

    // Swap bits across the left and right words
    function exchangeLR(offset, mask) {
        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
        this._rBlock ^= t;
        this._lBlock ^= t << offset;
    }

    function exchangeRL(offset, mask) {
        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
        this._lBlock ^= t;
        this._rBlock ^= t << offset;
    }

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
     */
    C.DES = BlockCipher._createHelper(DES);

    /**
     * Triple-DES block cipher algorithm.
     */
    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;

            // Create DES instances
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
        },

        encryptBlock: function (M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
        },

        decryptBlock: function (M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
        },

        keySize: 192/32,

        ivSize: 64/32,

        blockSize: 64/32
    });

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
     */
    C.TripleDES = BlockCipher._createHelper(TripleDES);
}());

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;

    /**
     * Base64 encoding strategy.
     */
    var Base64 = C_enc.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;

            // Clamp excess bits
            wordArray.clamp();

            // Convert
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                }
            }

            // Add padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                }
            }

            return base64Chars.join('');
        },

        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function (base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;

            // Ignore padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex != -1) {
                    base64StrLength = paddingIndex;
                }
            }

            // Convert
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                    nBytes++;
                }
            }

            return WordArray.create(words, nBytes);
        },

        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };
}());

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Constants table
    var T = [];

    // Compute constants
    (function () {
        for (var i = 0; i < 64; i++) {
            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
        }
    }());

    /**
     * MD5 hash algorithm.
     */
    var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Swap endian
            for (var i = 0; i < 16; i++) {
                // Shortcuts
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];

                M[offset_i] = (
                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                );
            }

            // Shortcuts
            var H = this._hash.words;

            var M_offset_0  = M[offset + 0];
            var M_offset_1  = M[offset + 1];
            var M_offset_2  = M[offset + 2];
            var M_offset_3  = M[offset + 3];
            var M_offset_4  = M[offset + 4];
            var M_offset_5  = M[offset + 5];
            var M_offset_6  = M[offset + 6];
            var M_offset_7  = M[offset + 7];
            var M_offset_8  = M[offset + 8];
            var M_offset_9  = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];

            // Working varialbes
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];

            // Computation
            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
            d = II(d, a, b, c, M_offset_7,  10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5,  21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
            d = II(d, a, b, c, M_offset_3,  10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1,  21, T[55]);
            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6,  15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2,  15, T[62]);
            b = II(b, c, d, a, M_offset_9,  21, T[63]);

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
            var nBitsTotalL = nBitsTotal;
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
            );
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
            );

            data.sigBytes = (dataWords.length + 1) * 4;

            // Hash final blocks
            this._process();

            // Shortcuts
            var hash = this._hash;
            var H = hash.words;

            // Swap endian
            for (var i = 0; i < 4; i++) {
                // Shortcut
                var H_i = H[i];

                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
            }

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    function FF(a, b, c, d, x, s, t) {
        var n = a + ((b & c) | (~b & d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function GG(a, b, c, d, x, s, t) {
        var n = a + ((b & d) | (c & ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function HH(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function II(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.MD5('message');
     *     var hash = CryptoJS.MD5(wordArray);
     */
    C.MD5 = Hasher._createHelper(MD5);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacMD5(message, key);
     */
    C.HmacMD5 = Hasher._createHmacHelper(MD5);
}(Math));

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Reusable object
    var W = [];

    /**
     * SHA-1 hash algorithm.
     */
    var SHA1 = C_algo.SHA1 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476,
                0xc3d2e1f0
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];

            // Computation
            for (var i = 0; i < 80; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                    W[i] = (n << 1) | (n >>> 31);
                }

                var t = ((a << 5) | (a >>> 27)) + e + W[i];
                if (i < 20) {
                    t += ((b & c) | (~b & d)) + 0x5a827999;
                } else if (i < 40) {
                    t += (b ^ c ^ d) + 0x6ed9eba1;
                } else if (i < 60) {
                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
                } else /* if (i < 80) */ {
                    t += (b ^ c ^ d) - 0x359d3e2a;
                }

                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA1('message');
     *     var hash = CryptoJS.SHA1(wordArray);
     */
    C.SHA1 = Hasher._createHelper(SHA1);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA1(message, key);
     */
    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
}());

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Initialization and round constants tables
    var H = [];
    var K = [];

    // Compute constants
    (function () {
        function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n % factor)) {
                    return false;
                }
            }

            return true;
        }

        function getFractionalBits(n) {
            return ((n - (n | 0)) * 0x100000000) | 0;
        }

        var n = 2;
        var nPrime = 0;
        while (nPrime < 64) {
            if (isPrime(n)) {
                if (nPrime < 8) {
                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                }
                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

                nPrime++;
            }

            n++;
        }
    }());

    // Reusable object
    var W = [];

    /**
     * SHA-256 hash algorithm.
     */
    var SHA256 = C_algo.SHA256 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init(H.slice(0));
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];

            // Computation
            for (var i = 0; i < 64; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var gamma0x = W[i - 15];
                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
                                   (gamma0x >>> 3);

                    var gamma1x = W[i - 2];
                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
                                   (gamma1x >>> 10);

                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                }

                var ch  = (e & f) ^ (~e & g);
                var maj = (a & b) ^ (a & c) ^ (b & c);

                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

                var t1 = h + sigma1 + ch + K[i] + W[i];
                var t2 = sigma0 + maj;

                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
            H[5] = (H[5] + f) | 0;
            H[6] = (H[6] + g) | 0;
            H[7] = (H[7] + h) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA256('message');
     *     var hash = CryptoJS.SHA256(wordArray);
     */
    C.SHA256 = Hasher._createHelper(SHA256);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA256(message, key);
     */
    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
}(Math));

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var SHA256 = C_algo.SHA256;

    /**
     * SHA-224 hash algorithm.
     */
    var SHA224 = C_algo.SHA224 = SHA256.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
            ]);
        },

        _doFinalize: function () {
            var hash = SHA256._doFinalize.call(this);

            hash.sigBytes -= 4;

            return hash;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA224('message');
     *     var hash = CryptoJS.SHA224(wordArray);
     */
    C.SHA224 = SHA256._createHelper(SHA224);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA224(message, key);
     */
    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
}());

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Hasher = C_lib.Hasher;
    var C_x64 = C.x64;
    var X64Word = C_x64.Word;
    var X64WordArray = C_x64.WordArray;
    var C_algo = C.algo;

    function X64Word_create() {
        return X64Word.create.apply(X64Word, arguments);
    }

    // Constants
    var K = [
        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
    ];

    // Reusable objects
    var W = [];
    (function () {
        for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
        }
    }());

    /**
     * SHA-512 hash algorithm.
     */
    var SHA512 = C_algo.SHA512 = Hasher.extend({
        _doReset: function () {
            this._hash = new X64WordArray.init([
                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Shortcuts
            var H = this._hash.words;

            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];

            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;

            // Working variables
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;

            // Rounds
            for (var i = 0; i < 80; i++) {
                // Shortcut
                var Wi = W[i];

                // Extend message
                if (i < 16) {
                    var Wih = Wi.high = M[offset + i * 2]     | 0;
                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
                } else {
                    // Gamma0
                    var gamma0x  = W[i - 15];
                    var gamma0xh = gamma0x.high;
                    var gamma0xl = gamma0x.low;
                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

                    // Gamma1
                    var gamma1x  = W[i - 2];
                    var gamma1xh = gamma1x.high;
                    var gamma1xl = gamma1x.low;
                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                    var Wi7  = W[i - 7];
                    var Wi7h = Wi7.high;
                    var Wi7l = Wi7.low;

                    var Wi16  = W[i - 16];
                    var Wi16h = Wi16.high;
                    var Wi16l = Wi16.low;

                    var Wil = gamma0l + Wi7l;
                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
                    var Wil = Wil + gamma1l;
                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
                    var Wil = Wil + Wi16l;
                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

                    Wi.high = Wih;
                    Wi.low  = Wil;
                }

                var chh  = (eh & fh) ^ (~eh & gh);
                var chl  = (el & fl) ^ (~el & gl);
                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

                // t1 = h + sigma1 + ch + K[i] + W[i]
                var Ki  = K[i];
                var Kih = Ki.high;
                var Kil = Ki.low;

                var t1l = hl + sigma1l;
                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
                var t1l = t1l + chl;
                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
                var t1l = t1l + Kil;
                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
                var t1l = t1l + Wil;
                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

                // t2 = sigma0 + maj
                var t2l = sigma0l + majl;
                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

                // Update working variables
                hh = gh;
                hl = gl;
                gh = fh;
                gl = fl;
                fh = eh;
                fl = el;
                el = (dl + t1l) | 0;
                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
                dh = ch;
                dl = cl;
                ch = bh;
                cl = bl;
                bh = ah;
                bl = al;
                al = (t1l + t2l) | 0;
                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
            }

            // Intermediate hash value
            H0l = H0.low  = (H0l + al);
            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
            H1l = H1.low  = (H1l + bl);
            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
            H2l = H2.low  = (H2l + cl);
            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
            H3l = H3.low  = (H3l + dl);
            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
            H4l = H4.low  = (H4l + el);
            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
            H5l = H5.low  = (H5l + fl);
            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
            H6l = H6.low  = (H6l + gl);
            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
            H7l = H7.low  = (H7l + hl);
            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Convert hash to 32-bit word array before returning
            var hash = this._hash.toX32();

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        },

        blockSize: 1024/32
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA512('message');
     *     var hash = CryptoJS.SHA512(wordArray);
     */
    C.SHA512 = Hasher._createHelper(SHA512);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA512(message, key);
     */
    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
}());

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_x64 = C.x64;
    var X64Word = C_x64.Word;
    var X64WordArray = C_x64.WordArray;
    var C_algo = C.algo;
    var SHA512 = C_algo.SHA512;

    /**
     * SHA-384 hash algorithm.
     */
    var SHA384 = C_algo.SHA384 = SHA512.extend({
        _doReset: function () {
            this._hash = new X64WordArray.init([
                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
            ]);
        },

        _doFinalize: function () {
            var hash = SHA512._doFinalize.call(this);

            hash.sigBytes -= 16;

            return hash;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA384('message');
     *     var hash = CryptoJS.SHA384(wordArray);
     */
    C.SHA384 = SHA512._createHelper(SHA384);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA384(message, key);
     */
    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
}());

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by Cdric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Constants table
    var _zl = WordArray.create([
        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
    var _zr = WordArray.create([
        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
    var _sl = WordArray.create([
         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
    var _sr = WordArray.create([
        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

    /**
     * RIPEMD160 hash algorithm.
     */
    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
        _doReset: function () {
            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
        },

        _doProcessBlock: function (M, offset) {

            // Swap endian
            for (var i = 0; i < 16; i++) {
                // Shortcuts
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];

                // Swap
                M[offset_i] = (
                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                );
            }
            // Shortcut
            var H  = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;

            // Working variables
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;

            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            // Computation
            var t;
            for (var i = 0; i < 80; i += 1) {
                t = (al +  M[offset+zl[i]])|0;
                if (i<16){
	            t +=  f1(bl,cl,dl) + hl[0];
                } else if (i<32) {
	            t +=  f2(bl,cl,dl) + hl[1];
                } else if (i<48) {
	            t +=  f3(bl,cl,dl) + hl[2];
                } else if (i<64) {
	            t +=  f4(bl,cl,dl) + hl[3];
                } else {// if (i<80) {
	            t +=  f5(bl,cl,dl) + hl[4];
                }
                t = t|0;
                t =  rotl(t,sl[i]);
                t = (t+el)|0;
                al = el;
                el = dl;
                dl = rotl(cl, 10);
                cl = bl;
                bl = t;

                t = (ar + M[offset+zr[i]])|0;
                if (i<16){
	            t +=  f5(br,cr,dr) + hr[0];
                } else if (i<32) {
	            t +=  f4(br,cr,dr) + hr[1];
                } else if (i<48) {
	            t +=  f3(br,cr,dr) + hr[2];
                } else if (i<64) {
	            t +=  f2(br,cr,dr) + hr[3];
                } else {// if (i<80) {
	            t +=  f1(br,cr,dr) + hr[4];
                }
                t = t|0;
                t =  rotl(t,sr[i]) ;
                t = (t+er)|0;
                ar = er;
                er = dr;
                dr = rotl(cr, 10);
                cr = br;
                br = t;
            }
            // Intermediate hash value
            t    = (H[1] + cl + dr)|0;
            H[1] = (H[2] + dl + er)|0;
            H[2] = (H[3] + el + ar)|0;
            H[3] = (H[4] + al + br)|0;
            H[4] = (H[0] + bl + cr)|0;
            H[0] =  t;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
            );
            data.sigBytes = (dataWords.length + 1) * 4;

            // Hash final blocks
            this._process();

            // Shortcuts
            var hash = this._hash;
            var H = hash.words;

            // Swap endian
            for (var i = 0; i < 5; i++) {
                // Shortcut
                var H_i = H[i];

                // Swap
                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
            }

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });


    function f1(x, y, z) {
        return ((x) ^ (y) ^ (z));

    }

    function f2(x, y, z) {
        return (((x)&(y)) | ((~x)&(z)));
    }

    function f3(x, y, z) {
        return (((x) | (~(y))) ^ (z));
    }

    function f4(x, y, z) {
        return (((x) & (z)) | ((y)&(~(z))));
    }

    function f5(x, y, z) {
        return ((x) ^ ((y) |(~(z))));

    }

    function rotl(x,n) {
        return (x<<n) | (x>>>(32-n));
    }


    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.RIPEMD160('message');
     *     var hash = CryptoJS.RIPEMD160(wordArray);
     */
    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
     */
    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
}(Math));

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var C_algo = C.algo;

    /**
     * HMAC algorithm.
     */
    var HMAC = C_algo.HMAC = Base.extend({
        /**
         * Initializes a newly created HMAC.
         *
         * @param {Hasher} hasher The hash algorithm to use.
         * @param {WordArray|string} key The secret key.
         *
         * @example
         *
         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
         */
        init: function (hasher, key) {
            // Init hasher
            hasher = this._hasher = new hasher.init();

            // Convert string to WordArray, else assume WordArray already
            if (typeof key == 'string') {
                key = Utf8.parse(key);
            }

            // Shortcuts
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;

            // Allow arbitrary length keys
            if (key.sigBytes > hasherBlockSizeBytes) {
                key = hasher.finalize(key);
            }

            // Clamp excess bits
            key.clamp();

            // Clone key for inner and outer pads
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();

            // Shortcuts
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;

            // XOR keys with pad constants
            for (var i = 0; i < hasherBlockSize; i++) {
                oKeyWords[i] ^= 0x5c5c5c5c;
                iKeyWords[i] ^= 0x36363636;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this HMAC to its initial state.
         *
         * @example
         *
         *     hmacHasher.reset();
         */
        reset: function () {
            // Shortcut
            var hasher = this._hasher;

            // Reset
            hasher.reset();
            hasher.update(this._iKey);
        },

        /**
         * Updates this HMAC with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {HMAC} This HMAC instance.
         *
         * @example
         *
         *     hmacHasher.update('message');
         *     hmacHasher.update(wordArray);
         */
        update: function (messageUpdate) {
            this._hasher.update(messageUpdate);

            // Chainable
            return this;
        },

        /**
         * Finalizes the HMAC computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The HMAC.
         *
         * @example
         *
         *     var hmac = hmacHasher.finalize();
         *     var hmac = hmacHasher.finalize('message');
         *     var hmac = hmacHasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Shortcut
            var hasher = this._hasher;

            // Compute HMAC
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

            return hmac;
        }
    });
}());

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var SHA1 = C_algo.SHA1;
    var HMAC = C_algo.HMAC;

    /**
     * Password-Based Key Derivation Function 2 algorithm.
     */
    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
        /**
         * Configuration options.
         *
         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
         * @property {Hasher} hasher The hasher to use. Default: SHA1
         * @property {number} iterations The number of iterations to perform. Default: 1
         */
        cfg: Base.extend({
            keySize: 128/32,
            hasher: SHA1,
            iterations: 1
        }),

        /**
         * Initializes a newly created key derivation function.
         *
         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
         *
         * @example
         *
         *     var kdf = CryptoJS.algo.PBKDF2.create();
         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
         */
        init: function (cfg) {
            this.cfg = this.cfg.extend(cfg);
        },

        /**
         * Computes the Password-Based Key Derivation Function 2.
         *
         * @param {WordArray|string} password The password.
         * @param {WordArray|string} salt A salt.
         *
         * @return {WordArray} The derived key.
         *
         * @example
         *
         *     var key = kdf.compute(password, salt);
         */
        compute: function (password, salt) {
            // Shortcut
            var cfg = this.cfg;

            // Init HMAC
            var hmac = HMAC.create(cfg.hasher, password);

            // Initial values
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([0x00000001]);

            // Shortcuts
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;

            // Generate key
            while (derivedKeyWords.length < keySize) {
                var block = hmac.update(salt).finalize(blockIndex);
                hmac.reset();

                // Shortcuts
                var blockWords = block.words;
                var blockWordsLength = blockWords.length;

                // Iterations
                var intermediate = block;
                for (var i = 1; i < iterations; i++) {
                    intermediate = hmac.finalize(intermediate);
                    hmac.reset();

                    // Shortcut
                    var intermediateWords = intermediate.words;

                    // XOR intermediate with block
                    for (var j = 0; j < blockWordsLength; j++) {
                        blockWords[j] ^= intermediateWords[j];
                    }
                }

                derivedKey.concat(block);
                blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;

            return derivedKey;
        }
    });

    /**
     * Computes the Password-Based Key Derivation Function 2.
     *
     * @param {WordArray|string} password The password.
     * @param {WordArray|string} salt A salt.
     * @param {Object} cfg (Optional) The configuration options to use for this computation.
     *
     * @return {WordArray} The derived key.
     *
     * @static
     *
     * @example
     *
     *     var key = CryptoJS.PBKDF2(password, salt);
     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
     */
    C.PBKDF2 = function (password, salt, cfg) {
        return PBKDF2.create(cfg).compute(password, salt);
    };
}());

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad="=";

function hex2b64(h) {
  var i;
  var c;
  var ret = "";
  for(i = 0; i+3 <= h.length; i+=3) {
    c = parseInt(h.substring(i,i+3),16);
    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
  }
  if(i+1 == h.length) {
    c = parseInt(h.substring(i,i+1),16);
    ret += b64map.charAt(c << 2);
  }
  else if(i+2 == h.length) {
    c = parseInt(h.substring(i,i+2),16);
    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
  }
  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;
  return ret;
}

// convert a base64 string to hex
function b64tohex(s) {
  var ret = ""
  var i;
  var k = 0; // b64 state, 0-3
  var slop;
  var v;
  for(i = 0; i < s.length; ++i) {
    if(s.charAt(i) == b64pad) break;
    v = b64map.indexOf(s.charAt(i));
    if(v < 0) continue;
    if(k == 0) {
      ret += int2char(v >> 2);
      slop = v & 3;
      k = 1;
    }
    else if(k == 1) {
      ret += int2char((slop << 2) | (v >> 4));
      slop = v & 0xf;
      k = 2;
    }
    else if(k == 2) {
      ret += int2char(slop);
      ret += int2char(v >> 2);
      slop = v & 3;
      k = 3;
    }
    else {
      ret += int2char((slop << 2) | (v >> 4));
      ret += int2char(v & 0xf);
      k = 0;
    }
  }
  if(k == 1)
    ret += int2char(slop << 2);
  return ret;
}

// convert a base64 string to a byte/number array
function b64toBA(s) {
  //piggyback on b64tohex for now, optimize later
  var h = b64tohex(s);
  var i;
  var a = new Array();
  for(i = 0; 2*i < h.length; ++i) {
    a[i] = parseInt(h.substring(2*i,2*i+2),16);
  }
  return a;
}

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Basic JavaScript BN library - subset useful for RSA encryption.

// Bits per digit
var dbits;

// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary&0xffffff)==0xefcafe);

// (public) Constructor
function BigInteger(a,b,c) {
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null && "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}

// return new, unset BigInteger
function nbi() { return new BigInteger(null); }

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i,x,w,j,c,n) {
  while(--n >= 0) {
    var v = x*this[i++]+w[j]+c;
    c = Math.floor(v/0x4000000);
    w[j++] = v&0x3ffffff;
  }
  return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i,x,w,j,c,n) {
  var xl = x&0x7fff, xh = x>>15;
  while(--n >= 0) {
    var l = this[i]&0x7fff;
    var h = this[i++]>>15;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
    w[j++] = l&0x3fffffff;
  }
  return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i,x,w,j,c,n) {
  var xl = x&0x3fff, xh = x>>14;
  while(--n >= 0) {
    var l = this[i]&0x3fff;
    var h = this[i++]>>14;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x3fff)<<14)+w[j]+c;
    c = (l>>28)+(m>>14)+xh*h;
    w[j++] = l&0xfffffff;
  }
  return c;
}
if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
  BigInteger.prototype.am = am2;
  dbits = 30;
}
else if(j_lm && (navigator.appName != "Netscape")) {
  BigInteger.prototype.am = am1;
  dbits = 26;
}
else { // Mozilla/Netscape seems to prefer am3
  BigInteger.prototype.am = am3;
  dbits = 28;
}

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1<<dbits)-1);
BigInteger.prototype.DV = (1<<dbits);

var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2,BI_FP);
BigInteger.prototype.F1 = BI_FP-dbits;
BigInteger.prototype.F2 = 2*dbits-BI_FP;

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr,vv;
rr = "0".charCodeAt(0);
for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

function int2char(n) { return BI_RM.charAt(n); }
function intAt(s,i) {
  var c = BI_RC[s.charCodeAt(i)];
  return (c==null)?-1:c;
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
  r.t = this.t;
  r.s = this.s;
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1;
  this.s = (x<0)?-1:0;
  if(x > 0) this[0] = x;
  else if(x < -1) this[0] = x+this.DV;
  else this.t = 0;
}

// return bigint initialized to value
function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

// (protected) set from string and radix
function bnpFromString(s,b) {
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 256) k = 8; // byte array
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else { this.fromRadix(s,b); return; }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while(--i >= 0) {
    var x = (k==8)?s[i]&0xff:intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if(sh == 0)
      this[this.t++] = x;
    else if(sh+k > this.DB) {
      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
      this[this.t++] = (x>>(this.DB-sh));
    }
    else
      this[this.t-1] |= x<<sh;
    sh += k;
    if(sh >= this.DB) sh -= this.DB;
  }
  if(k == 8 && (s[0]&0x80) != 0) {
    this.s = -1;
    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s&this.DM;
  while(this.t > 0 && this[this.t-1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
  if(this.s < 0) return "-"+this.negate().toString(b);
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1<<k)-1, d, m = false, r = "", i = this.t;
  var p = this.DB-(i*this.DB)%k;
  if(i-- > 0) {
    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
    while(i >= 0) {
      if(p < k) {
        d = (this[i]&((1<<p)-1))<<(k-p);
        d |= this[--i]>>(p+=this.DB-k);
      }
      else {
        d = (this[i]>>(p-=k))&km;
        if(p <= 0) { p += this.DB; --i; }
      }
      if(d > 0) m = true;
      if(m) r += int2char(d);
    }
  }
  return m?r:"0";
}

// (public) -this
function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

// (public) |this|
function bnAbs() { return (this.s<0)?this.negate():this; }

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s-a.s;
  if(r != 0) return r;
  var i = this.t;
  r = i-a.t;
  if(r != 0) return (this.s<0)?-r:r;
  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
  return 0;
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1, t;
  if((t=x>>>16) != 0) { x = t; r += 16; }
  if((t=x>>8) != 0) { x = t; r += 8; }
  if((t=x>>4) != 0) { x = t; r += 4; }
  if((t=x>>2) != 0) { x = t; r += 2; }
  if((t=x>>1) != 0) { x = t; r += 1; }
  return r;
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if(this.t <= 0) return 0;
  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n,r) {
  var i;
  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
  for(i = n-1; i >= 0; --i) r[i] = 0;
  r.t = this.t+n;
  r.s = this.s;
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n,r) {
  for(var i = n; i < this.t; ++i) r[i-n] = this[i];
  r.t = Math.max(this.t-n,0);
  r.s = this.s;
}

// (protected) r = this << n
function bnpLShiftTo(n,r) {
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<cbs)-1;
  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
  for(i = this.t-1; i >= 0; --i) {
    r[i+ds+1] = (this[i]>>cbs)|c;
    c = (this[i]&bm)<<bs;
  }
  for(i = ds-1; i >= 0; --i) r[i] = 0;
  r[ds] = c;
  r.t = this.t+ds+1;
  r.s = this.s;
  r.clamp();
}

// (protected) r = this >> n
function bnpRShiftTo(n,r) {
  r.s = this.s;
  var ds = Math.floor(n/this.DB);
  if(ds >= this.t) { r.t = 0; return; }
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<bs)-1;
  r[0] = this[ds]>>bs;
  for(var i = ds+1; i < this.t; ++i) {
    r[i-ds-1] |= (this[i]&bm)<<cbs;
    r[i-ds] = this[i]>>bs;
  }
  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
  r.t = this.t-ds;
  r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a,r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this[i]-a[i];
    r[i++] = c&this.DM;
    c >>= this.DB;
  }
  if(a.t < this.t) {
    c -= a.s;
    while(i < this.t) {
      c += this[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c -= a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = (c<0)?-1:0;
  if(c < -1) r[i++] = this.DV+c;
  else if(c > 0) r[i++] = c;
  r.t = i;
  r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i+y.t;
  while(--i >= 0) r[i] = 0;
  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2*x.t;
  while(--i >= 0) r[i] = 0;
  for(i = 0; i < x.t-1; ++i) {
    var c = x.am(i,x[i],r,2*i,0,1);
    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
      r[i+x.t] -= x.DV;
      r[i+x.t+1] = 1;
    }
  }
  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
  r.s = 0;
  r.clamp();
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r) {
  var pm = m.abs();
  if(pm.t <= 0) return;
  var pt = this.abs();
  if(pt.t < pm.t) {
    if(q != null) q.fromInt(0);
    if(r != null) this.copyTo(r);
    return;
  }
  if(r == null) r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
  else { pm.copyTo(y); pt.copyTo(r); }
  var ys = y.t;
  var y0 = y[ys-1];
  if(y0 == 0) return;
  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
  y.dlShiftTo(j,t);
  if(r.compareTo(t) >= 0) {
    r[r.t++] = 1;
    r.subTo(t,r);
  }
  BigInteger.ONE.dlShiftTo(ys,t);
  t.subTo(y,y);	// "negative" y so we can replace sub with am later
  while(y.t < ys) y[y.t++] = 0;
  while(--j >= 0) {
    // Estimate quotient digit
    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r[i] < --qd) r.subTo(t,r);
    }
  }
  if(q != null) {
    r.drShiftTo(ys,q);
    if(ts != ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
  if(ts < 0) BigInteger.ZERO.subTo(r,r);
}

// (public) this mod a
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a,null,r);
  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
  return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if(this.t < 1) return 0;
  var x = this[0];
  if((x&1) == 0) return 0;
  var y = x&3;		// y == 1/x mod 2^2
  y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
  y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly;
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y>0)?this.DV-y:-y;
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp&0x7fff;
  this.mph = this.mp>>15;
  this.um = (1<<(m.DB-15))-1;
  this.mt2 = 2*m.t;
}

// xR mod m
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t,r);
  r.divRemTo(this.m,null,r);
  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
  return r;
}

// x/R mod m
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while(x.t <= this.mt2)	// pad x so am has enough room later
    x[x.t++] = 0;
  for(var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x[i]*mp mod DV
    var j = x[i]&0x7fff;
    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
    // use am to combine the multiply-shift-add into one call
    j = i+this.m.t;
    x[j] += this.m.am(0,u0,x,i,0,this.m.t);
    // propagate carry
    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
  }
  x.clamp();
  x.drShiftTo(this.m.t,x);
  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

// r = "xy/R mod m"; x,y != r
function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

// (protected) true iff this is even
function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e,z) {
  if(e > 0xffffffff || e < 1) return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
  g.copyTo(r);
  while(--i >= 0) {
    z.sqrTo(r,r2);
    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
    else { var t = r; r = r2; r2 = t; }
  }
  return z.revert(r);
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e,m) {
  var z;
  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

// public
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
// Copyright (c) 2005-2009  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Extended JavaScript BN functions, required for RSA private ops.

// Version 1.1: new BigInteger("0", 10) returns "proper" zero
// Version 1.2: square() API, isProbablePrime fix

// (public)
function bnClone() { var r = nbi(); this.copyTo(r); return r; }

// (public) return value as integer
function bnIntValue() {
  if(this.s < 0) {
    if(this.t == 1) return this[0]-this.DV;
    else if(this.t == 0) return -1;
  }
  else if(this.t == 1) return this[0];
  else if(this.t == 0) return 0;
  // assumes 16 < DB < 32
  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
}

// (public) return value as byte
function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

// (public) return value as short (assumes DB>=16)
function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

// (protected) return x s.t. r^x < DV
function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

// (public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
  if(this.s < 0) return -1;
  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
  else return 1;
}

// (protected) convert to radix string
function bnpToRadix(b) {
  if(b == null) b = 10;
  if(this.signum() == 0 || b < 2 || b > 36) return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b,cs);
  var d = nbv(a), y = nbi(), z = nbi(), r = "";
  this.divRemTo(d,y,z);
  while(y.signum() > 0) {
    r = (a+z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d,y,z);
  }
  return z.intValue().toString(b) + r;
}

// (protected) convert from radix string
function bnpFromRadix(s,b) {
  this.fromInt(0);
  if(b == null) b = 10;
  var cs = this.chunkSize(b);
  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
  for(var i = 0; i < s.length; ++i) {
    var x = intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
      continue;
    }
    w = b*w+x;
    if(++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w,0);
      j = 0;
      w = 0;
    }
  }
  if(j > 0) {
    this.dMultiply(Math.pow(b,j));
    this.dAddOffset(w,0);
  }
  if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) alternate constructor
function bnpFromNumber(a,b,c) {
  if("number" == typeof b) {
    // new BigInteger(int,int,RNG)
    if(a < 2) this.fromInt(1);
    else {
      this.fromNumber(a,c);
      if(!this.testBit(a-1))	// force MSB set
        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
      if(this.isEven()) this.dAddOffset(1,0); // force odd
      while(!this.isProbablePrime(b)) {
        this.dAddOffset(2,0);
        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
      }
    }
  }
  else {
    // new BigInteger(int,RNG)
    var x = new Array(), t = a&7;
    x.length = (a>>3)+1;
    b.nextBytes(x);
    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
    this.fromString(x,256);
  }
}

// (public) convert to bigendian byte array
function bnToByteArray() {
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB-(i*this.DB)%8, d, k = 0;
  if(i-- > 0) {
    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
      r[k++] = d|(this.s<<(this.DB-p));
    while(i >= 0) {
      if(p < 8) {
        d = (this[i]&((1<<p)-1))<<(8-p);
        d |= this[--i]>>(p+=this.DB-8);
      }
      else {
        d = (this[i]>>(p-=8))&0xff;
        if(p <= 0) { p += this.DB; --i; }
      }
      if((d&0x80) != 0) d |= -256;
      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
      if(k > 0 || d != this.s) r[k++] = d;
    }
  }
  return r;
}

function bnEquals(a) { return(this.compareTo(a)==0); }
function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

// (protected) r = this op a (bitwise)
function bnpBitwiseTo(a,op,r) {
  var i, f, m = Math.min(a.t,this.t);
  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
  if(a.t < this.t) {
    f = a.s&this.DM;
    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
    r.t = this.t;
  }
  else {
    f = this.s&this.DM;
    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
    r.t = a.t;
  }
  r.s = op(this.s,a.s);
  r.clamp();
}

// (public) this & a
function op_and(x,y) { return x&y; }
function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

// (public) this | a
function op_or(x,y) { return x|y; }
function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

// (public) this ^ a
function op_xor(x,y) { return x^y; }
function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

// (public) this & ~a
function op_andnot(x,y) { return x&~y; }
function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

// (public) ~this
function bnNot() {
  var r = nbi();
  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}

// (public) this << n
function bnShiftLeft(n) {
  var r = nbi();
  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
  return r;
}

// (public) this >> n
function bnShiftRight(n) {
  var r = nbi();
  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
  return r;
}

// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
  if(x == 0) return -1;
  var r = 0;
  if((x&0xffff) == 0) { x >>= 16; r += 16; }
  if((x&0xff) == 0) { x >>= 8; r += 8; }
  if((x&0xf) == 0) { x >>= 4; r += 4; }
  if((x&3) == 0) { x >>= 2; r += 2; }
  if((x&1) == 0) ++r;
  return r;
}

// (public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
  for(var i = 0; i < this.t; ++i)
    if(this[i] != 0) return i*this.DB+lbit(this[i]);
  if(this.s < 0) return this.t*this.DB;
  return -1;
}

// return number of 1 bits in x
function cbit(x) {
  var r = 0;
  while(x != 0) { x &= x-1; ++r; }
  return r;
}

// (public) return number of set bits
function bnBitCount() {
  var r = 0, x = this.s&this.DM;
  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
  return r;
}

// (public) true iff nth bit is set
function bnTestBit(n) {
  var j = Math.floor(n/this.DB);
  if(j >= this.t) return(this.s!=0);
  return((this[j]&(1<<(n%this.DB)))!=0);
}

// (protected) this op (1<<n)
function bnpChangeBit(n,op) {
  var r = BigInteger.ONE.shiftLeft(n);
  this.bitwiseTo(r,op,r);
  return r;
}

// (public) this | (1<<n)
function bnSetBit(n) { return this.changeBit(n,op_or); }

// (public) this & ~(1<<n)
function bnClearBit(n) { return this.changeBit(n,op_andnot); }

// (public) this ^ (1<<n)
function bnFlipBit(n) { return this.changeBit(n,op_xor); }

// (protected) r = this + a
function bnpAddTo(a,r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this[i]+a[i];
    r[i++] = c&this.DM;
    c >>= this.DB;
  }
  if(a.t < this.t) {
    c += a.s;
    while(i < this.t) {
      c += this[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c += a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = (c<0)?-1:0;
  if(c > 0) r[i++] = c;
  else if(c < -1) r[i++] = this.DV+c;
  r.t = i;
  r.clamp();
}

// (public) this + a
function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

// (public) this - a
function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

// (public) this * a
function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

// (public) this^2
function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

// (public) this / a
function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

// (public) this % a
function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

// (public) [this/a,this%a]
function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a,q,r);
  return new Array(q,r);
}

// (protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
  this[this.t] = this.am(0,n-1,this,0,0,this.t);
  ++this.t;
  this.clamp();
}

// (protected) this += n << w words, this >= 0
function bnpDAddOffset(n,w) {
  if(n == 0) return;
  while(this.t <= w) this[this.t++] = 0;
  this[w] += n;
  while(this[w] >= this.DV) {
    this[w] -= this.DV;
    if(++w >= this.t) this[this.t++] = 0;
    ++this[w];
  }
}

// A "null" reducer
function NullExp() {}
function nNop(x) { return x; }
function nMulTo(x,y,r) { x.multiplyTo(y,r); }
function nSqrTo(x,r) { x.squareTo(r); }

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

// (public) this^e
function bnPow(e) { return this.exp(e,new NullExp()); }

// (protected) r = lower n words of "this * a", a.t <= n
// "this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a,n,r) {
  var i = Math.min(this.t+a.t,n);
  r.s = 0; // assumes a,this >= 0
  r.t = i;
  while(i > 0) r[--i] = 0;
  var j;
  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
  r.clamp();
}

// (protected) r = "this * a" without lower n words, n > 0
// "this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a,n,r) {
  --n;
  var i = r.t = this.t+a.t-n;
  r.s = 0; // assumes a,this >= 0
  while(--i >= 0) r[i] = 0;
  for(i = Math.max(n-this.t,0); i < a.t; ++i)
    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
  r.clamp();
  r.drShiftTo(1,r);
}

// Barrett modular reduction
function Barrett(m) {
  // setup Barrett
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
}

function barrettConvert(x) {
  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
  else if(x.compareTo(this.m) < 0) return x;
  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
}

function barrettRevert(x) { return x; }

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
  x.drShiftTo(this.m.t-1,this.r2);
  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
  x.subTo(this.r2,x);
  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

// r = x^2 mod m; x != r
function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

// r = x*y mod m; x,y != r
function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

// (public) this^e % m (HAC 14.85)
function bnModPow(e,m) {
  var i = e.bitLength(), k, r = nbv(1), z;
  if(i <= 0) return r;
  else if(i < 18) k = 1;
  else if(i < 48) k = 3;
  else if(i < 144) k = 4;
  else if(i < 768) k = 5;
  else k = 6;
  if(i < 8)
    z = new Classic(m);
  else if(m.isEven())
    z = new Barrett(m);
  else
    z = new Montgomery(m);

  // precomputation
  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
  g[1] = z.convert(this);
  if(k > 1) {
    var g2 = nbi();
    z.sqrTo(g[1],g2);
    while(n <= km) {
      g[n] = nbi();
      z.mulTo(g2,g[n-2],g[n]);
      n += 2;
    }
  }

  var j = e.t-1, w, is1 = true, r2 = nbi(), t;
  i = nbits(e[j])-1;
  while(j >= 0) {
    if(i >= k1) w = (e[j]>>(i-k1))&km;
    else {
      w = (e[j]&((1<<(i+1))-1))<<(k1-i);
      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
    }

    n = k;
    while((w&1) == 0) { w >>= 1; --n; }
    if((i -= n) < 0) { i += this.DB; --j; }
    if(is1) {	// ret == 1, don't bother squaring or multiplying it
      g[w].copyTo(r);
      is1 = false;
    }
    else {
      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
      z.mulTo(r2,g[w],r);
    }

    while(j >= 0 && (e[j]&(1<<i)) == 0) {
      z.sqrTo(r,r2); t = r; r = r2; r2 = t;
      if(--i < 0) { i = this.DB-1; --j; }
    }
  }
  return z.revert(r);
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
  var x = (this.s<0)?this.negate():this.clone();
  var y = (a.s<0)?a.negate():a.clone();
  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
  if(g < 0) return x;
  if(i < g) g = i;
  if(g > 0) {
    x.rShiftTo(g,x);
    y.rShiftTo(g,y);
  }
  while(x.signum() > 0) {
    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
    if(x.compareTo(y) >= 0) {
      x.subTo(y,x);
      x.rShiftTo(1,x);
    }
    else {
      y.subTo(x,y);
      y.rShiftTo(1,y);
    }
  }
  if(g > 0) y.lShiftTo(g,y);
  return y;
}

// (protected) this % n, n < 2^26
function bnpModInt(n) {
  if(n <= 0) return 0;
  var d = this.DV%n, r = (this.s<0)?n-1:0;
  if(this.t > 0)
    if(d == 0) r = this[0]%n;
    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
  return r;
}

// (public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
  var ac = m.isEven();
  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
  var u = m.clone(), v = this.clone();
  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
  while(u.signum() != 0) {
    while(u.isEven()) {
      u.rShiftTo(1,u);
      if(ac) {
        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
        a.rShiftTo(1,a);
      }
      else if(!b.isEven()) b.subTo(m,b);
      b.rShiftTo(1,b);
    }
    while(v.isEven()) {
      v.rShiftTo(1,v);
      if(ac) {
        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
        c.rShiftTo(1,c);
      }
      else if(!d.isEven()) d.subTo(m,d);
      d.rShiftTo(1,d);
    }
    if(u.compareTo(v) >= 0) {
      u.subTo(v,u);
      if(ac) a.subTo(c,a);
      b.subTo(d,b);
    }
    else {
      v.subTo(u,v);
      if(ac) c.subTo(a,c);
      d.subTo(b,d);
    }
  }
  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
  if(d.compareTo(m) >= 0) return d.subtract(m);
  if(d.signum() < 0) d.addTo(m,d); else return d;
  if(d.signum() < 0) return d.add(m); else return d;
}

var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
var lplim = (1<<26)/lowprimes[lowprimes.length-1];

// (public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
  var i, x = this.abs();
  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
    for(i = 0; i < lowprimes.length; ++i)
      if(x[0] == lowprimes[i]) return true;
    return false;
  }
  if(x.isEven()) return false;
  i = 1;
  while(i < lowprimes.length) {
    var m = lowprimes[i], j = i+1;
    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
    m = x.modInt(m);
    while(i < j) if(m%lowprimes[i++] == 0) return false;
  }
  return x.millerRabin(t);
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE);
  var k = n1.getLowestSetBit();
  if(k <= 0) return false;
  var r = n1.shiftRight(k);
  t = (t+1)>>1;
  if(t > lowprimes.length) t = lowprimes.length;
  var a = nbi();
  for(var i = 0; i < t; ++i) {
    //Pick bases at random, instead of starting at 2
    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
    var y = a.modPow(r,this);
    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1;
      while(j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2,this);
        if(y.compareTo(BigInteger.ONE) == 0) return false;
      }
      if(y.compareTo(n1) != 0) return false;
    }
  }
  return true;
}

// protected
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;

// public
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

// JSBN-specific extension
BigInteger.prototype.square = bnSquare;

// BigInteger interfaces not implemented in jsbn:

// BigInteger(int signum, byte[] magnitude)
// double doubleValue()
// float floatValue()
// int hashCode()
// long longValue()
// static BigInteger valueOf(long val)

BigInteger.prototype.sqrt = function() {
    var div = BigInteger.ZERO.setBit(this.bitLength()/2);
    var div2 = div;
    for (;;) {
	var y = div.add(this.divide(div)).shiftRight(1);
	if (y.equals(div) || y.equals(div2))
	    return y;
	div2 = div;
	div = y;
    }
}


/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
// prng4.js - uses Arcfour as a PRNG

function Arcfour() {
  this.i = 0;
  this.j = 0;
  this.S = new Array();
}

// Initialize arcfour context from key, an array of ints, each from [0..255]
function ARC4init(key) {
  var i, j, t;
  for(i = 0; i < 256; ++i)
    this.S[i] = i;
  j = 0;
  for(i = 0; i < 256; ++i) {
    j = (j + this.S[i] + key[i % key.length]) & 255;
    t = this.S[i];
    this.S[i] = this.S[j];
    this.S[j] = t;
  }
  this.i = 0;
  this.j = 0;
}

function ARC4next() {
  var t;
  this.i = (this.i + 1) & 255;
  this.j = (this.j + this.S[this.i]) & 255;
  t = this.S[this.i];
  this.S[this.i] = this.S[this.j];
  this.S[this.j] = t;
  return this.S[(t + this.S[this.i]) & 255];
}

Arcfour.prototype.init = ARC4init;
Arcfour.prototype.next = ARC4next;

// Plug in your RNG constructor here
function prng_newstate() {
  return new Arcfour();
}

// Pool size must be a multiple of 4 and greater than 32.
// An array of bytes the size of the pool will be passed to init()
var rng_psize = 256;

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
// Random number generator - requires a PRNG backend, e.g. prng4.js

// For best results, put code like
// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
// in your main HTML document.

var rng_state;
var rng_pool;
var rng_pptr;

// Mix in a 32-bit integer into the pool
function rng_seed_int(x) {
  rng_pool[rng_pptr++] ^= x & 255;
  rng_pool[rng_pptr++] ^= (x >> 8) & 255;
  rng_pool[rng_pptr++] ^= (x >> 16) & 255;
  rng_pool[rng_pptr++] ^= (x >> 24) & 255;
  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
}

// Mix in the current time (w/milliseconds) into the pool
function rng_seed_time() {
  rng_seed_int(new Date().getTime());
}

// Initialize the pool with junk if needed.
if (rng_pool == null) {
  rng_pool = new Array();
  rng_pptr = 0;
  var t;
  if (typeof window !== "undefined" &&
      (window.crypto !== undefined ||
       window.msCrypto !== undefined)) {
    var crypto = window.crypto || window.msCrypto;
    if (crypto.getRandomValues) {
      // Use webcrypto if available
      var ua = new Uint8Array(32);
      crypto.getRandomValues(ua);
      for(t = 0; t < 32; ++t)
        rng_pool[rng_pptr++] = ua[t];
    } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
      // Extract entropy (256 bits) from NS4 RNG if available
      var z = window.crypto.random(32);
      for(t = 0; t < z.length; ++t)
        rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
    }
  }  
  while (rng_pptr < rng_psize) {  // extract some randomness from Math.random()
    t = Math.floor(65536 * Math.random());
    rng_pool[rng_pptr++] = t >>> 8;
    rng_pool[rng_pptr++] = t & 255;
  }
  rng_pptr = 0;
  rng_seed_time();
  //rng_seed_int(window.screenX);
  //rng_seed_int(window.screenY);
}

function rng_get_byte() {
  if (rng_state == null) {
    rng_seed_time();
    rng_state = prng_newstate();
    rng_state.init(rng_pool);
    for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
      rng_pool[rng_pptr] = 0;
    rng_pptr = 0;
    //rng_pool = null;
  }
  // TODO: allow reseeding after first request
  return rng_state.next();
}

function rng_get_bytes(ba) {
  var i;
  for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
}

function SecureRandom() {}

SecureRandom.prototype.nextBytes = rng_get_bytes;

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
// Depends on jsbn.js and rng.js

// Version 1.1: support utf-8 encoding in pkcs1pad2

// convert a (hex) string to a bignum object
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

function linebrk(s,n) {
  var ret = "";
  var i = 0;
  while(i + n < s.length) {
    ret += s.substring(i,i+n) + "\n";
    i += n;
  }
  return ret + s.substring(i,s.length);
}

function byte2Hex(b) {
  if(b < 0x10)
    return "0" + b.toString(16);
  else
    return b.toString(16);
}

// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s,n) {
  if(n < s.length + 11) { // TODO: fix for utf-8
    throw "Message too long for RSA";
    return null;
  }
  var ba = new Array();
  var i = s.length - 1;
  while(i >= 0 && n > 0) {
    var c = s.charCodeAt(i--);
    if(c < 128) { // encode using utf-8
      ba[--n] = c;
    }
    else if((c > 127) && (c < 2048)) {
      ba[--n] = (c & 63) | 128;
      ba[--n] = (c >> 6) | 192;
    }
    else {
      ba[--n] = (c & 63) | 128;
      ba[--n] = ((c >> 6) & 63) | 128;
      ba[--n] = (c >> 12) | 224;
    }
  }
  ba[--n] = 0;
  var rng = new SecureRandom();
  var x = new Array();
  while(n > 2) { // random non-zero pad
    x[0] = 0;
    while(x[0] == 0) rng.nextBytes(x);
    ba[--n] = x[0];
  }
  ba[--n] = 2;
  ba[--n] = 0;
  return new BigInteger(ba);
}

// PKCS#1 (OAEP) mask generation function
function oaep_mgf1_arr(seed, len, hash)
{
    var mask = '', i = 0;

    while (mask.length < len)
    {
        mask += hash(String.fromCharCode.apply(String, seed.concat([
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff])));
        i += 1;
    }

    return mask;
}

/**
 * PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint
 * @name oaep_pad
 * @param s raw string of message
 * @param n key length of RSA key
 * @param hash JavaScript function to calculate raw hash value from raw string or algorithm name (ex. "SHA1") 
 * @param hashLen byte length of resulted hash value (ex. 20 for SHA1)
 * @return {BigInteger} BigInteger object of resulted PKCS#1 OAEP padded message
 * @description
 * This function calculates OAEP padded message from original message.<br/>
 * NOTE: Since jsrsasign 6.2.0, 'hash' argument can accept an algorithm name such as "sha1".
 * @example
 * oaep_pad("aaa", 128) &rarr; big integer object // SHA-1 by default
 * oaep_pad("aaa", 128, function(s) {...}, 20);
 * oaep_pad("aaa", 128, "sha1");
 */
function oaep_pad(s, n, hash, hashLen) {
    var MD = KJUR.crypto.MessageDigest;
    var Util = KJUR.crypto.Util;
    var algName = null;

    if (!hash) hash = "sha1";

    if (typeof hash === "string") {
        algName = MD.getCanonicalAlgName(hash);
        hashLen = MD.getHashLength(algName);
        hash = function(s) {
            return hextorstr(Util.hashHex(rstrtohex(s), algName));
        };
    }

    if (s.length + 2 * hashLen + 2 > n) {
        throw "Message too long for RSA";
    }

    var PS = '', i;

    for (i = 0; i < n - s.length - 2 * hashLen - 2; i += 1) {
        PS += '\x00';
    }

    var DB = hash('') + PS + '\x01' + s;
    var seed = new Array(hashLen);
    new SecureRandom().nextBytes(seed);
    
    var dbMask = oaep_mgf1_arr(seed, DB.length, hash);
    var maskedDB = [];

    for (i = 0; i < DB.length; i += 1) {
        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, hash);
    var maskedSeed = [0];

    for (i = 0; i < seed.length; i += 1) {
        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);
    }

    return new BigInteger(maskedSeed.concat(maskedDB));
}

// "empty" RSA key constructor
function RSAKey() {
  this.n = null;
  this.e = 0;
  this.d = null;
  this.p = null;
  this.q = null;
  this.dmp1 = null;
  this.dmq1 = null;
  this.coeff = null;
}

// Set the public key fields N and e from hex strings
function RSASetPublic(N, E) {
    this.isPublic = true;
    this.isPrivate = false;
    if (typeof N !== "string") {
	this.n = N;
	this.e = E;
    } else if(N != null && E != null && N.length > 0 && E.length > 0) {
	this.n = parseBigInt(N,16);
	this.e = parseInt(E,16);
    } else {
	throw "Invalid RSA public key";
    }
}

// Perform raw public operation on "x": return x^e (mod n)
function RSADoPublic(x) {
  return x.modPowInt(this.e, this.n);
}

// Return the PKCS#1 RSA encryption of "text" as an even-length hex string
function RSAEncrypt(text) {
  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}

// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string
function RSAEncryptOAEP(text, hash, hashLen) {
  var n = (this.n.bitLength() + 7) >> 3;
  var m = oaep_pad(text, n, hash, hashLen);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  while (h.length < n*2) h = "0" + h;
  return h;
}

// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
//function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
//}

// protected
RSAKey.prototype.doPublic = RSADoPublic;

// public
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;
RSAKey.prototype.encryptOAEP = RSAEncryptOAEP;
//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

RSAKey.prototype.type = "RSA";

/*! (c) Tom Wu, Kenji Urushima | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
// Depends on rsa.js and jsbn2.js

// Version 1.1: support utf-8 decoding in pkcs1unpad2

// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d,n) {
  var b = d.toByteArray();
  var i = 0;
  while(i < b.length && b[i] == 0) ++i;
  if(b.length-i != n-1 || b[i] != 2)
    return null;
  ++i;
  while(b[i] != 0)
    if(++i >= b.length) return null;
  var ret = "";
  while(++i < b.length) {
    var c = b[i] & 255;
    if(c < 128) { // utf-8 decode
      ret += String.fromCharCode(c);
    }
    else if((c > 191) && (c < 224)) {
      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));
      ++i;
    }
    else {
      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));
      i += 2;
    }
  }
  return ret;
}

// PKCS#1 (OAEP) mask generation function
function oaep_mgf1_str(seed, len, hash)
{
    var mask = '', i = 0;

    while (mask.length < len)
    {
        mask += hash(seed + String.fromCharCode.apply(String, [
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff]));
        i += 1;
    }

    return mask;
}

/**
 * Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext
 * @name oaep_unpad
 * @param {BigInteger} d BigInteger object of OAEP padded message
 * @param n byte length of RSA key (i.e. 128 when RSA 1024bit)
 * @param hash JavaScript function to calculate raw hash value from raw string or algorithm name (ex. "SHA1") 
 * @param hashLen byte length of resulted hash value (i.e. 20 for SHA1)
 * @return {String} raw string of OAEP unpadded message
 * @description
 * This function do unpadding OAEP padded message then returns an original message.<br/>
 * NOTE: Since jsrsasign 6.2.0, 'hash' argument can accept an algorithm name such as "sha1".
 * @example
 * // DEFAULT(SHA1)
 * bi1 = oaep_pad("aaa", 128);
 * oaep_unpad(bi1, 128) &rarr; "aaa" // SHA-1 by default
 */
function oaep_unpad(d, n, hash, hashLen) {
    var MD = KJUR.crypto.MessageDigest;
    var Util = KJUR.crypto.Util;
    var algName = null;

    if (!hash) hash = "sha1";

    if (typeof hash === "string") {
        algName = MD.getCanonicalAlgName(hash);
        hashLen = MD.getHashLength(algName);
        hash = function(s) {
            return hextorstr(Util.hashHex(rstrtohex(s), algName));
        };
    }

    d = d.toByteArray();

    var i;

    for (i = 0; i < d.length; i += 1) {
        d[i] &= 0xff;
    }

    while (d.length < n) {
        d.unshift(0);
    }

    d = String.fromCharCode.apply(String, d);

    if (d.length < 2 * hashLen + 2) {
        throw "Cipher too short";
    }

    var maskedSeed = d.substr(1, hashLen)
    var maskedDB = d.substr(hashLen + 1);

    var seedMask = oaep_mgf1_str(maskedDB, hashLen, hash);
    var seed = [], i;

    for (i = 0; i < maskedSeed.length; i += 1) {
        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);
    }

    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),
                               d.length - hashLen, hash);

    var DB = [];

    for (i = 0; i < maskedDB.length; i += 1) {
        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    DB = String.fromCharCode.apply(String, DB);

    if (DB.substr(0, hashLen) !== hash('')) {
        throw "Hash mismatch";
    }

    DB = DB.substr(hashLen);

    var first_one = DB.indexOf('\x01');
    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf('\x00') : -1;

    if (last_zero + 1 != first_one) {
        throw "Malformed data";
    }

    return DB.substr(first_one + 1);
}

// Set the private key fields N, e, and d from hex strings
function RSASetPrivate(N,E,D) {
  this.isPrivate = true;
  if (typeof N !== "string")
  {
    this.n = N;
    this.e = E;
    this.d = D;
  }
  else if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
  }
  else
    throw "Invalid RSA private key";
}

// Set the private key fields N, e, d and CRT params from hex strings
function RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {
  this.isPrivate = true;
  this.isPublic = false;
  if (N == null) throw "RSASetPrivateEx N == null";
  if (E == null) throw "RSASetPrivateEx E == null";
  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";
  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";

  if (N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
    this.p = parseBigInt(P,16);
    this.q = parseBigInt(Q,16);
    this.dmp1 = parseBigInt(DP,16);
    this.dmq1 = parseBigInt(DQ,16);
    this.coeff = parseBigInt(C,16);
  } else {
    throw "Invalid RSA private key in RSASetPrivateEx";
  }
}

// Generate a new random private key B bits long, using public expt E
/*
 * @example
 * RSAKey.generate(1024, "10001")
 */
function RSAGenerate(B,E) {
  var rng = new SecureRandom();
  var qs = B>>1;
  this.e = parseInt(E,16);
  var ee = new BigInteger(E,16);

  var mindiffbits = (B / 2) - 100;
  var minDiff = BigInteger.ONE.shiftLeft(mindiffbits);

  for(;;) {
    for(;;) {
      this.p = new BigInteger(B-qs,1,rng);
      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 &&
	 this.p.isProbablePrime(10)) break;
    }
    for(;;) {
      this.q = new BigInteger(qs,1,rng);
      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 &&
	 this.q.isProbablePrime(10)) break;
    }

    // p <= q
    if(this.p.compareTo(this.q) <= 0) {
      var t = this.p;
      this.p = this.q;
      this.q = t;
    }

    // |p - q| > 2^(bitlen/2-100)=minDiff
    var diff = this.q.subtract(this.p).abs();
    if (diff.bitLength() < mindiffbits || diff.compareTo(minDiff) <= 0) continue;

    // calculate dmp1,dmq1,coeff
    var p1 = this.p.subtract(BigInteger.ONE);	// p1 = p - 1
    var q1 = this.q.subtract(BigInteger.ONE);	// q1 = q - 1
    var phi = p1.multiply(q1);
    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
      this.n = this.p.multiply(this.q);	// this.n = p * q
      if (this.n.bitLength() == B) {
        this.d = ee.modInverse(phi);	// this.d = 
        this.dmp1 = this.d.mod(p1);	// this.dmp1 = d mod (p - 1)
        this.dmq1 = this.d.mod(q1);	// this.dmq1 = d mod (q - 1)
        this.coeff = this.q.modInverse(this.p);	// this.coeff = (q ^ -1) mod p
        break;
      }
    }
  }
  this.isPrivate = true;
}

// Perform raw private operation on "x": return x^d (mod n)
function RSADoPrivate(x) {
  if(this.p == null || this.q == null)
    return x.modPow(this.d, this.n);

  // TODO: re-calculate any missing CRT params
  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?
  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?

  while(xp.compareTo(xq) < 0)
    xp = xp.add(this.p);
  // NOTE:
  // xp.subtract(xq) => cp -cq
  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h
  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M
  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is an even-length hex string and the output is a plain string.
function RSADecrypt(ctext) {
  if (ctext.length != Math.ceil(this.n.bitLength() / 4.0)) {
    throw new Error("wrong ctext length");
  }

  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);
}

// Return the PKCS#1 OAEP RSA decryption of "ctext".
// "ctext" is an even-length hex string and the output is a plain string.
function RSADecryptOAEP(ctext, hash, hashLen) {
  if (ctext.length != Math.ceil(this.n.bitLength() / 4.0)) {
    throw new Error("wrong ctext length");
  }

  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash, hashLen);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is a Base64-encoded string and the output is a plain string.
//function RSAB64Decrypt(ctext) {
//  var h = b64tohex(ctext);
//  if(h) return this.decrypt(h); else return null;
//}

// protected
RSAKey.prototype.doPrivate = RSADoPrivate;

// public
RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.generate = RSAGenerate;
RSAKey.prototype.decrypt = RSADecrypt;
RSAKey.prototype.decryptOAEP = RSADecryptOAEP;
//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
// Basic Javascript Elliptic Curve implementation
// Ported loosely from BouncyCastle's Java EC code
// Only Fp curves implemented for now

// Requires jsbn.js and jsbn2.js

// ----------------
// ECFieldElementFp

// constructor
function ECFieldElementFp(q,x) {
    this.x = x;
    // TODO if(x.compareTo(q) >= 0) error
    this.q = q;
}

function feFpEquals(other) {
    if(other == this) return true;
    return (this.q.equals(other.q) && this.x.equals(other.x));
}

function feFpToBigInteger() {
    return this.x;
}

function feFpNegate() {
    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
}

function feFpAdd(b) {
    return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
}

function feFpSubtract(b) {
    return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
}

function feFpMultiply(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
}

function feFpSquare() {
    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
}

function feFpDivide(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
}

ECFieldElementFp.prototype.equals = feFpEquals;
ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
ECFieldElementFp.prototype.negate = feFpNegate;
ECFieldElementFp.prototype.add = feFpAdd;
ECFieldElementFp.prototype.subtract = feFpSubtract;
ECFieldElementFp.prototype.multiply = feFpMultiply;
ECFieldElementFp.prototype.square = feFpSquare;
ECFieldElementFp.prototype.divide = feFpDivide;

ECFieldElementFp.prototype.sqrt = function() {
    return new ECFieldElementFp(this.q, this.x.sqrt().mod(this.q));
}

// ----------------
// ECPointFp

// constructor
function ECPointFp(curve,x,y,z) {
    this.curve = curve;
    this.x = x;
    this.y = y;
    // Projective coordinates: either zinv == null or z * zinv == 1
    // z and zinv are just BigIntegers, not fieldElements
    if(z == null) {
      this.z = BigInteger.ONE;
    }
    else {
      this.z = z;
    }
    this.zinv = null;
    //TODO: compression flag
}

function pointFpGetX() {
    if(this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q));
}

function pointFpGetY() {
    if(this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q));
}

function pointFpEquals(other) {
    if(other == this) return true;
    if(this.isInfinity()) return other.isInfinity();
    if(other.isInfinity()) return this.isInfinity();
    var u, v;
    // u = Y2 * Z1 - Y1 * Z2
    u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
    if(!u.equals(BigInteger.ZERO)) return false;
    // v = X2 * Z1 - X1 * Z2
    v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
    return v.equals(BigInteger.ZERO);
}

function pointFpIsInfinity() {
    if((this.x == null) && (this.y == null)) return true;
    return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
}

function pointFpNegate() {
    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
}

function pointFpAdd(b) {
    if(this.isInfinity()) return b;
    if(b.isInfinity()) return this;

    // u = Y2 * Z1 - Y1 * Z2
    var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
    // v = X2 * Z1 - X1 * Z2
    var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);

    if(BigInteger.ZERO.equals(v)) {
        if(BigInteger.ZERO.equals(u)) {
            return this.twice(); // this == b, so double
        }
	return this.curve.getInfinity(); // this = -b, so infinity
    }

    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var x2 = b.x.toBigInteger();
    var y2 = b.y.toBigInteger();

    var v2 = v.square();
    var v3 = v2.multiply(v);
    var x1v2 = x1.multiply(v2);
    var zu2 = u.square().multiply(this.z);

    // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
    var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
    // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
    var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
    // z3 = v^3 * z1 * z2
    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);

    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
}

function pointFpTwice() {
    if(this.isInfinity()) return this;
    if(this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();

    // TODO: optimized handling of constants
    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();

    var y1z1 = y1.multiply(this.z);
    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
    var a = this.curve.a.toBigInteger();

    // w = 3 * x1^2 + a * z1^2
    var w = x1.square().multiply(THREE);
    if(!BigInteger.ZERO.equals(a)) {
      w = w.add(this.z.square().multiply(a));
    }
    w = w.mod(this.curve.q);
    // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
    var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
    // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
    var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
    // z3 = 8 * (y1 * z1)^3
    var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);

    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
}

// Simple NAF (Non-Adjacent Form) multiplication algorithm
// TODO: modularize the multiplication algorithm
// UPDATE: 2020.03.30 mitigate Minerva timing attack https://minerva.crocs.fi.muni.cz/
//                    Constant time execution on multiply method.
function pointFpMultiply(k) {
    if(this.isInfinity()) return this;
    if(k.signum() == 0) return this.curve.getInfinity();

    // initialize for multiply
    var e = k; // e = k
    var h = e.multiply(new BigInteger("3"));
    var neg = this.negate();
    var R = this;

    // initialize for dummy to mitigate timing attack
    var e2 = this.curve.q.subtract(k); // e2 = q - k
    var h2 = e2.multiply(new BigInteger("3"));
    var R2 = new ECPointFp(this.curve, this.x, this.y);
    var neg2 = R2.negate();

    // calculate multiply
    var i;
    for(i = h.bitLength() - 2; i > 0; --i) {
	R = R.twice();

	var hBit = h.testBit(i);
	var eBit = e.testBit(i);

	if (hBit != eBit) {
	    R = R.add(hBit ? this : neg);
	}
    }

    // calculate dummy to mitigate timing attack
    for(i = h2.bitLength() - 2; i > 0; --i) {
	R2 = R2.twice();

	var h2Bit = h2.testBit(i);
	var e2Bit = e2.testBit(i);

	if (h2Bit != e2Bit) {
	    R2 = R2.add(h2Bit ? R2 : neg2);
	}
    }

    return R;
}

// Compute this*j + x*k (simultaneous multiplication)
function pointFpMultiplyTwo(j,x,k) {
  var i;
  if(j.bitLength() > k.bitLength())
    i = j.bitLength() - 1;
  else
    i = k.bitLength() - 1;

  var R = this.curve.getInfinity();
  var both = this.add(x);
  while(i >= 0) {
    R = R.twice();
    if(j.testBit(i)) {
      if(k.testBit(i)) {
        R = R.add(both);
      }
      else {
        R = R.add(this);
      }
    }
    else {
      if(k.testBit(i)) {
        R = R.add(x);
      }
    }
    --i;
  }

  return R;
}

ECPointFp.prototype.getX = pointFpGetX;
ECPointFp.prototype.getY = pointFpGetY;
ECPointFp.prototype.equals = pointFpEquals;
ECPointFp.prototype.isInfinity = pointFpIsInfinity;
ECPointFp.prototype.negate = pointFpNegate;
ECPointFp.prototype.add = pointFpAdd;
ECPointFp.prototype.twice = pointFpTwice;
ECPointFp.prototype.multiply = pointFpMultiply;
ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;

// ----------------
// ECCurveFp

// constructor
function ECCurveFp(q,a,b) {
    this.q = q;
    this.a = this.fromBigInteger(a);
    this.b = this.fromBigInteger(b);
    this.infinity = new ECPointFp(this, null, null);
}

function curveFpGetQ() {
    return this.q;
}

function curveFpGetA() {
    return this.a;
}

function curveFpGetB() {
    return this.b;
}

function curveFpEquals(other) {
    if(other == this) return true;
    return(this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
}

function curveFpGetInfinity() {
    return this.infinity;
}

function curveFpFromBigInteger(x) {
    return new ECFieldElementFp(this.q, x);
}

// for now, work with hex strings because they're easier in JS
function curveFpDecodePointHex(s) {
    switch(parseInt(s.substr(0,2), 16)) { // first byte
    case 0:
	return this.infinity;
    case 2:
    case 3:
	var hYTilde = s.substr(0,2); // "02" or "03"
	var hX = s.substr(2);
	// y = sqrt((x^2+a)x+b) = sqrt(x^3+ax+b)
	var x = this.fromBigInteger(new BigInteger(xHex, 16)); // FE
	var a = this.getA(); // FE
	var b = this.getB(); // FE
	var rhs = x.square().add(a).multiply(x).add(b); //FE
	var y = rhs.sqrt();  // FE
	if (hYTilde == "03") y = y.negate();
	return new ECPointFp(this, x, y);
	// point compression not supported yet
	// return null;
    case 4:
    case 6:
    case 7:
	var len = (s.length - 2) / 2;
	var xHex = s.substr(2, len);
	var yHex = s.substr(len+2, len);

	return new ECPointFp(this,
			     this.fromBigInteger(new BigInteger(xHex, 16)),
			     this.fromBigInteger(new BigInteger(yHex, 16)));

    default: // unsupported
	return null;
    }
}

ECCurveFp.prototype.getQ = curveFpGetQ;
ECCurveFp.prototype.getA = curveFpGetA;
ECCurveFp.prototype.getB = curveFpGetB;
ECCurveFp.prototype.equals = curveFpEquals;
ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;

/*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
 */
/*
 * splitted from bitcoin-lib/ecdsa.js
 *
 * version 1.0.0 is the original of bitcoin-lib/ecdsa.js
 */
ECFieldElementFp.prototype.getByteLength = function () {
  return Math.floor((this.toBigInteger().bitLength() + 7) / 8);
};

ECPointFp.prototype.getEncoded = function (compressed) {
  var integerToBytes = function(i, len) {
    var bytes = i.toByteArrayUnsigned();

    if (len < bytes.length) {
      bytes = bytes.slice(bytes.length-len);
    } else while (len > bytes.length) {
      bytes.unshift(0);
    }
    return bytes;
  };

  var x = this.getX().toBigInteger();
  var y = this.getY().toBigInteger();

  // Get value as a 32-byte Buffer
  // Fixed length based on a patch by bitaddress.org and Casascius
  var enc = integerToBytes(x, 32);

  if (compressed) {
    if (y.isEven()) {
      // Compressed even pubkey
      // M = 02 || X
      enc.unshift(0x02);
    } else {
      // Compressed uneven pubkey
      // M = 03 || X
      enc.unshift(0x03);
    }
  } else {
    // Uncompressed pubkey
    // M = 04 || X || Y
    enc.unshift(0x04);
    enc = enc.concat(integerToBytes(y, 32));
  }
  return enc;
};

ECPointFp.decodeFrom = function (curve, enc) {
  var type = enc[0];
  var dataLen = enc.length-1;

  // Extract x and y as byte arrays
  var xBa = enc.slice(1, 1 + dataLen/2);
  var yBa = enc.slice(1 + dataLen/2, 1 + dataLen);

  // Prepend zero byte to prevent interpretation as negative integer
  xBa.unshift(0);
  yBa.unshift(0);

  // Convert to BigIntegers
  var x = new BigInteger(xBa);
  var y = new BigInteger(yBa);

  // Return point
  return new ECPointFp(curve, curve.fromBigInteger(x), curve.fromBigInteger(y));
};

/*
 * @since ec-patch.js 1.0.1
 */
ECPointFp.decodeFromHex = function (curve, encHex) {
  var type = encHex.substr(0, 2); // shall be "04"
  var dataLen = encHex.length - 2;

  // Extract x and y as byte arrays
  var xHex = encHex.substr(2, dataLen / 2);
  var yHex = encHex.substr(2 + dataLen / 2, dataLen / 2);

  // Convert to BigIntegers
  var x = new BigInteger(xHex, 16);
  var y = new BigInteger(yHex, 16);

  // Return point
  return new ECPointFp(curve, curve.fromBigInteger(x), curve.fromBigInteger(y));
};

ECPointFp.prototype.add2D = function (b) {
  if(this.isInfinity()) return b;
  if(b.isInfinity()) return this;

  if (this.x.equals(b.x)) {
    if (this.y.equals(b.y)) {
      // this = b, i.e. this must be doubled
      return this.twice();
    }
    // this = -b, i.e. the result is the point at infinity
    return this.curve.getInfinity();
  }

  var x_x = b.x.subtract(this.x);
  var y_y = b.y.subtract(this.y);
  var gamma = y_y.divide(x_x);

  var x3 = gamma.square().subtract(this.x).subtract(b.x);
  var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);

  return new ECPointFp(this.curve, x3, y3);
};

ECPointFp.prototype.twice2D = function () {
  if (this.isInfinity()) return this;
  if (this.y.toBigInteger().signum() == 0) {
    // if y1 == 0, then (x1, y1) == (x1, -y1)
    // and hence this = -this and thus 2(x1, y1) == infinity
    return this.curve.getInfinity();
  }

  var TWO = this.curve.fromBigInteger(BigInteger.valueOf(2));
  var THREE = this.curve.fromBigInteger(BigInteger.valueOf(3));
  var gamma = this.x.square().multiply(THREE).add(this.curve.a).divide(this.y.multiply(TWO));

  var x3 = gamma.square().subtract(this.x.multiply(TWO));
  var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);

  return new ECPointFp(this.curve, x3, y3);
};

ECPointFp.prototype.multiply2D = function (k) {
  if(this.isInfinity()) return this;
  if(k.signum() == 0) return this.curve.getInfinity();

  var e = k;
  var h = e.multiply(new BigInteger("3"));

  var neg = this.negate();
  var R = this;

  var i;
  for (i = h.bitLength() - 2; i > 0; --i) {
    R = R.twice();

    var hBit = h.testBit(i);
    var eBit = e.testBit(i);

    if (hBit != eBit) {
      R = R.add2D(hBit ? this : neg);
    }
  }

  return R;
};

ECPointFp.prototype.isOnCurve = function () {
  var x = this.getX().toBigInteger();
  var y = this.getY().toBigInteger();
  var a = this.curve.getA().toBigInteger();
  var b = this.curve.getB().toBigInteger();
  var n = this.curve.getQ();
  var lhs = y.multiply(y).mod(n);
  var rhs = x.multiply(x).multiply(x)
    .add(a.multiply(x)).add(b).mod(n);
  return lhs.equals(rhs);
};

ECPointFp.prototype.toString = function () {
  return '('+this.getX().toBigInteger().toString()+','+
    this.getY().toBigInteger().toString()+')';
};

/**
 * Validate an elliptic curve point.
 *
 * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive
 */
ECPointFp.prototype.validate = function () {
  var n = this.curve.getQ();

  // Check Q != O
  if (this.isInfinity()) {
    throw new Error("Point is at infinity.");
  }

  // Check coordinate bounds
  var x = this.getX().toBigInteger();
  var y = this.getY().toBigInteger();
  if (x.compareTo(BigInteger.ONE) < 0 ||
      x.compareTo(n.subtract(BigInteger.ONE)) > 0) {
    throw new Error('x coordinate out of bounds');
  }
  if (y.compareTo(BigInteger.ONE) < 0 ||
      y.compareTo(n.subtract(BigInteger.ONE)) > 0) {
    throw new Error('y coordinate out of bounds');
  }

  // Check y^2 = x^3 + ax + b (mod n)
  if (!this.isOnCurve()) {
    throw new Error("Point is not on the curve.");
  }

  // Check nQ = 0 (Q is a scalar multiple of G)
  if (this.multiply(n).isInfinity()) {
    // TODO: This check doesn't work - fix.
    throw new Error("Point is not a scalar multiple of G.");
  }

  return true;
};

/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
 */
// This source code is free for use in the public domain.
// NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

// https://code.google.com/p/json-sans-eval/

/**
 * Parses a string of well-formed JSON text.
 *
 * If the input is not well-formed, then behavior is undefined, but it is
 * deterministic and is guaranteed not to modify any object other than its
 * return value.
 *
 * This does not use `eval` so is less likely to have obscure security bugs than
 * json2.js.
 * It is optimized for speed, so is much faster than json_parse.js.
 *
 * This library should be used whenever security is a concern (when JSON may
 * come from an untrusted source), speed is a concern, and erroring on malformed
 * JSON is *not* a concern.
 *
 *                      Pros                   Cons
 *                    +-----------------------+-----------------------+
 * json_sans_eval.js  | Fast, secure          | Not validating        |
 *                    +-----------------------+-----------------------+
 * json_parse.js      | Validating, secure    | Slow                  |
 *                    +-----------------------+-----------------------+
 * json2.js           | Fast, some validation | Potentially insecure  |
 *                    +-----------------------+-----------------------+
 *
 * json2.js is very fast, but potentially insecure since it calls `eval` to
 * parse JSON data, so an attacker might be able to supply strange JS that
 * looks like JSON, but that executes arbitrary javascript.
 * If you do have to use json2.js with untrusted data, make sure you keep
 * your version of json2.js up to date so that you get patches as they're
 * released.
 *
 * @param {string} json per RFC 4627
 * @param {function (this:Object, string, *):*} opt_reviver optional function
 *     that reworks JSON objects post-parse per Chapter 15.12 of EcmaScript3.1.
 *     If supplied, the function is called with a string key, and a value.
 *     The value is the property of 'this'.  The reviver should return
 *     the value to use in its place.  So if dates were serialized as
 *     {@code { "type": "Date", "time": 1234 }}, then a reviver might look like
 *     {@code
 *     function (key, value) {
 *       if (value && typeof value === 'object' && 'Date' === value.type) {
 *         return new Date(value.time);
 *       } else {
 *         return value;
 *       }
 *     }}.
 *     If the reviver returns {@code undefined} then the property named by key
 *     will be deleted from its container.
 *     {@code this} is bound to the object containing the specified property.
 * @return {Object|Array}
 * @author Mike Samuel <mikesamuel@gmail.com>
 */
var jsonParse = (function () {
  var number
      = '(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)';
  var oneChar = '(?:[^\\0-\\x08\\x0a-\\x1f\"\\\\]'
      + '|\\\\(?:[\"/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';
  var string = '(?:\"' + oneChar + '*\")';

  // Will match a value in a well-formed JSON file.
  // If the input is not well-formed, may match strangely, but not in an unsafe
  // way.
  // Since this only matches value tokens, it does not match whitespace, colons,
  // or commas.
  var jsonToken = new RegExp(
      '(?:false|true|null|[\\{\\}\\[\\]]'
      + '|' + number
      + '|' + string
      + ')', 'g');

  // Matches escape sequences in a string literal
  var escapeSequence = new RegExp('\\\\(?:([^u])|u(.{4}))', 'g');

  // Decodes escape sequences in object literals
  var escapes = {
    '"': '"',
    '/': '/',
    '\\': '\\',
    'b': '\b',
    'f': '\f',
    'n': '\n',
    'r': '\r',
    't': '\t'
  };
  function unescapeOne(_, ch, hex) {
    return ch ? escapes[ch] : String.fromCharCode(parseInt(hex, 16));
  }

  // A non-falsy value that coerces to the empty string when used as a key.
  var EMPTY_STRING = new String('');
  var SLASH = '\\';

  // Constructor to use based on an open token.
  var firstTokenCtors = { '{': Object, '[': Array };

  var hop = Object.hasOwnProperty;

  return function (json, opt_reviver) {
    // Split into tokens
    var toks = json.match(jsonToken);
    // Construct the object to return
    var result;
    var tok = toks[0];
    var topLevelPrimitive = false;
    if ('{' === tok) {
      result = {};
    } else if ('[' === tok) {
      result = [];
    } else {
      // The RFC only allows arrays or objects at the top level, but the JSON.parse
      // defined by the EcmaScript 5 draft does allow strings, booleans, numbers, and null
      // at the top level.
      result = [];
      topLevelPrimitive = true;
    }

    // If undefined, the key in an object key/value record to use for the next
    // value parsed.
    var key;
    // Loop over remaining tokens maintaining a stack of uncompleted objects and
    // arrays.
    var stack = [result];
    for (var i = 1 - topLevelPrimitive, n = toks.length; i < n; ++i) {
      tok = toks[i];

      var cont;
      switch (tok.charCodeAt(0)) {
        default:  // sign or digit
          cont = stack[0];
          cont[key || cont.length] = +(tok);
          key = void 0;
          break;
        case 0x22:  // '"'
          tok = tok.substring(1, tok.length - 1);
          if (tok.indexOf(SLASH) !== -1) {
            tok = tok.replace(escapeSequence, unescapeOne);
          }
          cont = stack[0];
          if (!key) {
            if (cont instanceof Array) {
              key = cont.length;
            } else {
              key = tok || EMPTY_STRING;  // Use as key for next value seen.
              break;
            }
          }
          cont[key] = tok;
          key = void 0;
          break;
        case 0x5b:  // '['
          cont = stack[0];
          stack.unshift(cont[key || cont.length] = []);
          key = void 0;
          break;
        case 0x5d:  // ']'
          stack.shift();
          break;
        case 0x66:  // 'f'
          cont = stack[0];
          cont[key || cont.length] = false;
          key = void 0;
          break;
        case 0x6e:  // 'n'
          cont = stack[0];
          cont[key || cont.length] = null;
          key = void 0;
          break;
        case 0x74:  // 't'
          cont = stack[0];
          cont[key || cont.length] = true;
          key = void 0;
          break;
        case 0x7b:  // '{'
          cont = stack[0];
          stack.unshift(cont[key || cont.length] = {});
          key = void 0;
          break;
        case 0x7d:  // '}'
          stack.shift();
          break;
      }
    }
    // Fail if we've got an uncompleted object.
    if (topLevelPrimitive) {
      if (stack.length !== 1) { throw new Error(); }
      result = result[0];
    } else {
      if (stack.length) { throw new Error(); }
    }

    if (opt_reviver) {
      // Based on walk as implemented in http://www.json.org/json2.js
      var walk = function (holder, key) {
        var value = holder[key];
        if (value && typeof value === 'object') {
          var toDelete = null;
          for (var k in value) {
            if (hop.call(value, k) && value !== holder) {
              // Recurse to properties first.  This has the effect of causing
              // the reviver to be called on the object graph depth-first.

              // Since 'this' is bound to the holder of the property, the
              // reviver can access sibling properties of k including ones
              // that have not yet been revived.

              // The value returned by the reviver is used in place of the
              // current value of property k.
              // If it returns undefined then the property is deleted.
              var v = walk(value, k);
              if (v !== void 0) {
                value[k] = v;
              } else {
                // Deleting properties inside the loop has vaguely defined
                // semantics in ES3 and ES3.1.
                if (!toDelete) { toDelete = []; }
                toDelete.push(k);
              }
            }
          }
          if (toDelete) {
            for (var i = toDelete.length; --i >= 0;) {
              delete value[toDelete[i]];
            }
          }
        }
        return opt_reviver.call(holder, key, value);
      };
      result = walk({ '': result }, '');
    }

    return result;
  };
})();

/* asn1-1.0.27.js (c) 2013-2023 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * asn1.js - ASN.1 DER encoder classes
 *
 * Copyright (c) 2013-2022 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name asn1-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.8.0 asn1 1.0.27 (2023-Apr-08)
 * @since jsrsasign 2.1
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/** 
 * kjur's class library name space
 * <p>
 * This name space provides following name spaces:
 * <ul>
 * <li>{@link KJUR.asn1} - ASN.1 primitive hexadecimal encoder</li>
 * <li>{@link KJUR.asn1.x509} - ASN.1 structure for X.509 certificate and CRL</li>
 * <li>{@link KJUR.crypto} - Java Cryptographic Extension(JCE) style MessageDigest/Signature 
 * class and utilities</li>
 * </ul>
 * </p> 
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * @name KJUR
 * @namespace kjur's class library name space
 */
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};

/**
 * kjur's ASN.1 class library name space
 * <p>
 * This is ITU-T X.690 ASN.1 DER encoder class library and
 * class structure and methods is very similar to 
 * org.bouncycastle.asn1 package of 
 * well known BouncyCaslte Cryptography Library.
 * <h4>PROVIDING ASN.1 PRIMITIVES</h4>
 * Here are ASN.1 DER primitive classes.
 * <ul>
 * <li>0x01 {@link KJUR.asn1.DERBoolean}</li>
 * <li>0x02 {@link KJUR.asn1.DERInteger}</li>
 * <li>0x03 {@link KJUR.asn1.DERBitString}</li>
 * <li>0x04 {@link KJUR.asn1.DEROctetString}</li>
 * <li>0x05 {@link KJUR.asn1.DERNull}</li>
 * <li>0x06 {@link KJUR.asn1.DERObjectIdentifier}</li>
 * <li>0x0a {@link KJUR.asn1.DEREnumerated}</li>
 * <li>0x0c {@link KJUR.asn1.DERUTF8String}</li>
 * <li>0x12 {@link KJUR.asn1.DERNumericString}</li>
 * <li>0x13 {@link KJUR.asn1.DERPrintableString}</li>
 * <li>0x14 {@link KJUR.asn1.DERTeletexString}</li>
 * <li>0x16 {@link KJUR.asn1.DERIA5String}</li>
 * <li>0x17 {@link KJUR.asn1.DERUTCTime}</li>
 * <li>0x18 {@link KJUR.asn1.DERGeneralizedTime}</li>
 * <li>0x1a {@link KJUR.asn1.DERVisibleString}</li>
 * <li>0x1e {@link KJUR.asn1.DERBMPString}</li>
 * <li>0x30 {@link KJUR.asn1.DERSequence}</li>
 * <li>0x31 {@link KJUR.asn1.DERSet}</li>
 * </ul>
 * <h4>OTHER ASN.1 CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.ASN1Object}</li>
 * <li>{@link KJUR.asn1.DERAbstractString}</li>
 * <li>{@link KJUR.asn1.DERAbstractTime}</li>
 * <li>{@link KJUR.asn1.DERAbstractStructured}</li>
 * <li>{@link KJUR.asn1.DERTaggedObject}</li>
 * </ul>
 * <h4>SUB NAME SPACES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.cades} - CAdES long term signature format</li>
 * <li>{@link KJUR.asn1.cms} - Cryptographic Message Syntax</li>
 * <li>{@link KJUR.asn1.csr} - Certificate Signing Request (CSR/PKCS#10)</li>
 * <li>{@link KJUR.asn1.tsp} - RFC 3161 Timestamping Protocol Format</li>
 * <li>{@link KJUR.asn1.x509} - RFC 5280 X.509 certificate and CRL</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace. 
 * This caused by a bug of jsdoc2.
 * @name KJUR.asn1
 * @namespace
 */
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};

/**
 * ASN1 utilities class
 * @name KJUR.asn1.ASN1Util
 * @class ASN1 utilities class
 * @since asn1 1.0.2
 */
KJUR.asn1.ASN1Util = new function() {
    this.integerToByteHex = function(i) {
        var h = i.toString(16);
        if ((h.length % 2) == 1) h = '0' + h;
        return h;
    };
    this.bigIntToMinTwosComplementsHex = function(bigIntegerValue) {
        var h = bigIntegerValue.toString(16);
        if (h.substr(0, 1) != '-') {
            if (h.length % 2 == 1) {
                h = '0' + h;
            } else {
                if (! h.match(/^[0-7]/)) {
                    h = '00' + h;
                }
            }
        } else {
            var hPos = h.substr(1);
            var xorLen = hPos.length;
            if (xorLen % 2 == 1) {
                xorLen += 1;
            } else {
                if (! h.match(/^[0-7]/)) {
                    xorLen += 2;
                }
            }
            var hMask = '';
            for (var i = 0; i < xorLen; i++) {
                hMask += 'f';
            }
            var biMask = new BigInteger(hMask, 16);
            var biNeg = biMask.xor(bigIntegerValue).add(BigInteger.ONE);
            h = biNeg.toString(16).replace(/^-/, '');
        }
        return h;
    };
    /**
     * get PEM string from hexadecimal data and header string
     * @name getPEMStringFromHex
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {String} dataHex hexadecimal string of PEM body
     * @param {String} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')
     * @return {String} PEM formatted string of input data
     * @description
     * This method converts a hexadecimal string to a PEM string with
     * a specified header. Its line break will be CRLF("\r\n").
     * @example
     * var pem  = KJUR.asn1.ASN1Util.getPEMStringFromHex('616161', 'RSA PRIVATE KEY');
     * // value of pem will be:
     * -----BEGIN PRIVATE KEY-----
     * YWFh
     * -----END PRIVATE KEY-----
     */
    this.getPEMStringFromHex = function(dataHex, pemHeader) {
	return hextopem(dataHex, pemHeader);
    };

    /**
     * generate ASN1Object specifed by JSON parameters
     * @name newObject
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return {KJUR.asn1.ASN1Object} generated object
     * @since asn1 1.0.3
     * @description
     * generate any ASN1Object specified by JSON param
     * including ASN.1 primitive or structured.
     * Generally 'param' can be described as follows:
     * <blockquote>
     * {TYPE-OF-ASNOBJ: ASN1OBJ-PARAMETER}
     * </blockquote>
     * 'TYPE-OF-ASN1OBJ' can be one of following symbols:
     * <ul>
     * <li>'bool' - {@link KJUR.asn1.DERBoolean}</li>
     * <li>'int' - {@link KJUR.asn1.DERInteger}</li>
     * <li>'bitstr' - {@link KJUR.asn1.DERBitString}</li>
     * <li>'octstr' - {@link KJUR.asn1.DEROctetString}</li>
     * <li>'null' - {@link KJUR.asn1.DERNull}</li>
     * <li>'oid' - {@link KJUR.asn1.DERObjectIdentifier}</li>
     * <li>'enum' - {@link KJUR.asn1.DEREnumerated}</li>
     * <li>'utf8str' - {@link KJUR.asn1.DERUTF8String}</li>
     * <li>'numstr' - {@link KJUR.asn1.DERNumericString}</li>
     * <li>'prnstr' - {@link KJUR.asn1.DERPrintableString}</li>
     * <li>'telstr' - {@link KJUR.asn1.DERTeletexString}</li>
     * <li>'ia5str' - {@link KJUR.asn1.DERIA5String}</li>
     * <li>'utctime' - {@link KJUR.asn1.DERUTCTime}</li>
     * <li>'gentime' - {@link KJUR.asn1.DERGeneralizedTime}</li>
     * <li>'visstr' - {@link KJUR.asn1.DERVisibleString}</li>
     * <li>'bmpstr' - {@link KJUR.asn1.DERBMPString}</li>
     * <li>'seq' - {@link KJUR.asn1.DERSequence}</li>
     * <li>'set' - {@link KJUR.asn1.DERSet}</li>
     * <li>'tag' - {@link KJUR.asn1.DERTaggedObject}</li>
     * <li>'asn1' - {@link KJUR.asn1.ASN1Object}</li>
     * </ul>
     * <br/>
     * NOTE: Structured object such as SEQUENCE or SET can conclude
     * ASN1Object as well as JSON parameters since jsrsasign 9.0.0.
     *
     * @example
     * newObject({'prnstr': 'aaa'});
     * newObject({'seq': [{'int': 3}, {'prnstr': 'aaa'}]})
     * newObject({seq: [{int: 3}, new DERInteger({int: 3})]}) // mixed
     * // ASN.1 Tagged Object
     * newObject({'tag': {'tag': 'a1', 
     *                    'explicit': true,
     *                    'obj': {'seq': [{'int': 3}, {'prnstr': 'aaa'}]}}});
     * // more simple representation of ASN.1 Tagged Object
     * newObject({'tag': ['a1',
     *                    true,
     *                    {'seq': [
     *                      {'int': 3}, 
     *                      {'prnstr': 'aaa'}]}
     *                   ]});
     */
    this.newObject = function(param) {
	var _KJUR = KJUR,
	    _KJUR_asn1 = _KJUR.asn1,
	    _ASN1Object = _KJUR_asn1.ASN1Object,
	    _DERBoolean = _KJUR_asn1.DERBoolean,
	    _DERInteger = _KJUR_asn1.DERInteger,
	    _DERBitString = _KJUR_asn1.DERBitString,
	    _DEROctetString = _KJUR_asn1.DEROctetString,
	    _DERNull = _KJUR_asn1.DERNull,
	    _DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	    _DEREnumerated = _KJUR_asn1.DEREnumerated,
	    _DERUTF8String = _KJUR_asn1.DERUTF8String,
	    _DERNumericString = _KJUR_asn1.DERNumericString,
	    _DERPrintableString = _KJUR_asn1.DERPrintableString,
	    _DERTeletexString = _KJUR_asn1.DERTeletexString,
	    _DERIA5String = _KJUR_asn1.DERIA5String,
	    _DERUTCTime = _KJUR_asn1.DERUTCTime,
	    _DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime,
	    _DERVisibleString = _KJUR_asn1.DERVisibleString,
	    _DERBMPString = _KJUR_asn1.DERBMPString,
	    _DERSequence = _KJUR_asn1.DERSequence,
	    _DERSet = _KJUR_asn1.DERSet,
	    _DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	    _newObject = _KJUR_asn1.ASN1Util.newObject;

	if (param instanceof _KJUR_asn1.ASN1Object) return param;

        var keys = Object.keys(param);
        if (keys.length != 1)
            throw new Error("key of param shall be only one.");
        var key = keys[0];

        if (":asn1:bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:visstr:bmpstr:seq:set:tag:".indexOf(":" + key + ":") == -1)
            throw new Error("undefined key: " + key);

        if (key == "bool")    return new _DERBoolean(param[key]);
        if (key == "int")     return new _DERInteger(param[key]);
        if (key == "bitstr")  return new _DERBitString(param[key]);
        if (key == "octstr")  return new _DEROctetString(param[key]);
        if (key == "null")    return new _DERNull(param[key]);
        if (key == "oid")     return new _DERObjectIdentifier(param[key]);
        if (key == "enum")    return new _DEREnumerated(param[key]);
        if (key == "utf8str") return new _DERUTF8String(param[key]);
        if (key == "numstr")  return new _DERNumericString(param[key]);
        if (key == "prnstr")  return new _DERPrintableString(param[key]);
        if (key == "telstr")  return new _DERTeletexString(param[key]);
        if (key == "ia5str")  return new _DERIA5String(param[key]);
        if (key == "utctime") return new _DERUTCTime(param[key]);
        if (key == "gentime") return new _DERGeneralizedTime(param[key]);
        if (key == "visstr")  return new _DERVisibleString(param[key]);
        if (key == "bmpstr")  return new _DERBMPString(param[key]);
        if (key == "asn1")    return new _ASN1Object(param[key]);

        if (key == "seq") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSequence({'array': a});
        }

        if (key == "set") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSet({'array': a});
        }

        if (key == "tag") {
            var tagParam = param[key];
            if (Object.prototype.toString.call(tagParam) === '[object Array]' &&
                tagParam.length == 3) {
                var obj = _newObject(tagParam[2]);
                return new _DERTaggedObject({tag: tagParam[0],
					     explicit: tagParam[1],
					     obj: obj});
            } else {
		return new _DERTaggedObject(tagParam);
            }
        }
    };

    /**
     * get encoded hexadecimal string of ASN1Object specifed by JSON parameters
     * @name jsonToASN1HEX
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return hexadecimal string of ASN1Object
     * @since asn1 1.0.4
     * @description
     * As for ASN.1 object representation of JSON object,
     * please see {@link newObject}.
     * @example
     * jsonToASN1HEX({'prnstr': 'aaa'}); 
     */
    this.jsonToASN1HEX = function(param) {
        var asn1Obj = this.newObject(param);
        return asn1Obj.tohex();
    };
};

/**
 * get dot noted oid number string from hexadecimal value of OID
 * @name oidHexToInt
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} hex hexadecimal value of object identifier
 * @return {String} dot noted string of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from hexadecimal string representation of 
 * ASN.1 value of object identifier to oid number string.
 * @example
 * KJUR.asn1.ASN1Util.oidHexToInt('550406') &rarr; "2.5.4.6"
 */
KJUR.asn1.ASN1Util.oidHexToInt = function(hex) {
    var s = "";
    var i01 = parseInt(hex.substr(0, 2), 16);
    var i0 = Math.floor(i01 / 40);
    var i1 = i01 % 40;
    var s = i0 + "." + i1;

    var binbuf = "";
    for (var i = 2; i < hex.length; i += 2) {
	var value = parseInt(hex.substr(i, 2), 16);
        var bin = ("00000000" + value.toString(2)).slice(- 8);
	binbuf = binbuf + bin.substr(1, 7);
	if (bin.substr(0, 1) == "0") {
	    var bi = new BigInteger(binbuf, 2);
	    s = s + "." + bi.toString(10);
	    binbuf = "";
	}
    };

    return s;
};

/**
 * get hexadecimal value of object identifier from dot noted oid value (DEPRECATED)
 * @name oidIntToHex
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} oidString dot noted string of object identifier
 * @return {String} hexadecimal value of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @see {@link ASN1HEX.hextooidstr}
 * @deprecated from jsrsasign 10.0.6. please use {@link oidtohex}
 *
 * @description
 * This static method converts from object identifier value string.
 * to hexadecimal string representation of it.
 * {@link ASN1HEX.hextooidstr} is a reverse function of this.
 * @example
 * KJUR.asn1.ASN1Util.oidIntToHex("2.5.4.6") &rarr; "550406"
 */
KJUR.asn1.ASN1Util.oidIntToHex = function(oidString) {
    var itox = function(i) {
        var h = i.toString(16);
        if (h.length == 1) h = '0' + h;
        return h;
    };

    var roidtox = function(roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7) padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++) bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7) b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };
    
    if (! oidString.match(/^[0-9.]+$/)) {
        throw "malformed oid string: " + oidString;
    }
    var h = '';
    var a = oidString.split('.');
    var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
    h += itox(i0);
    a.splice(0, 2);
    for (var i = 0; i < a.length; i++) {
        h += roidtox(a[i]);
    }
    return h;
};


// ********************************************************************
//  Abstract ASN.1 Classes
// ********************************************************************

// ********************************************************************

/**
 * base class for ASN.1 DER encoder object<br/>
 * @name KJUR.asn1.ASN1Object
 * @class base class for ASN.1 DER encoder object
 * @param {Array} params JSON object parameter for constructor
 * @property {Boolean} isModified flag whether internal data was changed
 * @property {Array} params JSON object parameter for ASN.1 encode
 * @property {String} hTLV hexadecimal string of ASN.1 TLV
 * @property {String} hT hexadecimal string of ASN.1 TLV tag(T)
 * @property {String} hL hexadecimal string of ASN.1 TLV length(L)
 * @property {String} hV hexadecimal string of ASN.1 TLV value(V)
 *
 * @description
 * This class is ASN.1 DER object encode base class.
 * 
 * @example
 * new KJUR.asn1.ASN1Object({tlv: "030101"})
 */
KJUR.asn1.ASN1Object = function(params) {
    var isModified = true;
    var hTLV = null;
    var hT = '00';
    var hL = '00';
    var hV = '';
    this.params = null;

    /**
     * get hexadecimal ASN.1 TLV length(L) bytes from TLV value(V)<br/>
     * @name getLengthHexFromValue
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV length(L)
     */
    this.getLengthHexFromValue = function() {
        if (typeof this.hV == "undefined" || this.hV == null) {
            throw new Error("this.hV is null or undefined");
        }
        if (this.hV.length % 2 == 1) {
            throw new Error("value hex must be even length: n=" +
			    hV.length + ",v=" + this.hV);
        }
        var n = this.hV.length / 2;
        var hN = n.toString(16);
        if (hN.length % 2 == 1) {
            hN = "0" + hN;
        }
        if (n < 128) {
            return hN;
        } else {
            var hNlen = hN.length / 2;
            if (hNlen > 15) {
                throw new Error("ASN.1 length too long to represent by 8x: n = "
				+ n.toString(16));
            }
            var head = 128 + hNlen;
            return head.toString(16) + hN;
        }
    };

    /**
     * get hexadecimal string of ASN.1 TLV bytes<br/>
     * @name tohex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV
     * @since jsrsasign 10.5.16 asn1 1.0.24
     * @see KJUR.asn1.ASN1Object#getEncodedHex
     * @example
     * ...ASN1ObjectInstance.tohex() &rarr; "3003020101"
     */
    this.tohex = function() {
        if (this.hTLV == null || this.isModified) {
            this.hV = this.getFreshValueHex();
            this.hL = this.getLengthHexFromValue();
            this.hTLV = this.hT + this.hL + this.hV;
            this.isModified = false;
            //alert("first time: " + this.hTLV);
        }
        return this.hTLV;
    };

    /**
     * get hexadecimal string of ASN.1 TLV bytes (DEPRECATED)<br/>
     * @name getEncodedHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV
     * @deprecated since jsrsasign 10.5.16 please use {@link KJUR.asn1.ASN1Object#tohex}
     */
    this.getEncodedHex = function() { return this.tohex(); };

    /**
     * get hexadecimal string of ASN.1 TLV value(V) bytes
     * @name getValueHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV value(V) bytes
     */
    this.getValueHex = function() {
        this.tohex();
        return this.hV;
    }

    this.getFreshValueHex = function() {
        return '';
    };

    this.setByParam = function(params) {
	this.params = params;
    };

    if (params != undefined) {
	if (params.tlv != undefined) {
	    this.hTLV = params.tlv;
	    this.isModified = false;
	}
    }
};

// == BEGIN DERAbstractString ================================================
/**
 * base class for ASN.1 DER string classes
 * @name KJUR.asn1.DERAbstractString
 * @class base class for ASN.1 DER string classes
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @property {String} s internal string of value
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERAbstractString = function(params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
    var s = null;
    var hV = null;

    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @return {String} string value of this string object
     */
    this.getString = function() {
        return this.s;
    };

    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newS value by a string to set
     * @description
     * This method set value by string. <br/>
     * NOTE: This method assumes that the argument string is
     * UTF-8 encoded even though ASN.1 primitive 
     * such as IA5String or PrintableString doesn't
     * support all of UTF-8 characters.
     * @example
     * o = new KJUR.asn1.DERIA5String();
     * o.setString("abc");
     * o.setString("");
     */
    this.setString = function(newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = utf8tohex(this.s).toLowerCase();
    };

    /**
     * set value by a hexadecimal string
     * @name setStringHex
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newHexString value by a hexadecimal string to set
     */
    this.setStringHex = function(newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params == "string") {
            this.setString(params);
        } else if (typeof params['str'] != "undefined") {
            this.setString(params['str']);
        } else if (typeof params['hex'] != "undefined") {
            this.setStringHex(params['hex']);
        }
    }
};
extendClass(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
// == END   DERAbstractString ================================================

// == BEGIN DERAbstractTime ==================================================
/**
 * base class for ASN.1 DER Generalized/UTCTime class
 * @name KJUR.asn1.DERAbstractTime
 * @class base class for ASN.1 DER Generalized/UTCTime class
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 * @see KJUR.asn1.DERGeneralizedTime
 * @see KJUR.asn1.DERUTCTime
 * @see KJUR.asn1.x509.Time
 */
KJUR.asn1.DERAbstractTime = function(params) {
    KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);
    var s = null;
    var date = null;

    // --- PRIVATE METHODS --------------------
    this.localDateToUTC = function(d) {
        var utc = d.getTime() + (d.getTimezoneOffset() * 60000);
        var utcDate = new Date(utc);
        return utcDate;
    };

    /*
     * format date string by Data object
     * @name formatDate
     * @memberOf KJUR.asn1.AbstractTime;
     * @param {Date} dateObject 
     * @param {string} type 'utc' or 'gen'
     * @param {boolean} withMillis flag for with millisections or not
     * @description
     * 'withMillis' flag is supported from asn1 1.0.6.
     */
    this.formatDate = function(dateObject, type, withMillis) {
        var pad = this.zeroPadding;
        var d = this.localDateToUTC(dateObject);
        var year = String(d.getFullYear());
        if (type == 'utc') year = year.substr(2, 2);
        var month = pad(String(d.getMonth() + 1), 2);
        var day = pad(String(d.getDate()), 2);
        var hour = pad(String(d.getHours()), 2);
        var min = pad(String(d.getMinutes()), 2);
        var sec = pad(String(d.getSeconds()), 2);
        var s = year + month + day + hour + min + sec;
        if (withMillis === true) {
            var millis = d.getMilliseconds();
            if (millis != 0) {
                var sMillis = pad(String(millis), 3);
                sMillis = sMillis.replace(/[0]+$/, "");
                s = s + "." + sMillis;
            }
        }
        return s + "Z";
    };

    this.zeroPadding = function(s, len) {
        if (s.length >= len) return s;
        return new Array(len - s.length + 1).join('0') + s;
    };

    // --- PUBLIC METHODS --------------------

    /**
     * set parameter of time
     * @name setByParam
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {Object} params JSON object, Date object or string of time
     * @since jsrsasign 10.4.1 asn1 1.0.22
     *
     * NOTE: If a member "millis" has a value "true",
     * a fraction of second will be specified for this object. 
     * This default is "false".
     *
     * @example
     * d1 = new KJUR.asn1.DERGeneralizedTime();
     * d1.setByParam("20210930235959.123Z");
     * d1.setByParam({str: "20210930235959.123Z"});
     *
     * d1.setByParam(new Date("2013/12/31 23:59:59.12"));
     * date1 = new Date(Date.UTC(2021,8,31,23,59,59,123));
     * d1.setByParam(date1);
     * d1.setByParam({date: date1});
     * d1.setByParam({date: date1, millis: true});
     */
    this.setByParam = function(params) {
	this.hV = null;
	this.hTLV = null;
	this.params = params;
    };

    /**
     * get string value of this string object (DEPRECATED)
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @return {String} string value of this time object
     * @deprecated from jsrsasign 10.4.1 asn1 1.0.22.
     */
    this.getString = function() {
        return undefined;
    };

    /**
     * set value by a string (DEPRECATED)
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {String} newS value by a string to set such like "130430235959Z"
     * @deprecated from jsrsasign 10.4.1 asn1 1.0.22.
     */
    this.setString = function(newS) {
        this.hTLV = null;
        this.isModified = true;
	if (this.params == undefined) this.params = {};
	this.params.str = newS;
    };

    /**
     * set value by a Date object<br/>
     * @name setByDate
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @since jsrsasign 10.4.1 asn1 1.0.22
     *
     * @example
     * o = new KJUR.asn1.DERUTCTime();
     * o.setByDate(new Date("2016/12/31 23:59:59.12"));
     * // 2015-Jan-31 23:59:59.12
     * o.setByDate(new Date(Date.UTC(2015, 0, 31, 23, 59, 59, 0)));
     */
    this.setByDate = function(dateObject) {
        this.hTLV = null;
        this.isModified = true;
	if (this.params == undefined) this.params = {};
	this.params.date = dateObject;
    };

    /**
     * set value by a Date object
     * @name setByDateValue
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {Integer} year year of date (ex. 2013)
     * @param {Integer} month month of date between 1 and 12 (ex. 12)
     * @param {Integer} day day of month
     * @param {Integer} hour hours of date
     * @param {Integer} min minutes of date
     * @param {Integer} sec seconds of date
     */
    this.setByDateValue = function(year, month, day, hour, min, sec) {
        var dateObject = new Date(Date.UTC(year, month - 1, day, 
					   hour, min, sec, 0));
        this.setByDate(dateObject);
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };
};
extendClass(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
// == END   DERAbstractTime ==================================================

// == BEGIN DERAbstractStructured ============================================
/**
 * base class for ASN.1 DER structured class
 * @name KJUR.asn1.DERAbstractStructured
 * @class base class for ASN.1 DER structured class
 * @property {Array} asn1Array internal array of ASN1Object
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractStructured = function(params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
    var asn1Array = null;

    /**
     * set value by array of ASN1Object
     * @name setByASN1ObjectArray
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {array} asn1ObjectArray array of ASN1Object to set
     */
    this.setByASN1ObjectArray = function(asn1ObjectArray) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array = asn1ObjectArray;
    };

    /**
     * append an ASN1Object to internal array
     * @name appendASN1Object
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {ASN1Object} asn1Object to add
     */
    this.appendASN1Object = function(asn1Object) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array.push(asn1Object);
    };

    this.asn1Array = new Array();
    if (typeof params != "undefined") {
        if (typeof params['array'] != "undefined") {
            this.asn1Array = params['array'];
        }
    }
};
extendClass(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);


// ********************************************************************
//  ASN.1 Object Classes
// ********************************************************************

// ********************************************************************
/**
 * class for ASN.1 DER Boolean
 * @name KJUR.asn1.DERBoolean
 * @class class for ASN.1 DER Boolean
 * @extends KJUR.asn1.ASN1Object
 * @see KJUR.asn1.ASN1Object - superclass
 * @description
 * In ASN.1 DER, DER Boolean "false" shall be omitted.
 * However this supports boolean false for future BER support.
 * @example
 * new KJUR.asn1.DERBoolean(true)
 * new KJUR.asn1.DERBoolean(false)
 */
KJUR.asn1.DERBoolean = function(params) {
    KJUR.asn1.DERBoolean.superclass.constructor.call(this);
    this.hT = "01";
    if (params == false)
	this.hTLV = "010100";
    else 
	this.hTLV = "0101ff";
};
extendClass(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER Integer
 * @name KJUR.asn1.DERInteger
 * @class class for ASN.1 DER Integer
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>bigint - specify initial ASN.1 value(V) by BigInteger object</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERInteger = function(params) {
    KJUR.asn1.DERInteger.superclass.constructor.call(this);
    this.hT = "02";
    this.params = null;
    var _biToTwoCompl = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex;

    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function(bigIntegerValue) {
	this.isModified = true;
	this.params = { bigint: bigIntegerValue };
    };

    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DERInteger
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function(intValue) {
	this.isModified = true;
	this.params = intValue;
    };

    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     * @example
     * new KJUR.asn1.DERInteger(123);
     * new KJUR.asn1.DERInteger({'int': 123});
     * new KJUR.asn1.DERInteger({'hex': '1fad'});
     * new KJUR.asn1.DERInteger({'bigint': new BigInteger("1234", 10)});
     */
    this.setValueHex = function(newHexString) {
	this.isModified = true;
	this.params = { hex: newHexString };
    };

    this.getFreshValueHex = function() {
	var params = this.params;
	var bi = null;
	if (params == null) throw new Error("value not set");

	if (typeof params == "object" && params.hex != undefined) {
	    this.hV = params.hex;
            return this.hV;
	}

	if (typeof params == "number") {
	    bi = new BigInteger(String(params), 10);
	} else if (params["int"] != undefined) {
	    bi = new BigInteger(String(params["int"]), 10);
	} else if (params.bigint != undefined) {
	    bi = params.bigint;
	} else {
	    throw new Error("wrong parameter");
	}
	this.hV = _biToTwoCompl(bi);
        return this.hV;
    };

    if (params != undefined) {
	this.params = params;
    }
};
extendClass(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER encoded BitString primitive
 * @name KJUR.asn1.DERBitString
 * @class class for ASN.1 DER encoded BitString primitive
 * @extends KJUR.asn1.ASN1Object
 * @description 
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>bin - specify binary string (ex. '10111')</li>
 * <li>array - specify array of boolean (ex. [true,false,true,true])</li>
 * <li>hex - specify hexadecimal string of ASN.1 value(V) including unused bits</li>
 * <li>obj - specify {@link KJUR.asn1.ASN1Util.newObject} 
 * argument for "BitString encapsulates" structure.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: 'obj' parameter have been supported since
 * asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).<br/>
 *
 * @example
 * // default constructor
 * o = new KJUR.asn1.DERBitString();
 * // initialize with binary string
 * o = new KJUR.asn1.DERBitString({bin: "1011"});
 * // initialize with boolean array
 * o = new KJUR.asn1.DERBitString({array: [true,false,true,true]});
 * // initialize with hexadecimal string (04 is unused bits)
 * o = new KJUR.asn1.DERBitString({hex: "04bac0"});
 * // initialize with ASN1Util.newObject argument for encapsulated
 * o = new KJUR.asn1.DERBitString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // BIT STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   } 
 */
KJUR.asn1.DERBitString = function(params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
	var o = KJUR.asn1.ASN1Util.newObject(params.obj);
	params.hex = "00" + o.tohex();
    }
    KJUR.asn1.DERBitString.superclass.constructor.call(this);
    this.hT = "03";

    /**
     * set ASN.1 value(V) by a hexadecimal string including unused bits
     * @name setHexValueIncludingUnusedBits
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} newHexStringIncludingUnusedBits
     */
    this.setHexValueIncludingUnusedBits = function(newHexStringIncludingUnusedBits) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = newHexStringIncludingUnusedBits;
    };

    /**
     * set ASN.1 value(V) by unused bit and hexadecimal string of value
     * @name setUnusedBitsAndHexValue
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {Integer} unusedBits
     * @param {String} hValue
     */
    this.setUnusedBitsAndHexValue = function(unusedBits, hValue) {
        if (unusedBits < 0 || 7 < unusedBits) {
            throw "unused bits shall be from 0 to 7: u = " + unusedBits;
        }
        var hUnusedBits = "0" + unusedBits;
        this.hTLV = null;
        this.isModified = true;
        this.hV = hUnusedBits + hValue;
    };

    /**
     * set ASN.1 DER BitString by binary string<br/>
     * @name setByBinaryString
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} binaryString binary value string (i.e. '10111')
     * @description
     * Its unused bits will be calculated automatically by length of 
     * 'binaryValue'. <br/>
     * NOTE: Leading zeros '0' will be ignored.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBinaryString("1011");
     * o.setByBinaryString("001"); // leading zeros ignored
     */
    this.setByBinaryString = function(binaryString) {
        binaryString = binaryString.replace(/0+$/, '');
        var unusedBits = 8 - binaryString.length % 8;
        if (unusedBits == 8) unusedBits = 0;
	
	binaryString += "0000000".substr(0, unusedBits);

        var h = '';
        for (var i = 0; i < binaryString.length - 1; i += 8) {
            var b = binaryString.substr(i, 8);
            var x = parseInt(b, 2).toString(16);
            if (x.length == 1) x = '0' + x;
            h += x;  
        }
        this.hTLV = null;
        this.isModified = true;
        this.hV = '0' + unusedBits + h;
    };

    /**
     * set ASN.1 TLV value(V) by an array of boolean<br/>
     * @name setByBooleanArray
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {array} booleanArray array of boolean (ex. [true, false, true])
     * @description
     * NOTE: Trailing falses will be ignored in the ASN.1 DER Object.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray([false, true, false, true, true]);
     */
    this.setByBooleanArray = function(booleanArray) {
        var s = '';
        for (var i = 0; i < booleanArray.length; i++) {
            if (booleanArray[i] == true) {
                s += '1';
            } else {
                s += '0';
            }
        }
        this.setByBinaryString(s);
    };

    /**
     * generate an array of falses with specified length<br/>
     * @name newFalseArray
     * @memberOf KJUR.asn1.DERBitString
     * @function
     * @param {Integer} nLength length of array to generate
     * @return {array} array of boolean falses
     * @description
     * This static method may be useful to initialize boolean array.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.newFalseArray(3) &rarr; [false, false, false]
     */
    this.newFalseArray = function(nLength) {
        var a = new Array(nLength);
        for (var i = 0; i < nLength; i++) {
            a[i] = false;
        }
        return a;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params == "string" && params.toLowerCase().match(/^[0-9a-f]+$/)) {
            this.setHexValueIncludingUnusedBits(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setHexValueIncludingUnusedBits(params['hex']);
        } else if (typeof params['bin'] != "undefined") {
            this.setByBinaryString(params['bin']);
        } else if (typeof params['array'] != "undefined") {
            this.setByBooleanArray(params['array']);
        }
    }
};
extendClass(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER OctetString<br/>
 * @name KJUR.asn1.DEROctetString
 * @class class for ASN.1 DER OctetString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * This class provides ASN.1 OctetString simple type.<br/>
 * Supported "params" attributes are:
 * <ul>
 * <li>str - to set a string as a value</li>
 * <li>hex - to set a hexadecimal string as a value</li>
 * <li>obj - to set a encapsulated ASN.1 value by JSON object 
 * which is defined in {@link KJUR.asn1.ASN1Util.newObject}</li>
 * </ul>
 * NOTE: A parameter 'obj' have been supported 
 * for "OCTET STRING, encapsulates" structure.
 * since asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).
 * @see KJUR.asn1.DERAbstractString - superclass
 * @example
 * // default constructor
 * o = new KJUR.asn1.DEROctetString();
 * // initialize with string
 * o = new KJUR.asn1.DEROctetString({str: "aaa"});
 * // initialize with hexadecimal string
 * o = new KJUR.asn1.DEROctetString({hex: "616161"});
 * // initialize with ASN1Util.newObject argument 
 * o = new KJUR.asn1.DEROctetString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // OCTET STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   } 
 */
KJUR.asn1.DEROctetString = function(params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
	var o = KJUR.asn1.ASN1Util.newObject(params.obj);
	params.hex = o.tohex();
    }
    KJUR.asn1.DEROctetString.superclass.constructor.call(this, params);
    this.hT = "04";
};
extendClass(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER Null
 * @name KJUR.asn1.DERNull
 * @class class for ASN.1 DER Null
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERNull = function() {
    KJUR.asn1.DERNull.superclass.constructor.call(this);
    this.hT = "05";
    this.hTLV = "0500";
};
extendClass(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER ObjectIdentifier
 * @name KJUR.asn1.DERObjectIdentifier
 * @class class for ASN.1 DER ObjectIdentifier
 * @param {Object} JSON object or string of parameters (ex. {'oid': '2.5.4.5'})
 * @extends KJUR.asn1.ASN1Object
 * @see oidtohex
 * 
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>oid - specify initial ASN.1 value(V) by a oid string (ex. 2.5.4.13)</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * @example
 * new DERObjectIdentifier({"name": "sha1"})
 * new DERObjectIdentifier({"oid": "1.2.3.4"})
 * new DERObjectIdentifier({"hex": "2d..."})
 * new DERObjectIdentifier("1.2.3.4")
 * new DERObjectIdentifier("SHA1withRSA")
 */
KJUR.asn1.DERObjectIdentifier = function(params) {
    KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
    this.hT = "06";

    /**
     * set value by a hexadecimal string
     * @name setValueHex
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} newHexString hexadecimal value of OID bytes
     */
    this.setValueHex = function(newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };

    /**
     * set value by a OID string<br/>
     * @name setValueOidString
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidString OID string (ex. 2.5.4.13)
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueOidString("2.5.4.13");
     */
    this.setValueOidString = function(oidString) {
	var h = oidtohex(oidString);
	if (h == null)
            throw new Error("malformed oid string: " + oidString);
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = h;
    };

    /**
     * set value by a OID name
     * @name setValueName
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidName OID name (ex. 'serverAuth')
     * @since 1.0.1
     * @description
     * OID name shall be defined in 'KJUR.asn1.x509.OID.name2oidList'.
     * Otherwise raise error.
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueName("serverAuth");
     */
    this.setValueName = function(oidName) {
	var oid = KJUR.asn1.x509.OID.name2oid(oidName);
	if (oid !== '') {
            this.setValueOidString(oid);
        } else {
            throw new Error("DERObjectIdentifier oidName undefined: " + oidName);
        }
    };

    this.setValueNameOrOid = function(nameOrOid) {
	if (nameOrOid.match(/^[0-2].[0-9.]+$/)) {
	    this.setValueOidString(nameOrOid);
	} else {
	    this.setValueName(nameOrOid);
	}
    }

    this.getFreshValueHex = function() {
        return this.hV;
    };

    this.setByParam = function(params) {
        if (typeof params === "string") {
	    this.setValueNameOrOid(params);
        } else if (params.oid !== undefined) {
	    this.setValueNameOrOid(params.oid);
        } else if (params.name !== undefined) {
            this.setValueNameOrOid(params.name);
        } else if (params.hex !== undefined) {
            this.setValueHex(params.hex);
        }
    };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER Enumerated
 * @name KJUR.asn1.DEREnumerated
 * @class class for ASN.1 DER Enumerated
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * @example
 * new KJUR.asn1.DEREnumerated(123);
 * new KJUR.asn1.DEREnumerated({int: 123});
 * new KJUR.asn1.DEREnumerated({hex: '1fad'});
 */
KJUR.asn1.DEREnumerated = function(params) {
    KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
    this.hT = "0a";

    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function(bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };

    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function(intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };

    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     */
    this.setValueHex = function(newHexString) {
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        } else if (typeof params == "number") {
            this.setByInteger(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
extendClass(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER UTF8String
 * @name KJUR.asn1.DERUTF8String
 * @class class for ASN.1 DER UTF8String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERUTF8String = function(params) {
    KJUR.asn1.DERUTF8String.superclass.constructor.call(this, params);
    this.hT = "0c";
};
extendClass(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER NumericString
 * @name KJUR.asn1.DERNumericString
 * @class class for ASN.1 DER NumericString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERNumericString = function(params) {
    KJUR.asn1.DERNumericString.superclass.constructor.call(this, params);
    this.hT = "12";
};
extendClass(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER PrintableString
 * @name KJUR.asn1.DERPrintableString
 * @class class for ASN.1 DER PrintableString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERPrintableString = function(params) {
    KJUR.asn1.DERPrintableString.superclass.constructor.call(this, params);
    this.hT = "13";
};
extendClass(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER TeletexString
 * @name KJUR.asn1.DERTeletexString
 * @class class for ASN.1 DER TeletexString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERTeletexString = function(params) {
    KJUR.asn1.DERTeletexString.superclass.constructor.call(this, params);
    this.hT = "14";
};
extendClass(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER IA5String
 * @name KJUR.asn1.DERIA5String
 * @class class for ASN.1 DER IA5String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERIA5String = function(params) {
    KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);
    this.hT = "16";
};
extendClass(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER VisibleString
 * @name KJUR.asn1.DERVisibleString
 * @class class for ASN.1 DER VisibleString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @since jsrsasign 8.0.23 asn1 1.0.15
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERVisibleString = function(params) {
    KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);
    this.hT = "1a";
};
extendClass(KJUR.asn1.DERVisibleString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER BMPString
 * @name KJUR.asn1.DERBMPString
 * @class class for ASN.1 DER BMPString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @since jsrsasign 8.0.23 asn1 1.0.15
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERBMPString = function(params) {
    KJUR.asn1.DERBMPString.superclass.constructor.call(this, params);
    this.hT = "1e";
};
extendClass(KJUR.asn1.DERBMPString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER UTCTime
 * @name KJUR.asn1.DERUTCTime
 * @class class for ASN.1 DER UTCTime
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.DERAbstractTime
 * @see KJUR.asn1.DERGeneralizedTime
 * @see KJUR.asn1.x509.Time
 *
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'130430235959Z')</li>
 * <li>date - specify Date object.</li>
 * <li>millis - specify flag to show milliseconds (from 1.0.6)</li>
 * </ul>
 * NOTE1: 'params' can be omitted.
 * NOTE2: 'millis' property is supported from jsrsasign 10.4.1 asn1 1.0.22.
 *
 * <h4>EXAMPLES</h4>
 * @example
 * new DERUTCTime("20151231235959Z")
 * new DERUTCTime("20151231235959.123Z")
 * new DERUTCTime(new Date())
 * new DERUTCTime(new Date(Date.UTC(2015,11,31,23,59,59,123)))
 * new DERUTCTime({str: "20151231235959.123Z"})
 * new DERUTCTime({date: new Date()})
 * new DERUTCTime({date: new Date(), millis: true})
 * new DERUTCTime({millis: true})
 */
KJUR.asn1.DERUTCTime = function(params) {
    KJUR.asn1.DERUTCTime.superclass.constructor.call(this, params);
    this.hT = "17";
    this.params = undefined;

    this.getFreshValueHex = function() {
	var params = this.params;

	if (this.params == undefined) params = { date: new Date() };

	if (typeof params == "string") {
	    if (params.match(/^[0-9]{12}Z$/) ||
		params.match(/^[0-9]{12}\.[0-9]+Z$/)) {
		this.hV = stohex(params);
	    } else {
		throw new Error("malformed string for UTCTime: " + params);
	    }
	} else if (params.str != undefined) {
	    this.hV = stohex(params.str);
	} else if (params.date == undefined && params.millis == true) {
	    var date = new Date();
	    this.hV = stohex(this.formatDate(date, 'utc', true));
	} else if (params.date != undefined &&
		   params.date instanceof Date) {
	    var withMillis = (params.millis === true);
	    this.hV = stohex(this.formatDate(params.date, 'utc', withMillis));
	} else if (params instanceof Date) {
	    this.hV = stohex(this.formatDate(params, 'utc'));
	}

	if (this.hV == undefined) {
	    throw new Error("parameter not specified properly for UTCTime");
	}
	return this.hV;
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);

// ********************************************************************
/**
 * class for ASN.1 DER GeneralizedTime
 * @name KJUR.asn1.DERGeneralizedTime
 * @class class for ASN.1 DER GeneralizedTime
 * @param {Array} params associative array of parameters (ex. {'str': '20130430235959Z'})
 * @property {Boolean} withMillis flag to show milliseconds or not
 * @extends KJUR.asn1.DERAbstractTime
 * @see KJUR.asn1.DERUTCTime
 * @see KJUR.asn1.x509.Time
 *
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'20130430235959Z')</li>
 * <li>date - specify Date object.</li>
 * <li>millis - specify flag to show milliseconds (from 1.0.6)</li>
 * </ul>
 * NOTE1: 'params' can be omitted.
 * NOTE2: 'millis' property is supported from asn1 1.0.6.
 *
 * <h4>EXAMPLES</h4>
 * @example
 * new DERGeneralizedTime("20151231235959Z")
 * new DERGeneralizedTime("20151231235959.123Z")
 * new DERGeneralizedTime(new Date())
 * new DERGeneralizedTime(new Date(Date.UTC(2015,11,31,23,59,59,123)))
 * new DERGeneralizedTime({str: "20151231235959.123Z"})
 * new DERGeneralizedTime({date: new Date()})
 * new DERGeneralizedTime({date: new Date(), millis: true})
 * new DERGeneralizedTime({millis: true})
 */
KJUR.asn1.DERGeneralizedTime = function(params) {
    KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);
    this.hT = "18";
    this.params = params;

    this.getFreshValueHex = function() {
	var params = this.params;

	if (this.params == undefined) params = { date: new Date() };

	if (typeof params == "string") {
	    if (params.match(/^[0-9]{14}Z$/) ||
		params.match(/^[0-9]{14}\.[0-9]+Z$/)) {
		this.hV = stohex(params);
	    } else {
		throw new Error("malformed string for GeneralizedTime: " + params);
	    }
	} else if (params.str != undefined) {
	    this.hV = stohex(params.str);
	} else if (params.date == undefined && params.millis == true) {
	    var date = new Date();
	    this.hV = stohex(this.formatDate(date, 'gen', true));
	} else if (params.date != undefined &&
		   params.date instanceof Date) {
	    var withMillis = (params.millis === true);
	    this.hV = stohex(this.formatDate(params.date, 'gen', withMillis));
	} else if (params instanceof Date) {
	    this.hV = stohex(this.formatDate(params, 'gen'));
	}

	if (this.hV == undefined) {
	    throw new Error("parameter not specified properly for GeneralizedTime");
	}
	return this.hV;
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);

// ********************************************************************
/**
 * class for ASN.1 DER Sequence
 * @name KJUR.asn1.DERSequence
 * @class class for ASN.1 DER Sequence
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERSequence = function(params) {
    KJUR.asn1.DERSequence.superclass.constructor.call(this, params);
    this.hT = "30";
    this.getFreshValueHex = function() {
        var h = '';
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            h += asn1Obj.tohex();
        }
        this.hV = h;
        return this.hV;
    };
};
extendClass(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);

// ********************************************************************
/**
 * class for ASN.1 DER Set
 * @name KJUR.asn1.DERSet
 * @class class for ASN.1 DER Set
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * <li>sortflag - flag for sort (default: true). ASN.1 BER is not sorted in 'SET OF'.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: sortflag is supported since 1.0.5.
 */
KJUR.asn1.DERSet = function(params) {
    KJUR.asn1.DERSet.superclass.constructor.call(this, params);
    this.hT = "31";
    this.sortFlag = true; // item shall be sorted only in ASN.1 DER
    this.getFreshValueHex = function() {
        var a = new Array();
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            a.push(asn1Obj.tohex());
        }
        if (this.sortFlag == true) a.sort();
        this.hV = a.join('');
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params.sortflag != "undefined" &&
            params.sortflag == false)
            this.sortFlag = false;
    }
};
extendClass(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);

// ********************************************************************
/**
 * class for ASN.1 DER TaggedObject
 * @name KJUR.asn1.DERTaggedObject
 * @class class for ASN.1 DER TaggedObject
 * @extends KJUR.asn1.ASN1Object
 * @see KJUR_asn1.ASN1Util.newObject
 *
 * @description
 * <br/>
 * Parameter 'tagNoNex' is ASN.1 tag(T) value for this object.
 * For example, if you find '[1]' tag in a ASN.1 dump, 
 * 'tagNoHex' will be 'a1'.
 * <br/>
 * As for optional argument 'params' for constructor, you can specify *ANY* of
 * following properties:
 * <ul>
 * <li>tag - specify tag (default is 'a0' which means [0])</li>
 * <li>explicit - specify true if this is explicit tag otherwise false 
 *     (default is 'true').</li>
 * <li>obj - specify ASN1Object or JSON object which will be tagged</li>
 * <li>tage - specify tag with explicit</li>
 * <li>tagi - specify tag with implicit</li>
 * </ul>
 * As for the member "obj" value of JSON object, 
 * {@link KJUR_asn1.ASN1Util.newObject} is used to generate.
 *
 * @example
 * // by JSON
 * new KJUR.asn1.DERTaggedObject({
 *  tag:'a0', explicit: true, obj: { "prnstr": { "str": "aaa" } }
 * }).tohex()
 *
 * // by ASN1Object object
 * new KJUR.asn1.DERTaggedObject({
 *  tage:'a0', obj: new KJUR.asn1.DERInteger({int: 3}) // explicit
 * }) 
 * new KJUR.asn1.DERTaggedObject({
 *  tagi:'a0', obj: new KJUR.asn1.DERInteger({int: 3}) // implicit
 * }) 
 * new KJUR.asn1.DERTaggedObject({
 *  tag:'a0', explicit: true, obj: new KJUR.asn1.DERInteger({int: 3}) // explicit
 * }) 
 *
 * // to hexadecimal
 * d1 = new KJUR.asn1.DERUTF8String({str':'a'})
 * d2 = new KJUR.asn1.DERTaggedObject({'obj': d1});
 * hex = d2.tohex();
 */
KJUR.asn1.DERTaggedObject = function(params) {
    KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);

    var _KJUR_asn1 = KJUR.asn1,
	_ASN1HEX = ASN1HEX,
	_getV = _ASN1HEX.getV,
	_isASN1HEX = _ASN1HEX.isASN1HEX,
	_newObject = _KJUR_asn1.ASN1Util.newObject;

    this.hT = "a0";
    this.hV = '';
    this.isExplicit = true;
    this.asn1Object = null;
    this.params = {tag: "a0", explicit: true}; //"tag": "a0, "explicit": true};

    /**
     * set value by an ASN1Object
     * @name setString
     * @memberOf KJUR.asn1.DERTaggedObject#
     * @function
     * @param {Boolean} isExplicitFlag flag for explicit/implicit tag
     * @param {Integer} tagNoHex hexadecimal string of ASN.1 tag
     * @param {ASN1Object} asn1Object ASN.1 to encapsulate
     * @deprecated since jsrsasign 10.5.4 please use setByParam instead
     */
    this.setASN1Object = function(isExplicitFlag, tagNoHex, asn1Object) {
	this.params = {tag: tagNoHex,
		       explicit: isExplicitFlag,
		       obj: asn1Object};
    };

    this.getFreshValueHex = function() {
	var params = this.params;

	if (params.explicit == undefined) params.explicit = true;

	if (params.tage != undefined) {
	    params.tag = params.tage;
	    params.explicit = true;
	}
	if (params.tagi != undefined) {
	    params.tag = params.tagi;
	    params.explicit = false;
	}

	if (params.str != undefined) {
	    this.hV = utf8tohex(params.str);
	} else if (params.hex != undefined) {
	    this.hV = params.hex;
	} else if (params.obj != undefined) {
	    var hV1;
	    if (params.obj instanceof _KJUR_asn1.ASN1Object) {
		hV1 = params.obj.tohex();
	    } else if (typeof params.obj == "object") {
		hV1 = _newObject(params.obj).tohex();
	    }
	    if (params.explicit) {
		this.hV = hV1;
	    } else {
		this.hV = _getV(hV1, 0);
	    }
	} else {
	    throw new Error("str, hex nor obj not specified");
	}

	if (params.tag == undefined) params.tag = "a0";
	this.hT = params.tag;
        this.hTLV = null;
        this.isModified = true;

        return this.hV;
    };

    this.setByParam = function(params) {
	this.params = params;
    };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);

/* asn1hex-1.2.15.js (c) 2012-2022 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * asn1hex.js - Hexadecimal represented ASN.1 string library
 *
 * Copyright (c) 2010-2022 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license/
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name asn1hex-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.5.23 asn1hex 1.2.15 (2022-May-27)
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/*
 * MEMO:
 *   f('3082025b02...', 2) ... 82025b ... 3bytes
 *   f('020100', 2) ... 01 ... 1byte
 *   f('0203001...', 2) ... 03 ... 1byte
 *   f('02818003...', 2) ... 8180 ... 2bytes
 *   f('3080....0000', 2) ... 80 ... -1
 *
 *   Requirements:
 *   - ASN.1 type octet length MUST be 1. 
 *     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)
 */

/**
 * ASN.1 DER encoded hexadecimal string utility class
 * @name ASN1HEX
 * @class ASN.1 DER encoded hexadecimal string utility class
 * @since jsrsasign 1.1
 * @description
 * This class provides a parser for hexadecimal string of
 * DER encoded ASN.1 binary data.
 * Here are major methods of this class.
 * <ul>
 * <li><b>ACCESS BY POSITION</b>
 *   <ul>
 *   <li>{@link ASN1HEX.getTLV} - get ASN.1 TLV at specified position</li>
 *   <li>{@link ASN1HEX.getTLVblen} - get byte length of ASN.1 TLV at specified position</li>
 *   <li>{@link ASN1HEX.getV} - get ASN.1 V at specified position</li>
 *   <li>{@link ASN1HEX.getVblen} - get integer ASN.1 L at specified position</li>
 *   <li>{@link ASN1HEX.getVidx} - get ASN.1 V position from its ASN.1 TLV position</li>
 *   <li>{@link ASN1HEX.getL} - get hexadecimal ASN.1 L at specified position</li>
 *   <li>{@link ASN1HEX.getLblen} - get byte length for ASN.1 L(length) bytes</li>
 *   </ul>
 * </li>
 * <li><b>ACCESS FOR CHILD ITEM</b>
 *   <ul>
 *   <li>{@link ASN1HEX.getNthChildIdx} - get nth child index at specified position</li>
 *   <li>{@link ASN1HEX.getChildIdx} - get indexes of children</li>
 *   <li>{@link ASN1HEX.getNextSiblingIdx} - get position of next sibling (DEPRECATED)</li>
 *   </ul>
 * </li>
 * <li><b>ACCESS NESTED ASN.1 STRUCTURE</b>
 *   <ul>
 *   <li>{@link ASN1HEX.getTLVbyList} - get ASN.1 TLV at specified list index</li>
 *   <li>{@link ASN1HEX.getVbyList} - get ASN.1 V at specified nth list index with checking expected tag</li>
 *   <li>{@link ASN1HEX.getIdxbyList} - get index at specified list index</li>
 *   </ul>
 * </li>
 * <li><b>(NEW)ACCESS NESTED ASN.1 STRUCTURE</b>
 *   <ul>
 *   <li>{@link ASN1HEX.getTLVbyListEx} - get ASN.1 TLV at specified list index</li>
 *   <li>{@link ASN1HEX.getVbyListEx} - get ASN.1 V at specified nth list index with checking expected tag</li>
 *   <li>{@link ASN1HEX.getIdxbyListEx} - get index at specified list index</li>
 *   </ul>
 * </li>
 * <li><b>UTILITIES</b>
 *   <ul>
 *   <li>{@link ASN1HEX.dump} - dump ASN.1 structure</li>
 *   <li>{@link ASN1HEX.isContextTag} - check if a hexadecimal tag is a specified ASN.1 context specific tag</li>
 *   <li>{@link ASN1HEX.isASN1HEX} - simple ASN.1 DER hexadecimal string checker</li>
 *   <li>{@link ASN1HEX.checkStrictDER} - strict ASN.1 DER hexadecimal string checker</li>
 *   <li>{@link ASN1HEX.hextooidstr} - convert hexadecimal string of OID to dotted integer list</li>
 *   </ul>
 * </li>
 * </ul>
 */
var ASN1HEX = new function() {
};

/**
 * get byte length for ASN.1 L(length) bytes<br/>
 * @name getLblen
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx string index
 * @return byte length for ASN.1 L(length) bytes
 * @since jsrsasign 7.2.0 asn1hex 1.1.11
 * @example
 * ASN1HEX.getLblen('020100', 0) &rarr; 1 for '01'
 * ASN1HEX.getLblen('020200', 0) &rarr; 1 for '02'
 * ASN1HEX.getLblen('02818003...', 0) &rarr; 2 for '8180'
 * ASN1HEX.getLblen('0282025b03...', 0) &rarr; 3 for '82025b'
 * ASN1HEX.getLblen('0280020100...', 0) &rarr; -1 for '80' BER indefinite length
 * ASN1HEX.getLblen('02ffab...', 0) &rarr; -2 for malformed ASN.1 length
 */
ASN1HEX.getLblen = function(s, idx) {
    if (s.substr(idx + 2, 1) != '8') return 1;
    var i = parseInt(s.substr(idx + 3, 1));
    if (i == 0) return -1;             // length octet '80' indefinite length
    if (0 < i && i < 10) return i + 1; // including '8?' octet;
    return -2;                         // malformed format
};

/**
 * get hexadecimal string for ASN.1 L(length) bytes<br/>
 * @name getL
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx string index to get L of ASN.1 object
 * @return {String} hexadecimal string for ASN.1 L(length) bytes
 * @since jsrsasign 7.2.0 asn1hex 1.1.11
 */
ASN1HEX.getL = function(s, idx) {
    var len = ASN1HEX.getLblen(s, idx);
    if (len < 1) return '';
    return s.substr(idx + 2, len * 2);
};

/**
 * get integer value of ASN.1 length for ASN.1 data<br/>
 * @name getVblen
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx string index
 * @return {Number} ASN.1 L(length) integer value
 * @since jsrsasign 7.2.0 asn1hex 1.1.11
 */
/*
 getting ASN.1 length value at the position 'idx' of
 hexa decimal string 's'.
 f('3082025b02...', 0) ... 82025b ... ???
 f('020100', 0) ... 01 ... 1
 f('0203001...', 0) ... 03 ... 3
 f('02818003...', 0) ... 8180 ... 128
 */
ASN1HEX.getVblen = function(s, idx) {
    var hLen, bi;
    hLen = ASN1HEX.getL(s, idx);
    if (hLen == '') return -1;
    if (hLen.substr(0, 1) === '8') {
        bi = new BigInteger(hLen.substr(2), 16);
    } else {
        bi = new BigInteger(hLen, 16);
    }
    return bi.intValue();
};

/**
 * get ASN.1 value starting string position for ASN.1 object refered by index 'idx'.
 * @name getVidx
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx string index
 * @since jsrsasign 7.2.0 asn1hex 1.1.11
 */
ASN1HEX.getVidx = function(s, idx) {
    var l_len = ASN1HEX.getLblen(s, idx);
    if (l_len < 0) return l_len;
    return idx + (l_len + 1) * 2;
};

/**
 * get hexadecimal string of ASN.1 V(value)<br/>
 * @name getV
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx string index
 * @return {String} hexadecimal string of ASN.1 value.
 * @since jsrsasign 7.2.0 asn1hex 1.1.11
 */
ASN1HEX.getV = function(s, idx) {
    var idx1 = ASN1HEX.getVidx(s, idx);
    var blen = ASN1HEX.getVblen(s, idx);
    return s.substr(idx1, blen * 2);
};

/**
 * get hexadecimal string of ASN.1 TLV at<br/>
 * @name getTLV
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx string index
 * @return {String} hexadecimal string of ASN.1 TLV.
 * @since jsrsasign 7.2.0 asn1hex 1.1.11
 */
ASN1HEX.getTLV = function(s, idx) {
    return s.substr(idx, 2) + ASN1HEX.getL(s, idx) + ASN1HEX.getV(s, idx);
};

/**
 * get byte length of ASN.1 TLV at specified string index<br/>
 * @name getTLVblen
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx string index to get ASN.1 TLV byte length
 * @return {Number} byte length of ASN.1 TLV
 * @since jsrsasign 9.1.5 asn1hex 1.1.11
 *
 * @description
 * This method returns a byte length of ASN.1 TLV at
 * specified string index.
 *
 * @example
 *                        v string indx=42
 * ASN1HEX.getTLVblen("...1303616161...", 42) &rarr; 10 (PrintableString 'aaa')
 */
ASN1HEX.getTLVblen = function(h, idx) {
    return 2 + ASN1HEX.getLblen(h, idx) * 2 + ASN1HEX.getVblen(h, idx) * 2;
};

// ========== sibling methods ================================

/**
 * get next sibling starting index for ASN.1 object string (DEPRECATED)<br/>
 * @name getNextSiblingIdx
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx string index
 * @return {Number} next sibling starting index for ASN.1 object string
 * @since jsrsasign 7.2.0 asn1hex 1.1.11
 * @deprecated jsrsasign 9.1.5 asn1hex 1.2.5 Please use {@link ASN1HEX.getTLVblen}
 *
 * @example
 * SEQUENCE { INTEGER 3, INTEGER 4 }
 * 3006
 *     020103 :idx=4
 *           020104 :next sibling idx=10
 * getNextSiblingIdx("3006020103020104", 4) & rarr 10
 */
ASN1HEX.getNextSiblingIdx = function(s, idx) {
    var idx1 = ASN1HEX.getVidx(s, idx);
    var blen = ASN1HEX.getVblen(s, idx);
    return idx1 + blen * 2;
};

// ========== children methods ===============================
/**
 * get array of string indexes of child ASN.1 objects<br/>
 * @name getChildIdx
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx start string index of ASN.1 object
 * @return {Array of Number} array of indexes for childen of ASN.1 objects
 * @since jsrsasign 7.2.0 asn1hex 1.1.11
 * @description
 * This method returns array of integers for a concatination of ASN.1 objects
 * in a ASN.1 value. As for BITSTRING, one byte of unusedbits is skipped.
 * As for other ASN.1 simple types such as INTEGER, OCTET STRING or PRINTABLE STRING,
 * it returns a array of a string index of its ASN.1 value.<br/>
 * NOTE: Since asn1hex 1.1.7 of jsrsasign 6.1.2, Encapsulated BitString is supported.
 * @example
 * ASN1HEX.getChildIdx("0203012345", 0) &rArr; [4] // INTEGER 012345
 * ASN1HEX.getChildIdx("1303616161", 0) &rArr; [4] // PrintableString aaa
 * ASN1HEX.getChildIdx("030300ffff", 0) &rArr; [6] // BITSTRING ffff (unusedbits=00a)
 * ASN1HEX.getChildIdx("3006020104020105", 0) &rArr; [4, 10] // SEQUENCE(INT4,INT5)
 */
ASN1HEX.getChildIdx = function(h, idx) {
    var _ASN1HEX = ASN1HEX;
    var a = [];
    var idxStart, totalChildBlen, currentChildBlen;

    idxStart = _ASN1HEX.getVidx(h, idx);
    totalChildBlen = _ASN1HEX.getVblen(h, idx) * 2;
    if (h.substr(idx, 2) == "03") {  // BITSTRING without unusedbits
	idxStart += 2;
	totalChildBlen -= 2;
    }

    currentChildBlen = 0;
    var i = idxStart;
    while (currentChildBlen <= totalChildBlen) {
	var tlvBlen = _ASN1HEX.getTLVblen(h, i);
	currentChildBlen += tlvBlen;
	if (currentChildBlen <= totalChildBlen) a.push(i);
	i += tlvBlen;
	if (currentChildBlen >= totalChildBlen) break;
    }
    return a;
};

/**
 * get string index of nth child object of ASN.1 object refered by h, idx<br/>
 * @name getNthChildIdx
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx start string index of ASN.1 object
 * @param {Number} nth for child
 * @return {Number} string index of nth child.
 * @since jsrsasign 7.2.0 asn1hex 1.1.11
 */
ASN1HEX.getNthChildIdx = function(h, idx, nth) {
    var a = ASN1HEX.getChildIdx(h, idx);
    return a[nth];
};

// ========== decendant methods ==============================
/**
 * get string index of nth child object of ASN.1 object refered by h, idx<br/>
 * @name getIdxbyList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} currentIndex start string index of ASN.1 object
 * @param {Array of Number} nthList array list of nth
 * @param {String} checkingTag (OPTIONAL) string of expected ASN.1 tag for nthList 
 * @return {Number} string index refered by nthList
 * @since jsrsasign 7.1.4 asn1hex 1.1.10.
 * @description
 * @example
 * The "nthList" is a index list of structured ASN.1 object
 * reference. Here is a sample structure and "nthList"s which
 * refers each objects.
 *
 * SQUENCE               - 
 *   SEQUENCE            - [0]
 *     IA5STRING 000     - [0, 0]
 *     UTF8STRING 001    - [0, 1]
 *   SET                 - [1]
 *     IA5STRING 010     - [1, 0]
 *     UTF8STRING 011    - [1, 1]
 */
ASN1HEX.getIdxbyList = function(h, currentIndex, nthList, checkingTag) {
    var _ASN1HEX = ASN1HEX;
    var firstNth, a;
    if (nthList.length == 0) {
	if (checkingTag !== undefined) {
            if (h.substr(currentIndex, 2) !== checkingTag) return -1;
	}
        return currentIndex;
    }
    firstNth = nthList.shift();
    a = _ASN1HEX.getChildIdx(h, currentIndex);
    if (firstNth >= a.length) return -1;

    return _ASN1HEX.getIdxbyList(h, a[firstNth], nthList, checkingTag);
};

/**
 * get string index of nth child object of ASN.1 object refered by h, idx<br/>
 * @name getIdxbyListEx
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} currentIndex start string index of ASN.1 object
 * @param {Array of Object} nthList array list of nth index value or context specific tag string (ex. "[0]")
 * @param {String} checkingTag (OPTIONAL) string of expected ASN.1 tag for nthList 
 * @return {Number} string index refered by nthList. return -1 if not found
 * @since jsrsasign 8.0.21 asn1hex 1.2.2
 * @see <a href="https://github.com/kjur/jsrsasign/wiki/Tutorial-for-accessing-deep-inside-of-ASN.1-structure-by-using-new-ASN1HEX.getIdxbyListEx">ASN1HEX.getIdxbyListEx tutorial wiki page</a>
 *
 * @description
 * This method returns the string index in h specified by currentIndex and
 * nthList. This is useful to dig into a deep structured ASN.1 object
 * by indexes called nthList. 
 * <br/>
 * A nthList consists of a position number in children of ASN.1
 * structured data or a context specific tag string (ex. "[1]").
 * Here is a sample deep structured ASN.1 data and
 * nthLists referring decendent objects.
 * <blockquote><pre>
 * SQUENCE               - referring nthList is below:
 *   SEQUENCE            - [0]
 *     IA5STRING "a1"    - [0, 0]
 *     UTF8STRING "a2"   - [0, 1]
 *   SET                 - [1]
 *     IA5STRING "b1"    - [1, 0]
 *     UTF8STRING "b2"   - [1, 1]
 *     [0] "b3"          - [1, "[0]"] // optional since context tag
 *     [1] "b4"          - [1, "[1]"] // optional since context tag
 *     IA5STRING "b5"    - [1, 2] // context is skipped. next is 2
 *     UTF8STRING "b6"   - [1, 3]
 * </pre></blockquote>
 *
 * <br/>
 * This method can dig into ASN.1 object encapsulated by
 * OctetString or BitString with unused bits.
 *
 * @example
 * 3014 seq idx=0
 *   3012 seq idx=4
 *     020101 int:1 idx=8
 *     020102 int:2 idx=14
 *     800103 [0]:3 idx=20
 *     810104 [1]:4 idx=26
 *     020105 int:5 idx=32
 *     020106 int:6 idx=38
 * h = "30140412020101020102800103810104020105020106";
 * ASN1HEX.getIdxbyListEx(h, 0, [0, "[0]"]) &rarr; 16
 * ASN1HEX.getIdxbyListEx(h, 0, [0, 2]) &rarr; 28
 * ASN1HEX.getIdxbyListEx(h, 0, [0, 2], "0c") &rarr; -1 //not UTF8String(0c)
 */
ASN1HEX.getIdxbyListEx = function(h, currentIndex, nthList, checkingTag) {
    var _ASN1HEX = ASN1HEX;
    var firstNth, a;
    if (nthList.length == 0) {
	if (checkingTag !== undefined) {
            if (h.substr(currentIndex, 2) !== checkingTag) {
		return -1;
            }
	}
        return currentIndex;
    }
    firstNth = nthList.shift();
    a = _ASN1HEX.getChildIdx(h, currentIndex);

    var count = 0;
    for (var i = 0; i < a.length; i++) {
	var childTag = h.substr(a[i], 2);

	if ((typeof firstNth == "number" &&
	     (! _ASN1HEX.isContextTag(childTag)) &&
	     count == firstNth) ||
	    (typeof firstNth == "string" &&
	     _ASN1HEX.isContextTag(childTag, firstNth))) {
	    return _ASN1HEX.getIdxbyListEx(h, a[i], nthList, checkingTag);
	}
	if (! _ASN1HEX.isContextTag(childTag)) count++;
    }
    return -1;
};

/**
 * get ASN.1 TLV by nthList<br/>
 * @name getTLVbyList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 structure
 * @param {Integer} currentIndex string index to start searching in hexadecimal string "h"
 * @param {Array} nthList array of nth list index
 * @param {String} checkingTag (OPTIONAL) string of expected ASN.1 tag for nthList 
 * @return {String} referred hexadecimal string of ASN.1 TLV or null
 * @since jsrsasign 7.1.4 asn1hex 1.1.10
 *
 * @description
 * This static method is to get a ASN.1 value which specified "nthList" position
 * with checking expected tag "checkingTag".
 * <br/>
 * When referring value can't be found, this returns null.
 */
ASN1HEX.getTLVbyList = function(h, currentIndex, nthList, checkingTag) {
    var _ASN1HEX = ASN1HEX;
    var idx = _ASN1HEX.getIdxbyList(h, currentIndex, nthList, checkingTag);

    if (idx == -1) return null;
    if (idx >= h.length) return null;

    return _ASN1HEX.getTLV(h, idx);
};

/**
 * get ASN.1 TLV by nthList<br/>
 * @name getTLVbyListEx
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 structure
 * @param {Integer} currentIndex string index to start searching in hexadecimal string "h"
 * @param {Array of Object} nthList array list of nth index value or context specific tag string (ex. "[0]")
 * @param {String} checkingTag (OPTIONAL) string of expected ASN.1 tag for nthList 
 * @return {String} hexadecimal ASN.1 TLV string refered by nthList. return null if not found
 * @since jsrsasign 8.0.21 asn1hex 1.2.2
 * @see <a href="https://github.com/kjur/jsrsasign/wiki/Tutorial-for-accessing-deep-inside-of-ASN.1-structure-by-using-new-ASN1HEX.getIdxbyListEx">ASN1HEX.getIdxbyListEx tutorial wiki page</a>
 * @see {@link ASN1HEX.getIdxbyListEx}
 * @description
 * This static method is to get a ASN.1 value which specified "nthList" position
 * with checking expected tag "checkingTag".
 * This method can dig into ASN.1 object encapsulated by
 * OctetString or BitString with unused bits.
 * @example
 * 3014 seq idx=0
 *   0312 seq idx=4
 *     020101 int:1 idx=8
 *     020102 int:2 idx=14
 *     800103 [0]:3 idx=20
 *     810104 [1]:4 idx=26
 *     020105 int:5 idx=32
 *     020106 int:6 idx=38
 * h = "30140412020101020102800103810104020105020106";
 * ASN1HEX.getTLVbyList(h, 0, [0, "[0]"]) &rarr; 800103
 * ASN1HEX.getTLVbyList(h, 0, [0, 2]) &rarr; 020105
 * ASN1HEX.getTLVbyList(h, 0, [0, 2], "0c") &rarr; null //not UTF8String(0c)
 */
ASN1HEX.getTLVbyListEx = function(h, currentIndex, nthList, checkingTag) {
    var _ASN1HEX = ASN1HEX;
    var idx = _ASN1HEX.getIdxbyListEx(h, currentIndex, nthList, checkingTag);
    if (idx == -1) return null;
    return _ASN1HEX.getTLV(h, idx);
};

/**
 * get ASN.1 value by nthList<br/>
 * @name getVbyList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 structure
 * @param {Integer} currentIndex string index to start searching in hexadecimal string "h"
 * @param {Array} nthList array of nth list index
 * @param {String} checkingTag (OPTIONAL) string of expected ASN.1 tag for nthList 
 * @param {Boolean} removeUnusedbits (OPTIONAL) flag for remove first byte for value (DEFAULT false)
 * @return {String} referred hexadecimal string of ASN.1 value(V) or null
 * @since asn1hex 1.1.4
 * @see ASN1HEX.getIdxbyList
 * @see ASN1HEX.getVbyListEx
 *
 * @description
 * This static method is to get a ASN.1 value which specified "nthList" position
 * with checking expected tag "checkingTag".
 * <br/>
 * When referring value can't be found, this returns null.
 * <br/>
 * NOTE: 'removeUnusedbits' flag has been supported since
 * jsrsasign 7.1.14 asn1hex 1.1.10.
 */
ASN1HEX.getVbyList = function(h, currentIndex, nthList, checkingTag, removeUnusedbits) {
    var _ASN1HEX = ASN1HEX;
    var idx, v;
    idx = _ASN1HEX.getIdxbyList(h, currentIndex, nthList, checkingTag);
    
    if (idx == -1) return null;
    if (idx >= h.length) return null;

    v = _ASN1HEX.getV(h, idx);
    if (removeUnusedbits === true) v = v.substr(2);
    return v;
};

/**
 * get ASN.1 V by nthList<br/>
 * @name getVbyListEx
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 structure
 * @param {Integer} currentIndex string index to start searching in hexadecimal string "h"
 * @param {Array of Object} nthList array list of nth index value or context specific tag string (ex. "[0]")
 * @param {String} checkingTag (OPTIONAL) string of expected ASN.1 tag for nthList (default is undefined)
 * @param {Boolean} removeUnusedbits (OPTIONAL) flag for trim unused bit from result value (default is undefined)
 * @return {String} hexadecimal ASN.1 V string refered by nthList. return null if not found
 * @since jsrsasign 8.0.21 asn1hex 1.2.2
 * @see <a href="https://github.com/kjur/jsrsasign/wiki/Tutorial-for-accessing-deep-inside-of-ASN.1-structure-by-using-new-ASN1HEX.getIdxbyListEx">ASN1HEX.getIdxbyListEx tutorial wiki page</a>
 * @see {@link ASN1HEX.getIdxbyListEx}
 *
 * @description
 * This static method is to get a ASN.1 value which specified "nthList" position
 * with checking expected tag "checkingTag".
 * This method can dig into ASN.1 object encapsulated by
 * OctetString or BitString with unused bits.
 *
 * @example
 * 3014 seq idx=0
 *   3012 seq idx=4
 *     020101 int:1 idx=8
 *     020102 int:2 idx=14
 *     800103 [0]:3 idx=20
 *     810104 [1]:4 idx=26
 *     020105 int:5 idx=32
 *     020106 int:6 idx=38
 * h = "30140412020101020102800103810104020105020106";
 * ASN1HEX.getTLVbyList(h, 0, [0, "[0]"]) &rarr; 03
 * ASN1HEX.getTLVbyList(h, 0, [0, 2]) &rarr; 05
 * ASN1HEX.getTLVbyList(h, 0, [0, 2], "0c") &rarr; null //not UTF8String(0c)
 */
ASN1HEX.getVbyListEx = function(h, currentIndex, nthList, checkingTag, removeUnusedbits) {
    var _ASN1HEX = ASN1HEX;
    var idx, tlv, v;
    idx = _ASN1HEX.getIdxbyListEx(h, currentIndex, nthList, checkingTag);
    if (idx == -1) return null;
    v = _ASN1HEX.getV(h, idx);
    if (h.substr(idx, 2) == "03" && removeUnusedbits !== false) v = v.substr(2);
    return v;
};

/**
 * get integer value from ASN.1 V(value) of Integer or BitString<br/>
 * @name getInt
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string
 * @param {Number} idx string index in h to get ASN.1 DER Integer or BitString
 * @param {Object} errorReturn (OPTION) error return value (DEFAULT: -1)
 * @return {Number} ASN.1 DER Integer or BitString value
 * @since jsrsasign 10.1.0 asn1hex 1.2.7
 * @see bitstrtoint
 *
 * @example
 * ASN1HEX.getInt("xxxx020103xxxxxx", 4) &rarr 3 // DER Integer
 * ASN1HEX.getInt("xxxx03020780xxxxxx", 4) &rarr 1 // DER BitStringx
 * ASN1HEX.getInt("xxxx030203c8xxxxxx", 4) &rarr 25 // DER BitStringx
 */
ASN1HEX.getInt = function(h, idx, errorReturn) {
    if (errorReturn == undefined) errorReturn = -1;
    try {
	var hTag = h.substr(idx, 2);
	if (hTag != "02" && hTag != "03") return errorReturn;
	var hV = ASN1HEX.getV(h, idx);
	if (hTag == "02") {
	    return parseInt(hV, 16);
	} else {
	    return bitstrtoint(hV);
	}
    } catch(ex) {
	return errorReturn;
    }
};

/**
 * get object identifier string from ASN.1 V(value)<br/>
 * @name getOID
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string
 * @param {Number} idx string index in h to get ASN.1 DER ObjectIdentifier
 * @param {Object} errorReturn (OPTION) error return value (DEFAULT: null)
 * @return {String} object identifier string (ex. "1.2.3.4")
 * @since jsrsasign 10.1.0 asn1hex 1.2.7
 *
 * @example
 * ASN1HEX.getInt("xxxx06032a0304xxxxxx", 4) &rarr "1.2.3.4"
 */
ASN1HEX.getOID = function(h, idx, errorReturn) {
    if (errorReturn == undefined) errorReturn = null;
    try {
	if (h.substr(idx, 2) != "06") return errorReturn;
	var hOID = ASN1HEX.getV(h, idx);
	return hextooid(hOID);
    } catch(ex) {
	return errorReturn;
    }
};

/**
 * get object identifier name from ASN.1 V(value)<br/>
 * @name getOIDName
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string
 * @param {Number} idx string index in h to get ASN.1 DER ObjectIdentifier
 * @param {Object} errorReturn (OPTION) error return value (DEFAULT: null)
 * @return {String} object identifier name (ex. "sha256") oir OID string
 * @since jsrsasign 10.1.0 asn1hex 1.2.7
 *
 * @description
 * This static method returns object identifier name such as "sha256"
 * if registered. If not registered, it returns OID string. 
 * (ex. "1.2.3.4")
 *
 * @example
 * ASN1HEX.getOIDName("xxxx0609608648016503040201xxxxxx", 4) &rarr "sha256"
 * ASN1HEX.getOIDName("xxxx06032a0304xxxxxx", 4) &rarr "1.2.3.4"
 */
ASN1HEX.getOIDName = function(h, idx, errorReturn) {
    if (errorReturn == undefined) errorReturn = null;
    try {
	var oid = ASN1HEX.getOID(h, idx, errorReturn);
	if (oid == errorReturn) return errorReturn;
	var name = KJUR.asn1.x509.OID.oid2name(oid);
	if (name == '') return oid;
	return name;
    } catch(ex) {
	return errorReturn;
    }
};

/**
 * get raw string from ASN.1 V(value)<br/>
 * @name getString
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string
 * @param {Number} idx string index in h to get any ASN.1 DER String
 * @param {Object} errorReturn (OPTION) error return value (DEFAULT: null)
 * @return {String} raw string
 * @since jsrsasign 10.1.3 asn1hex 1.2.8
 *
 * @description
 * This static method returns a raw string from
 * any ASN.1 DER primitives.
 *
 * @example
 * ASN1HEX.getString("xxxx1303616161xxxxxx", 4) &rarr "aaa"
 * ASN1HEX.getString("xxxx0c03616161xxxxxx", 4) &rarr "aaa"
 */
ASN1HEX.getString = function(h, idx, errorReturn) {
    if (errorReturn == undefined) errorReturn = null;
    try {
	var hV = ASN1HEX.getV(h, idx);
	return hextorstr(hV);
    } catch(ex) {
	return errorReturn;
    }
};

/**
 * get OID string from hexadecimal encoded value<br/>
 * @name hextooidstr
 * @memberOf ASN1HEX
 * @function
 * @param {String} hex hexadecmal string of ASN.1 DER encoded OID value
 * @return {String} OID string (ex. '1.2.3.4.567')
 * @since asn1hex 1.1.5
 * @see {@link KJUR.asn1.ASN1Util.oidIntToHex}
 * @description
 * This static method converts from ASN.1 DER encoded 
 * hexadecimal object identifier value to dot concatinated OID value.
 * {@link KJUR.asn1.ASN1Util.oidIntToHex} is a reverse function of this.
 * @example
 * ASN1HEX.hextooidstr("550406") &rarr; "2.5.4.6"
 */
ASN1HEX.hextooidstr = function(hex) {
    var zeroPadding = function(s, len) {
        if (s.length >= len) return s;
        return new Array(len - s.length + 1).join('0') + s;
    };

    var a = [];

    // a[0], a[1]
    var hex0 = hex.substr(0, 2);
    var i0 = parseInt(hex0, 16);
    a[0] = new String(Math.floor(i0 / 40));
    a[1] = new String(i0 % 40);

    // a[2]..a[n]
   var hex1 = hex.substr(2);
    var b = [];
    for (var i = 0; i < hex1.length / 2; i++) {
    b.push(parseInt(hex1.substr(i * 2, 2), 16));
    }
    var c = [];
    var cbin = "";
    for (var i = 0; i < b.length; i++) {
        if (b[i] & 0x80) {
            cbin = cbin + zeroPadding((b[i] & 0x7f).toString(2), 7);
        } else {
            cbin = cbin + zeroPadding((b[i] & 0x7f).toString(2), 7);
            c.push(new String(parseInt(cbin, 2)));
            cbin = "";
        }
    }

    var s = a.join(".");
    if (c.length > 0) s = s + "." + c.join(".");
    return s;
};

/**
 * get string of simple ASN.1 dump from hexadecimal ASN.1 data<br/>
 * @name dump
 * @memberOf ASN1HEX
 * @function
 * @param {Object} hexOrObj hexadecmal string of ASN.1 data or ASN1Object object
 * @param {Array} flags associative array of flags for dump (OPTION)
 * @param {Number} idx string index for starting dump (OPTION)
 * @param {String} indent indent string (OPTION)
 * @return {String} string of simple ASN.1 dump
 * @since jsrsasign 4.8.3 asn1hex 1.1.6
 * @description
 * This method will get an ASN.1 dump from
 * hexadecmal string of ASN.1 DER encoded data.
 * Here are features:
 * <ul>
 * <li>ommit long hexadecimal string</li>
 * <li>dump encapsulated OCTET STRING (good for X.509v3 extensions)</li>
 * <li>structured/primitive context specific tag support (i.e. [0], [3] ...)</li>
 * <li>automatic decode for implicit primitive context specific tag 
 * (good for X.509v3 extension value)
 *   <ul>
 *   <li>if hex starts '68747470'(i.e. http) it is decoded as utf8 encoded string.</li>
 *   <li>if it is in 'subjectAltName' extension value and is '[2]'(dNSName) tag
 *   value will be encoded as utf8 string</li>
 *   <li>otherwise it shows as hexadecimal string</li>
 *   </ul>
 * </li>
 * </ul>
 * NOTE1: Argument {@link KJUR.asn1.ASN1Object} object is supported since
 * jsrsasign 6.2.4 asn1hex 1.0.8
 * @example
 * // 1) ASN.1 INTEGER
 * ASN1HEX.dump('0203012345')
 * &darr;
 * INTEGER 012345
 *
 * // 2) ASN.1 Object Identifier
 * ASN1HEX.dump('06052b0e03021a')
 * &darr;
 * ObjectIdentifier sha1 (1 3 14 3 2 26)
 *
 * // 3) ASN.1 SEQUENCE
 * ASN1HEX.dump('3006020101020102')
 * &darr;
 * SEQUENCE
 *   INTEGER 01
 *   INTEGER 02
 *
 * // 4) ASN.1 SEQUENCE since jsrsasign 6.2.4
 * o = KJUR.asn1.ASN1Util.newObject({seq: [{int: 1}, {int: 2}]});
 * ASN1HEX.dump(o)
 * &darr;
 * SEQUENCE
 *   INTEGER 01
 *   INTEGER 02
 * // 5) ASN.1 DUMP FOR X.509 CERTIFICATE
 * ASN1HEX.dump(pemtohex(certPEM))
 * &darr;
 * SEQUENCE
 *   SEQUENCE
 *     [0]
 *       INTEGER 02
 *     INTEGER 0c009310d206dbe337553580118ddc87
 *     SEQUENCE
 *       ObjectIdentifier SHA256withRSA (1 2 840 113549 1 1 11)
 *       NULL
 *     SEQUENCE
 *       SET
 *         SEQUENCE
 *           ObjectIdentifier countryName (2 5 4 6)
 *           PrintableString 'US'
 *             :
 */
ASN1HEX.dump = function(hexOrObj, flags, idx, indent) {
    var _ASN1HEX = ASN1HEX;
    var _getV = _ASN1HEX.getV;
    var _dump = _ASN1HEX.dump;
    var _getChildIdx = _ASN1HEX.getChildIdx;

    var hex = hexOrObj;
    if (hexOrObj instanceof KJUR.asn1.ASN1Object)
	hex = hexOrObj.tohex();

    var _skipLongHex = function(hex, limitNumOctet) {
	if (hex.length <= limitNumOctet * 2) {
	    return hex;
	} else {
	    var s = hex.substr(0, limitNumOctet) + 
		    "..(total " + hex.length / 2 + "bytes).." +
		    hex.substr(hex.length - limitNumOctet, limitNumOctet);
	    return s;
	};
    };

    if (flags === undefined) flags = { "ommit_long_octet": 32 };
    if (idx === undefined) idx = 0;
    if (indent === undefined) indent = "";
    var skipLongHex = flags.ommit_long_octet;

    var tag = hex.substr(idx, 2);

    if (tag == "01") {
	var v = _getV(hex, idx);
	if (v == "00") {
	    return indent + "BOOLEAN FALSE\n";
	} else {
	    return indent + "BOOLEAN TRUE\n";
	}
    }
    if (tag == "02") {
	var v = _getV(hex, idx);
        return indent + "INTEGER " + _skipLongHex(v, skipLongHex) + "\n";
    }
    if (tag == "03") {
	var v = _getV(hex, idx);
	if (_ASN1HEX.isASN1HEX(v.substr(2))) {
  	    var s = indent + "BITSTRING, encapsulates\n";
            s = s + _dump(v.substr(2), flags, 0, indent + "  ");
            return s;
	} else {
            return indent + "BITSTRING " + _skipLongHex(v, skipLongHex) + "\n";
	}
    }
    if (tag == "04") {
	var v = _getV(hex, idx);
	if (_ASN1HEX.isASN1HEX(v)) {
	    var s = indent + "OCTETSTRING, encapsulates\n";
	    s = s + _dump(v, flags, 0, indent + "  ");
	    return s;
	} else {
	    return indent + "OCTETSTRING " + _skipLongHex(v, skipLongHex) + "\n";
	}
    }
    if (tag == "05") {
	return indent + "NULL\n";
    }
    if (tag == "06") {
	var hV = _getV(hex, idx);
        var oidDot = KJUR.asn1.ASN1Util.oidHexToInt(hV);
        var oidName = KJUR.asn1.x509.OID.oid2name(oidDot);
	var oidSpc = oidDot.replace(/\./g, ' ');
        if (oidName != '') {
  	    return indent + "ObjectIdentifier " + oidName + " (" + oidSpc + ")\n";
	} else {
  	    return indent + "ObjectIdentifier (" + oidSpc + ")\n";
	}
    }
    if (tag == "0a") {
	return indent + "ENUMERATED " + parseInt(_getV(hex, idx)) + "\n";
    }
    if (tag == "0c") {
	return indent + "UTF8String '" + hextoutf8(_getV(hex, idx)) + "'\n";
    }
    if (tag == "13") {
	return indent + "PrintableString '" + hextoutf8(_getV(hex, idx)) + "'\n";
    }
    if (tag == "14") {
	return indent + "TeletexString '" + hextoutf8(_getV(hex, idx)) + "'\n";
    }
    if (tag == "16") {
	return indent + "IA5String '" + hextoutf8(_getV(hex, idx)) + "'\n";
    }
    if (tag == "17") {
	return indent + "UTCTime " + hextoutf8(_getV(hex, idx)) + "\n";
    }
    if (tag == "18") {
	return indent + "GeneralizedTime " + hextoutf8(_getV(hex, idx)) + "\n";
    }
    if (tag == "1a") {
	return indent + "VisualString '" + hextoutf8(_getV(hex, idx)) + "'\n";
    }
    if (tag == "1e") {
	return indent + "BMPString '" + ucs2hextoutf8(_getV(hex, idx)) + "'\n";
    }
    if (tag == "30") {
	if (hex.substr(idx, 4) == "3000") {
	    return indent + "SEQUENCE {}\n";
	}

	var s = indent + "SEQUENCE\n";
	var aIdx = _getChildIdx(hex, idx);

	var flagsTemp = flags;
	
	if ((aIdx.length == 2 || aIdx.length == 3) &&
	    hex.substr(aIdx[0], 2) == "06" &&
	    hex.substr(aIdx[aIdx.length - 1], 2) == "04") { // supposed X.509v3 extension
	    var oidName = _ASN1HEX.oidname(_getV(hex, aIdx[0]));
	    var flagsClone = JSON.parse(JSON.stringify(flags));
	    flagsClone.x509ExtName = oidName;
	    flagsTemp = flagsClone;
	}
	
	for (var i = 0; i < aIdx.length; i++) {
	    s = s + _dump(hex, flagsTemp, aIdx[i], indent + "  ");
	}
	return s;
    }
    if (tag == "31") {
	var s = indent + "SET\n";
	var aIdx = _getChildIdx(hex, idx);
	for (var i = 0; i < aIdx.length; i++) {
	    s = s + _dump(hex, flags, aIdx[i], indent + "  ");
	}
	return s;
    }
    var tag = parseInt(tag, 16);
    if ((tag & 128) != 0) { // context specific 
	var tagNumber = tag & 31;
	if ((tag & 32) != 0) { // structured tag
	    var s = indent + "[" + tagNumber + "]\n";
	    var aIdx = _getChildIdx(hex, idx);
	    for (var i = 0; i < aIdx.length; i++) {
		s = s + _dump(hex, flags, aIdx[i], indent + "  ");
	    }
	    return s;
	} else { // primitive tag
	    var v = _getV(hex, idx);
	    if (ASN1HEX.isASN1HEX(v)) {
		var s = indent + "[" + tagNumber + "]\n";
		s = s + _dump(v, flags, 0, indent + "  ");
		return s;
	    } else if (v.substr(0, 8) == "68747470") { // http
		v = hextoutf8(v);
	    } else if (flags.x509ExtName === "subjectAltName" &&
		       tagNumber == 2) {
		v = hextoutf8(v);
	    }
	    // else if (ASN1HEX.isASN1HEX(v))

	    var s = indent + "[" + tagNumber + "] " + v + "\n";
	    return s;
	}
    }
    return indent + "UNKNOWN(" + tag + ") " + 
	   _getV(hex, idx) + "\n";
};

/**
 * parse ASN.1 DER hexadecimal string<br/>
 * @name parse
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN1. DER
 * @return {Object} associative array of ASN.1 parsed result
 * @since jsrsasign 10.5.3 asn1hex 1.1.x
 * @see KJUR.asn1.ASN1Util.newOjbect
 *
 * @description
 * This method parses ASN.1 DER hexadecimal string.
 * Its result can be applied to {@link KJUR.asn1.ASN1Util.newOjbect}.
 *
 * @example
 * ASN1HEX.parse("31193017...") &rarr; // RDN
 * {set: [{seq: [{oid: "localityName"}, {utf8str: {str: "Test"}}] }]}
 */
ASN1HEX.parse = function(h) {
    var _ASN1HEX = ASN1HEX,
	_parse = _ASN1HEX.parse,
	_isASN1HEX = _ASN1HEX.isASN1HEX,
	_getV = _ASN1HEX.getV,
	_getTLV = _ASN1HEX.getTLV,
	_getChildIdx = _ASN1HEX.getChildIdx,
	_KJUR_asn1 = KJUR.asn1,
	_oidHexToInt = _KJUR_asn1.ASN1Util.oidHexToInt,
	_oid2name = _KJUR_asn1.x509.OID.oid2name,
	_hextoutf8 = hextoutf8,
	_ucs2hextoutf8 = ucs2hextoutf8,
	_iso88591hextoutf8 = iso88591hextoutf8;

    var tagName = {
	"0c": "utf8str", "12": "numstr", "13": "prnstr", 
	"14": "telstr", "16": "ia5str", "17": "utctime", 
	"18": "gentime", "1a": "visstr", "1e": "bmpstr", 
	"30": "seq", "31": "set"
    };

    var _parseChild = function(h) {
	var result = [];
	var aIdx = _getChildIdx(h, 0);
	for (var i = 0; i < aIdx.length; i++) {
	    var idx = aIdx[i];
	    var hTLV = _getTLV(h, idx);
	    var pItem = _parse(hTLV);
	    result.push(pItem);
	}
	return result;
    };

    var tag = h.substr(0, 2);
    var result = {};
    var hV = _getV(h, 0);
    if (tag == "01") {
	if (h == "0101ff") return {bool: true};
	return {bool: false};
    } else if (tag == "02") {
	return {"int": {hex: hV}};
    } else if (tag == "03") {
	try {
	    if (hV.substr(0, 2) != "00") throw "not encap";
	    var hV1 = hV.substr(2);
	    if (! _isASN1HEX(hV1)) throw "not encap";
	    return {bitstr: {obj: _parse(hV1)}};
	} catch(ex) {
	    var bV = null;
	    if (hV.length <= 10) bV = bitstrtobinstr(hV);
	    if (bV == null) {
		return {bitstr: {hex: hV}};
	    } else {
		return {bitstr: {bin: bV}};
	    }
	}
    } else if (tag == "04") {
	try {
	    if (! _isASN1HEX(hV)) throw "not encap";
	    return {octstr: {obj: _parse(hV)}};
	} catch(ex) {
	    return {octstr: {hex: hV}};
	}
    } else if (tag == "05") {
	return {"null": ''};
    } else if (tag == "06") {
	var oidDot = _oidHexToInt(hV);
	var oidName = _oid2name(oidDot);
	if (oidName == "") {
	    return {oid: oidDot};
	} else {
	    return {oid: oidName};
	}
    } else if (tag == "0a") {
	if (hV.length > 4) {
	    return {"enum": {hex: hV}};
	} else {
	    return {"enum": parseInt(hV, 16)};
	}
    } else if (tag == "30" || tag == "31") {
	result[tagName[tag]] = _parseChild(h);
	return result;
    } else if (tag == "14") { // TeletexString
	var s = _iso88591hextoutf8(hV);
	result[tagName[tag]] = {str: s};
	return result;
    } else if (tag == "1e") { // BMPString
	var s = _ucs2hextoutf8(hV);
	result[tagName[tag]] = {str: s};
	return result;
    } else if (":0c:12:13:16:17:18:1a:".indexOf(tag) != -1) { // Other Strings types
	var s = _hextoutf8(hV);
	result[tagName[tag]] = {str: s};
	return result;
    } else if (tag.match(/^8[0-9]$/)) {
	var s = _hextoutf8(hV);
	if (s == null | s == "") {
	    return {"tag": {"tag": tag, explicit: false, hex: hV}};
	} else if (s.match(/[\x00-\x1F\x7F-\x9F]/) != null ||
		   s.match(/[\u0000-\u001F\u0080\u009F]/) != null) {
	    return {"tag": {"tag": tag, explicit: false, hex: hV}};
	} else {
	    return {"tag": {"tag": tag, explicit: false, str: s}};
	}
    } else if (tag.match(/^a[0-9]$/)) {
	try {
	    if (! _isASN1HEX(hV)) throw new Error("not encap");
	    return {"tag": {"tag": tag, 
			    explicit: true,
			    obj: _parse(hV)}};
	} catch(ex) {
	    return {"tag": {"tag": tag, explicit: true, hex: hV}};
	}
    } else {
	var d = new KJUR.asn1.ASN1Object();
	d.hV = hV;
	var hL = d.getLengthHexFromValue();
	return {"asn1": {"tlv": tag + hL + hV}};
    }
};

/**
 * check if a hexadecimal tag is a specified ASN.1 context specific tag
 * @name isContextTag
 * @memberOf ASN1HEX
 * @function
 * @param {hTag} hex string of a hexadecimal ASN.1 tag consists by two characters (e.x. "a0")
 * @param {sTag} context specific tag in string represention (OPTION) (e.x. "[0]")
 * @return {Boolean} true if hTag is a ASN.1 context specific tag specified by sTag value.
 * @since jsrsasign 8.0.21 asn1hex 1.2.2
 * @description
 * This method checks if a hexadecimal tag is a specified ASN.1 context specific tag.
 * Structured and non-structured type of tag have the same string representation
 * of context specific tag. For example tag "a0" and "80" have the same string
 * representation "[0]".
 * The sTag has a range from from "[0]" to "[31]".
 * @example
 * ASN1HEX.isContextTag('a0', '[0]') &rarr; true // structured
 * ASN1HEX.isContextTag('a1', '[1]') &rarr; true // structured
 * ASN1HEX.isContextTag('a2', '[2]') &rarr; true // structured
 * ASN1HEX.isContextTag('80', '[0]') &rarr; true // non structured
 * ASN1HEX.isContextTag('81', '[1]') &rarr; true // non structured
 * ASN1HEX.isContextTag('82', '[2]') &rarr; true // non structured
 * ASN1HEX.isContextTag('a0', '[3]') &rarr; false
 * ASN1HEX.isContextTag('80', '[15]') &rarr; false
 *
 * ASN.1 tag bits
 * 12345679
 * ++        tag class(universal:00, context specific:10)
 *   +       structured:1, primitive:0
 *    +++++  tag number (0 - 31)
 */
ASN1HEX.isContextTag = function(hTag, sTag) {
    hTag = hTag.toLowerCase();
    var ihtag, istag;

    try {
	ihtag = parseInt(hTag, 16);
    } catch (ex) {
	return -1;
    }
	
    if (sTag === undefined) {
	if ((ihtag & 192) == 128) {
	    return true;
	} else {
	    return false;
	}
    }

    try {
	var result = sTag.match(/^\[[0-9]+\]$/);
	if (result == null) return false;
	istag = parseInt(sTag.substr(1,sTag.length - 1), 10);
	if (istag > 31) return false;
	if (((ihtag & 192) == 128) &&   // ihtag & b11000000 == b10000000
	    ((ihtag & 31) == istag)) {  // ihtag & b00011111 == istag (0-31)
	    return true;
	}
	return false;
    } catch (ex) {
	return false;
    }
};

/**
 * simple ASN.1 DER hexadecimal string checker<br/>
 * @name isASN1HEX
 * @memberOf ASN1HEX
 * @function
 * @param {String} hex string to check whether it is hexadecmal string for ASN.1 DER or not
 * @return {Boolean} true if it is hexadecimal string of ASN.1 data otherwise false
 * @since jsrsasign 4.8.3 asn1hex 1.1.6
 * @description
 * This method checks wheather the argument 'hex' is a hexadecimal string of
 * ASN.1 data or not.
 * @example
 * ASN1HEX.isASN1HEX('0203012345') &rarr; true // PROPER ASN.1 INTEGER
 * ASN1HEX.isASN1HEX('0203012345ff') &rarr; false // TOO LONG VALUE
 * ASN1HEX.isASN1HEX('02030123') &rarr; false // TOO SHORT VALUE
 * ASN1HEX.isASN1HEX('fa3bcd') &rarr; false // WRONG FOR ASN.1
 */
ASN1HEX.isASN1HEX = function(hex) {
    var _ASN1HEX = ASN1HEX;
    if (hex.length % 2 == 1) return false;

    var intL = _ASN1HEX.getVblen(hex, 0);
    var hT = hex.substr(0, 2);
    var hL = _ASN1HEX.getL(hex, 0);
    var hVLength = hex.length - hT.length - hL.length;
    if (hVLength == intL * 2) return true;

    return false;
};

/**
 * strict ASN.1 DER hexadecimal string checker
 * @name checkStrictDER
 * @memberOf ASN1HEX
 * @function
 * @param {String} hex string to check whether it is hexadecmal string for ASN.1 DER or not
 * @return unspecified
 * @since jsrsasign 8.0.19 asn1hex 1.2.1
 * @throws Error when malformed ASN.1 DER hexadecimal string
 * @description
 * This method checks wheather the argument 'hex' is a hexadecimal string of
 * ASN.1 data or not. If the argument is not DER string, this 
 * raise an exception.
 * @example
 * ASN1HEX.checkStrictDER('0203012345') &rarr; NO EXCEPTION FOR PROPER ASN.1 INTEGER
 * ASN1HEX.checkStrictDER('0203012345ff') &rarr; RAISE EXCEPTION FOR TOO LONG VALUE
 * ASN1HEX.checkStrictDER('02030123') &rarr; false RAISE EXCEPITON FOR TOO SHORT VALUE
 * ASN1HEX.checkStrictDER('fa3bcd') &rarr; false RAISE EXCEPTION FOR WRONG ASN.1
 */
ASN1HEX.checkStrictDER = function(h, idx, maxHexLen, maxByteLen, maxLbyteLen) {
    var _ASN1HEX = ASN1HEX;

    if (maxHexLen === undefined) {
	// 1. hex string check
	if (typeof h != "string") throw new Error("not hex string");
	h = h.toLowerCase();
	if (! KJUR.lang.String.isHex(h)) throw new Error("not hex string");

	// 2. set max if needed
	// max length of hexadecimal string
	maxHexLen = h.length;
	// max length of octets
	maxByteLen = h.length / 2;
	// max length of L octets of TLV
	if (maxByteLen < 0x80) {
	    maxLbyteLen = 1;
	} else {
	    maxLbyteLen = Math.ceil(maxByteLen.toString(16)) + 1;
	}
    }
    //console.log(maxHexLen + ":" + maxByteLen + ":" + maxLbyteLen);

    // 3. check if L(length) string not exceeds maxLbyteLen
    var hL = _ASN1HEX.getL(h, idx);
    if (hL.length > maxLbyteLen * 2)
	throw new Error("L of TLV too long: idx=" + idx);

    // 4. check if V(value) octet length (i.e. L(length) value) 
    //    not exceeds maxByteLen
    var vblen = _ASN1HEX.getVblen(h, idx);
    if (vblen > maxByteLen) 
	throw new Error("value of L too long than hex: idx=" + idx);

    // 5. check V string length and L's value are the same
    var hTLV = _ASN1HEX.getTLV(h, idx);
    var hVLength = 
	hTLV.length - 2 - _ASN1HEX.getL(h, idx).length;
    if (hVLength !== (vblen * 2))
	throw new Error("V string length and L's value not the same:" +
		        hVLength + "/" + (vblen * 2));

    // 6. check appending garbled string
    if (idx === 0) {
	if (h.length != hTLV.length)
	    throw new Error("total length and TLV length unmatch:" +
			    h.length + "!=" + hTLV.length);
    }

    // 7. check if there isn't prepending zeros in DER INTEGER value
    var hT = h.substr(idx, 2);
    if (hT === '02') {
	var vidx = _ASN1HEX.getVidx(h, idx);
	// check if DER INTEGER VALUE have least leading zeros 
	// for two's complement
	// GOOD - 3fabde... 008fad...
	// BAD  - 000012... 007fad...
	if (h.substr(vidx, 2) == "00" && h.charCodeAt(vidx + 2) < 56) // '8'=56
	    throw new Error("not least zeros for DER INTEGER");
    }

    // 8. check if all of elements in a structured item are conformed to
    //    strict DER encoding rules.
    if (parseInt(hT, 16) & 32) { // structured tag?
	var intL = _ASN1HEX.getVblen(h, idx);
	var sum = 0;
	var aIdx = _ASN1HEX.getChildIdx(h, idx);
	for (var i = 0; i < aIdx.length; i++) {
	    var tlv = _ASN1HEX.getTLV(h, aIdx[i]);
	    sum += tlv.length;
	    _ASN1HEX.checkStrictDER(h, aIdx[i], 
				   maxHexLen, maxByteLen, maxLbyteLen);
	}
	if ((intL * 2) != sum)
	    throw new Error("sum of children's TLV length and L unmatch: " +
			    (intL * 2) + "!=" + sum);
    }
};

/**
 * get hexacedimal string from PEM format data<br/>
 * @name oidname
 * @memberOf ASN1HEX
 * @function
 * @param {String} oidDotOrHex number dot notation(i.e. 1.2.3) or hexadecimal string for OID
 * @return {String} name for OID
 * @since jsrsasign 7.2.0 asn1hex 1.1.11
 * @description
 * This static method gets a OID name for
 * a specified string of number dot notation (i.e. 1.2.3) or
 * hexadecimal string.
 * @example
 * ASN1HEX.oidname("2.5.29.37") &rarr; extKeyUsage
 * ASN1HEX.oidname("551d25") &rarr; extKeyUsage
 * ASN1HEX.oidname("0.1.2.3") &rarr; 0.1.2.3 // unknown
 */
ASN1HEX.oidname = function(oidDotOrHex) {
    var _KJUR_asn1 = KJUR.asn1;
    if (KJUR.lang.String.isHex(oidDotOrHex))
	oidDotOrHex = _KJUR_asn1.ASN1Util.oidHexToInt(oidDotOrHex);
    var name = _KJUR_asn1.x509.OID.oid2name(oidDotOrHex);
    if (name === "") name = oidDotOrHex;
    return name;
};


/* asn1x509-2.1.20.js (c) 2013-2022 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * asn1x509.js - ASN.1 DER encoder classes for X.509 certificate
 *
 * Copyright (c) 2013-2023 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name asn1x509-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.8.4 asn1x509 2.1.20 (2023-Apr-26)
 * @since jsrsasign 2.1
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * kjur's class library name space
 * // already documented in asn1-1.0.js
 * @name KJUR
 * @namespace kjur's class library name space
 */
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};

/**
 * kjur's ASN.1 class library name space
 * // already documented in asn1-1.0.js
 * @name KJUR.asn1
 * @namespace
 */
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};

/**
 * kjur's ASN.1 class for X.509 certificate library name space
 * <p>
 * <h4>FEATURES</h4>
 * <ul>
 * <li>easily issue any kind of certificate</li>
 * <li>APIs are very similar to BouncyCastle library ASN.1 classes. So easy to learn.</li>
 * </ul>
 * </p>
 * <h4>PROVIDED CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.x509.Certificate}</li>
 * <li>{@link KJUR.asn1.x509.TBSCertificate}</li>
 * <li>{@link KJUR.asn1.x509.Extension} abstract class</li>
 * <li>{@link KJUR.asn1.x509.Extensions}</li>
 * <li>{@link KJUR.asn1.x509.SubjectPublicKeyInfo}</li>
 * <li>{@link KJUR.asn1.x509.AlgorithmIdentifier}</li>
 * <li>{@link KJUR.asn1.x509.GeneralNames}</li>
 * <li>{@link KJUR.asn1.x509.GeneralName}</li>
 * <li>{@link KJUR.asn1.x509.X500Name}</li>
 * <li>{@link KJUR.asn1.x509.RDN}</li>
 * <li>{@link KJUR.asn1.x509.AttributeTypeAndValue}</li>
 * <li>{@link KJUR.asn1.x509.DistributionPointName}</li>
 * <li>{@link KJUR.asn1.x509.DistributionPoint}</li>
 * <li>{@link KJUR.asn1.x509.PolicyInformation}</li>
 * <li>{@link KJUR.asn1.x509.PolicyQualifierInfo}</li>
 * <li>{@link KJUR.asn1.x509.UserNotice}</li>
 * <li>{@link KJUR.asn1.x509.NoticeReference}</li>
 * <li>{@link KJUR.asn1.x509.DisplayText}</li>
 * <li>{@link KJUR.asn1.x509.GeneralSubtree}</li>
 * <li>{@link KJUR.asn1.x509.CRL}</li>
 * <li>{@link KJUR.asn1.x509.TBSCertList}</li>
 * <li>{@link KJUR.asn1.x509.CRLEntry} (DEPRECATED)</li>
 * <li>{@link KJUR.asn1.x509.OID}</li>
 * </ul>
 * <h4>SUPPORTED EXTENSIONS</h4>
 * <ul>
 * <li>{@link KJUR.asn1.x509.AuthorityKeyIdentifier}</li>
 * <li>{@link KJUR.asn1.x509.SubjectKeyIdentifier}</li>
 * <li>{@link KJUR.asn1.x509.KeyUsage}</li>
 * <li>{@link KJUR.asn1.x509.CertificatePolicies}</li>
 * <li>{@link KJUR.asn1.x509.PolicyMappings} 2.5.29.33</li>
 * <li>{@link KJUR.asn1.x509.PolicyConstraints} 2.5.29.36</li>
 * <li>{@link KJUR.asn1.x509.InhibitAnyPolicy} 2.5.29.54</li>
 * <li>{@link KJUR.asn1.x509.SubjectAltName}</li>
 * <li>{@link KJUR.asn1.x509.IssuerAltName}</li>
 * <li>{@link KJUR.asn1.x509.BasicConstraints}</li>
 * <li>{@link KJUR.asn1.x509.NameConstraints}</li>
 * <li>{@link KJUR.asn1.x509.ExtKeyUsage}</li>
 * <li>{@link KJUR.asn1.x509.CRLDistributionPoints}</li>
 * <li>{@link KJUR.asn1.x509.AuthorityInfoAccess}</li>
 * <li>{@link KJUR.asn1.x509.CRLNumber}</li>
 * <li>{@link KJUR.asn1.x509.CRLReason}</li>
 * <li>{@link KJUR.asn1.x509.OCSPNonce}</li>
 * <li>{@link KJUR.asn1.x509.OCSPNoCheck}</li>
 * <li>{@link KJUR.asn1.x509.AdobeTimeStamp}</li>
 * <li>{@link KJUR.asn1.x509.SubjectDirectoryAttributes}</li>
 * <li>{@link KJUR.asn1.x509.PrivateExtension}</li>
 * </ul>
 * NOTE1: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.<br/>
 * NOTE2: SubjectAltName and IssuerAltName supported since 
 * jsrsasign 6.2.3 asn1x509 1.0.19.<br/>
 * NOTE3: CeritifcatePolicies supported supported since
 * jsrsasign 8.0.23 asn1x509 1.1.12<br/>
 * @name KJUR.asn1.x509
 * @namespace
 */
if (typeof KJUR.asn1.x509 == "undefined" || !KJUR.asn1.x509) KJUR.asn1.x509 = {};

// === BEGIN Certificate ===================================================

/**
 * X.509 Certificate class to sign and generate hex encoded certificate
 * @name KJUR.asn1.x509.Certificate
 * @class X.509 Certificate class to sign and generate hex encoded certificate
 * @property {Array} params JSON object of parameters
 * @param {Array} params JSON object for Certificate parameters
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * This class provides Certificate ASN.1 class structure
 * defined in 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.1">
 * RFC 5280 4.1</a>.
 * <pre>
 * Certificate  ::=  SEQUENCE  {
 *      tbsCertificate       TBSCertificate,
 *      signatureAlgorithm   AlgorithmIdentifier,
 *      signatureValue       BIT STRING  }
 * </pre>
 * Parameter "params" JSON object can be
 * the same as {@link KJUR.asn1.x509.TBSCertificate}. 
 * Then they are used to generate TBSCertificate.
 * Additionally just for Certificate, following parameters can be used:
 * <ul>
 * <li>{TBSCertfificate}tbsobj - 
 * specifies {@link KJUR.asn1.x509.TBSCertificate} 
 * object to be signed if needed. 
 * When this isn't specified, 
 * this will be set from other parametes of TBSCertificate.</li>
 * <li>{Object}cakey (OPTION) - specifies certificate signing private key.
 * Parameter "cakey" or "sighex" shall be specified. Following
 * values can be specified:
 *   <ul>
 *   <li>PKCS#1/5 or PKCS#8 PEM string of private key</li>
 *   <li>RSAKey/DSA/ECDSA key object. {@link KEYUTIL.getKey} is useful
 *   to generate a key object.</li>
 *   </ul>
 * </li>
 * <li>{String}sighex (OPTION) - hexadecimal string of signature value
 * (i.e. ASN.1 value(V) of signatureValue BIT STRING without
 * unused bits)</li>
 * </ul>
 * CAUTION: APIs of this class have been totally updated without
 * backward compatibility since jsrsasign 9.0.0.<br/>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: DSA/ECDSA is also supported for CA signging key from asn1x509 1.0.6.
 * @example
 * var cert = new KJUR.asn1.x509.Certificate({
 *  version: 3,
 *  serial: {hex: "1234..."},
 *  sigalg: "SHA256withRSAandMGF1",
 *  ...
 *  sighex: "1d3f..." // sign() method won't be called
 * });
 *
 * // sighex will by calculated by signing with cakey
 * var cert = new KJUR.asn1.x509.Certificate({
 *  version: 3,
 *  serial: {hex: "2345..."},
 *  sigalg: "SHA256withRSA",
 *  ...
 *  cakey: "-----BEGIN PRIVATE KEY..."
 * });
 *
 * // use TBSCertificate object to sign
 * var cert = new KJUR.asn1.x509.Certificate({
 *  tbsobj: <<OBJ>>,
 *  sigalg: "SHA256withRSA",
 *  cakey: "-----BEGIN PRIVATE KEY..."
 * });
 */
KJUR.asn1.x509.Certificate = function(params) {
    KJUR.asn1.x509.Certificate.superclass.constructor.call(this);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERBitString = _KJUR_asn1.DERBitString,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_TBSCertificate = _KJUR_asn1_x509.TBSCertificate,
	_AlgorithmIdentifier = _KJUR_asn1_x509.AlgorithmIdentifier;

    this.params = undefined;

    /**
     * set parameter<br/>
     * @name setByParam
     * @memberOf KJUR.asn1.x509.Certificate#
     * @function
     * @param params {Array} JSON object of certificate parameters
     * @since jsrsasign 9.0.0 asn1hex 2.0.0
     * @description
     * This method will set parameter 
     * {@link KJUR.asn1.x509.Certificate#params}
     * to this object.
     * @example
     * cert = new KJUR.asn1.x509.Certificate();
     * cert.setByParam({
     *   version: 3,
     *   serial: {hex: "1234..."},
     *   ...
     * });
     */
    this.setByParam = function(params) {
	this.params = params;
    };

    /**
     * sign certificate<br/>
     * @name sign
     * @memberOf KJUR.asn1.x509.Certificate#
     * @function
     * @description
     * This method signs TBSCertificate with a specified 
     * private key and algorithm by 
     * this.params.cakey and this.params.sigalg parameter.
     * @example
     * cert = new KJUR.asn1.x509.Certificate({...});
     * cert.sign()
     */
    this.sign = function() {
	var params = this.params;

	var sigalg = params.sigalg;
	if (params.sigalg.name != undefined) 
	    sigalg = params.sigalg.name;

	var hTBS = params.tbsobj.tohex();
	var sig = new KJUR.crypto.Signature({alg: sigalg});
	sig.init(params.cakey);
	sig.updateHex(hTBS);
	params.sighex = sig.sign();
    };

    /**
     * get PEM formatted certificate string after signed
     * @name getPEM
     * @memberOf KJUR.asn1.x509.Certificate#
     * @function
     * @return PEM formatted string of certificate
     * @since jsrsasign 9.0.0 asn1hex 2.0.0
     * @description
     * This method returns a string of PEM formatted 
     * certificate.
     * @example
     * cert = new KJUR.asn1.x509.Certificate({...});
     * cert.getPEM() &rarr;
     * "-----BEGIN CERTIFICATE-----\r\n..."
     */
    this.getPEM = function() {
	return hextopem(this.tohex(), "CERTIFICATE");
    };

    this.tohex = function() {
	var params = this.params;
	
	if (params.tbsobj == undefined || params.tbsobj == null) {
	    params.tbsobj = new _TBSCertificate(params);
	}

	if (params.sighex == undefined && params.cakey != undefined) {
	    this.sign();
	}

	if (params.sighex == undefined) {
	    throw new Error("sighex or cakey parameter not defined");
	}

	var a = [];
	a.push(params.tbsobj);
	a.push(new _AlgorithmIdentifier({name: params.sigalg}));
	a.push(new _DERBitString({hex: "00" + params.sighex}));
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.params = params;
};
extendClass(KJUR.asn1.x509.Certificate, KJUR.asn1.ASN1Object);

/**
 * ASN.1 TBSCertificate structure class<br/>
 * @name KJUR.asn1.x509.TBSCertificate
 * @class ASN.1 TBSCertificate structure class
 * @property {Array} params JSON object of parameters
 * @param {Array} params JSON object of TBSCertificate parameters
 * @extends KJUR.asn1.ASN1Object
 * @see KJUR.asn1.x509.Certificate
 *
 * @description
 * <br/>
 * NOTE: TBSCertificate class is updated without backward 
 * compatibility from jsrsasign 9.0.0 asn1x509 2.0.0.
 * Most of methods are removed and parameters can be set
 * by JSON object.
 *
 * @example
 * new TBSCertificate({
 *  version: 3, // this can be omitted, the default is 3.
 *  serial: {hex: "1234..."}, // DERInteger parameter
 *  sigalg: "SHA256withRSA",
 *  issuer: {array:[[{type:'O',value:'Test',ds:'prn'}]]}, // X500Name parameter
 *  notbefore: "151231235959Z", // string, passed to Time
 *  notafter: "251231235959Z", // string, passed to Time
 *  subject: {array:[[{type:'O',value:'Test',ds:'prn'}]]}, // X500Name parameter
 *  sbjpubkey: "-----BEGIN...", // KEYUTIL.getKey pubkey parameter
 *  // As for extension parameters, please see extension class
 *  // All extension parameters need to have "extname" parameter additionaly.
 *  ext:[{ 
 *   extname:"keyUsage",critical:true,
 *   names:["digitalSignature","keyEncipherment"]
 *  },{
 *   extname:"cRLDistributionPoints",
 *   array:[{dpname:{full:[{uri:"http://example.com/a1.crl"}]}}]
 *  }, ...]
 * })
 *
 * var tbsc = new TBSCertificate();
 * tbsc.setByParam({version:3,serial:{hex:'1234...'},...});
 */
KJUR.asn1.x509.TBSCertificate = function(params) {
    KJUR.asn1.x509.TBSCertificate.superclass.constructor.call(this);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERSequence = _KJUR_asn1.DERSequence,
	_AlgorithmIdentifier = _KJUR_asn1_x509.AlgorithmIdentifier,
	_Time = _KJUR_asn1_x509.Time,
	_X500Name = _KJUR_asn1_x509.X500Name,
	_Extensions = _KJUR_asn1_x509.Extensions,
	_SubjectPublicKeyInfo = _KJUR_asn1_x509.SubjectPublicKeyInfo;

    this.params = null;

    /**
     * get array of ASN.1 object for extensions<br/>
     * @name setByParam
     * @memberOf KJUR.asn1.x509.TBSCertificate#
     * @function
     * @param {Array} JSON object of TBSCertificate parameters
     * @example
     * tbsc = new KJUR.asn1.x509.TBSCertificate();
     * tbsc.setByParam({version:3, serial:{hex:'1234...'},...});
     */
    this.setByParam = function(params) {
	this.params = params;
    };

    this.tohex = function() {
	var a = [];
	var params = this.params;

	// X.509v3 default if params.version not defined
	if (params.version != undefined || params.version != 1) {
	    var version = 2; 
	    if (params.version != undefined) version = params.version - 1;
	    var obj = 
		new _DERTaggedObject({obj: new _DERInteger({'int': version})}) 
	    a.push(obj);
	}

	a.push(new _DERInteger(params.serial));
	a.push(new _AlgorithmIdentifier({name: params.sigalg}));
	a.push(new _X500Name(params.issuer));
	a.push(new _DERSequence({array:[new _Time(params.notbefore),
					new _Time(params.notafter)]}));
	a.push(new _X500Name(params.subject));
	a.push(new _SubjectPublicKeyInfo(KEYUTIL.getKey(params.sbjpubkey)));
	if (params.ext !== undefined && params.ext.length > 0) {
	    a.push(new _DERTaggedObject({tag: "a3",
					 obj: new _Extensions(params.ext)}));
	}

	var seq = new KJUR.asn1.DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.x509.TBSCertificate, KJUR.asn1.ASN1Object);

/**
 * Extensions ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.Extensions
 * @class Extensions ASN.1 structure class
 * @param {Array} aParam array of JSON extension parameter
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 9.1.0 asn1x509 2.1.0
 * @see KJUR.asn1.x509.TBSCertificate
 * @see KJUR.asn1.x509.TBSCertList
 * @see KJUR.asn1.csr.CertificationRequestInfo
 * @see KJUR.asn1.x509.PrivateExtension
 * @see KJUR.asn1.ocsp.ResponseData
 * @see KJUR.asn1.ocsp.BasicOCSPResponse 
 *
 * @description
 * This class represents
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.1">
 * Extensions defined in RFC 5280 4.1</a> and
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.9">
 * 4.1.2.9</a>.
 * <pre>
 * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension
 * </pre>
 * <p>NOTE: From jsrsasign 9.1.1, private extension or
 * undefined extension have been supported by
 * {@link KJUR.asn1.x509.PrivateExtension}.</p>
 * 
 * Here is a list of available extensions:
 * <ul>
 * <li>{@link KJUR.asn1.x509.BasicConstraints}</li>
 * <li>{@link KJUR.asn1.x509.KeyUsage}</li>
 * <li>{@link KJUR.asn1.x509.SubjectKeyIdentifier}</li>
 * <li>{@link KJUR.asn1.x509.AuthorityKeyIdentifier}</li>
 * <li>{@link KJUR.asn1.x509.SubjectAltName}</li>
 * <li>{@link KJUR.asn1.x509.IssuerAltName}</li>
 * <li>{@link KJUR.asn1.x509.CRLDistributionPoints}</li>
 * <li>{@link KJUR.asn1.x509.CertificatePolicies}</li>
 * <li>{@link KJUR.asn1.x509.CRLNumber}</li>
 * <li>{@link KJUR.asn1.x509.CRLReason}</li>
 * <li>{@link KJUR.asn1.x509.OCSPNonce}</li>
 * <li>{@link KJUR.asn1.x509.OCSPNoCheck}</li>
 * <li>{@link KJUR.asn1.x509.AdobeTimeStamp}</li>
 * <li>{@link KJUR.asn1.x509.SubjectDirectoryAttributes}</li>
 * <li>{@link KJUR.asn1.x509.PrivateExtension}</li>
 * </ul>
 * You can also use {@link KJUR.asn1.x509.PrivateExtension} object
 * to specify a unsupported extension.
 *
 * @example
 * o = new KJUR.asn1.x509.Extensions([
 *   {extname:"keyUsage",critical:true,names:["digitalSignature"]},
 *   {extname:"subjectAltName",array:[{dns:"example.com"}]},
 *   {extname:"1.2.3.4",extn:{prnstr:"aa"}} // private extension
 * ]);
 * o.tohex() &rarr; "30..."
 */
KJUR.asn1.x509.Extensions = function(aParam) {
    KJUR.asn1.x509.Extensions.superclass.constructor.call(this);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_x509 = _KJUR_asn1.x509;
    this.aParam = [];

    this.setByParam = function(aParam) { this.aParam = aParam; }

    this.tohex = function() {
	var a = [];
	for (var i = 0; i < this.aParam.length; i++) {
	    var param = this.aParam[i];
	    var extname = param.extname;
	    var obj = null;

	    if (param.extn != undefined) {
		obj = new _KJUR_asn1_x509.PrivateExtension(param);
	    } else if (extname == "subjectKeyIdentifier") {
		obj = new _KJUR_asn1_x509.SubjectKeyIdentifier(param);
	    } else if (extname == "keyUsage") {
		obj = new _KJUR_asn1_x509.KeyUsage(param);
	    } else if (extname == "subjectAltName") {
		obj = new _KJUR_asn1_x509.SubjectAltName(param);
	    } else if (extname == "issuerAltName") {
		obj = new _KJUR_asn1_x509.IssuerAltName(param);
	    } else if (extname == "basicConstraints") {
		obj = new _KJUR_asn1_x509.BasicConstraints(param);
	    } else if (extname == "nameConstraints") {
		obj = new _KJUR_asn1_x509.NameConstraints(param);
	    } else if (extname == "cRLDistributionPoints") {
		obj = new _KJUR_asn1_x509.CRLDistributionPoints(param);
	    } else if (extname == "certificatePolicies") {
		obj = new _KJUR_asn1_x509.CertificatePolicies(param);
	    } else if (extname == "policyMappings") {
		obj = new _KJUR_asn1_x509.PolicyMappings(param);
	    } else if (extname == "policyConstraints") {
		obj = new _KJUR_asn1_x509.PolicyConstraints(param);
	    } else if (extname == "inhibitAnyPolicy") {
		obj = new _KJUR_asn1_x509.InhibitAnyPolicy(param);
	    } else if (extname == "authorityKeyIdentifier") {
		obj = new _KJUR_asn1_x509.AuthorityKeyIdentifier(param);
	    } else if (extname == "extKeyUsage") {
		obj = new _KJUR_asn1_x509.ExtKeyUsage(param);
	    } else if (extname == "authorityInfoAccess") {
		obj = new _KJUR_asn1_x509.AuthorityInfoAccess(param);
	    } else if (extname == "cRLNumber") {
		obj = new _KJUR_asn1_x509.CRLNumber(param);
	    } else if (extname == "cRLReason") {
		obj = new _KJUR_asn1_x509.CRLReason(param);
	    } else if (extname == "ocspNonce") {
		obj = new _KJUR_asn1_x509.OCSPNonce(param);
	    } else if (extname == "ocspNoCheck") {
		obj = new _KJUR_asn1_x509.OCSPNoCheck(param);
	    } else if (extname == "adobeTimeStamp") {
		obj = new _KJUR_asn1_x509.AdobeTimeStamp(param);
	    } else if (extname == "subjectDirectoryAttributes") {
		obj = new _KJUR_asn1_x509.SubjectDirectoryAttributes(param);
	    } else {
		throw new Error("extension not supported:"
				+ JSON.stringify(param));
	    }
	    if (obj != null) a.push(obj);
	}

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (aParam != undefined) this.setByParam(aParam);
};
extendClass(KJUR.asn1.x509.Extensions, KJUR.asn1.ASN1Object);


// === END   TBSCertificate ===================================================

// === BEGIN X.509v3 Extensions Related =======================================

/**
 * base Extension ASN.1 structure class
 * @name KJUR.asn1.x509.Extension
 * @class base Extension ASN.1 structure class
 * @param {Array} params associative array of parameters (ex. {'critical': true})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <pre>
 * Extension  ::=  SEQUENCE  {
 *     extnID      OBJECT IDENTIFIER,
 *     critical    BOOLEAN DEFAULT FALSE,
 *     extnValue   OCTET STRING  }
 * </pre>
 * @example
 */
KJUR.asn1.x509.Extension = function(params) {
    KJUR.asn1.x509.Extension.superclass.constructor.call(this);
    var asn1ExtnValue = null,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_DERBitString = _KJUR_asn1.DERBitString,
	_DERBoolean = _KJUR_asn1.DERBoolean,
	_DERSequence = _KJUR_asn1.DERSequence;

    this.tohex = function() {
        var asn1Oid = new _DERObjectIdentifier({'oid': this.oid});
        var asn1EncapExtnValue =
            new _DEROctetString({'hex': this.getExtnValueHex()});

        var asn1Array = new Array();
        asn1Array.push(asn1Oid);
        if (this.critical) asn1Array.push(new _DERBoolean());
        asn1Array.push(asn1EncapExtnValue);

        var asn1Seq = new _DERSequence({'array': asn1Array});
        return asn1Seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.critical = false;
    if (params !== undefined) {
        if (params.critical !== undefined) {
            this.critical = params.critical;
        }
    }
};
extendClass(KJUR.asn1.x509.Extension, KJUR.asn1.ASN1Object);

/**
 * KeyUsage ASN.1 structure class
 * @name KJUR.asn1.x509.KeyUsage
 * @class KeyUsage ASN.1 structure class
 * @param {Array} params associative array of parameters (ex. {'bin': '11', 'critical': true})
 * @extends KJUR.asn1.x509.Extension
 * @description
 * This class is for <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.3" target="_blank">KeyUsage</a> X.509v3 extension.
 * <pre>
 * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
 * KeyUsage ::= BIT STRING {
 *   digitalSignature   (0),
 *   nonRepudiation     (1),
 *   keyEncipherment    (2),
 *   dataEncipherment   (3),
 *   keyAgreement       (4),
 *   keyCertSign        (5),
 *   cRLSign            (6),
 *   encipherOnly       (7),
 *   decipherOnly       (8) }
 * </pre><br/>
 * NOTE: 'names' parameter is supprted since jsrsasign 8.0.14.
 * @example
 * o = new KJUR.asn1.x509.KeyUsage({bin: "11"});
 * o = new KJUR.asn1.x509.KeyUsage({critical: true, bin: "11"});
 * o = new KJUR.asn1.x509.KeyUsage({names: ['digitalSignature', 'keyAgreement']});
 */
KJUR.asn1.x509.KeyUsage = function(params) {
    KJUR.asn1.x509.KeyUsage.superclass.constructor.call(this, params);

    var _Error = Error;

    var _nameValue = {
	digitalSignature:	0,
	nonRepudiation:		1,
	keyEncipherment:	2,
	dataEncipherment:	3,
	keyAgreement:		4,
	keyCertSign:		5,
	cRLSign:		6,
	encipherOnly:		7,
	decipherOnly:		8
    };

    this.getExtnValueHex = function() {
	var binString = this.getBinValue();
        this.asn1ExtnValue = new KJUR.asn1.DERBitString({bin: binString});
        return this.asn1ExtnValue.tohex();
    };

    this.getBinValue = function() {
	var params = this.params;

	if (typeof params != "object" ||
	    (typeof params.names != "object" && typeof params.bin != "string"))
	    throw new _Error("parameter not yet set");

	if (params.names != undefined) {
	    return namearraytobinstr(params.names, _nameValue);
	} else if (params.bin != undefined) {
	    return params.bin;
	} else {
	    throw new _Error("parameter not set properly");
	}
    };

    this.oid = "2.5.29.15";
    if (params !== undefined) this.params = params;
};
extendClass(KJUR.asn1.x509.KeyUsage, KJUR.asn1.x509.Extension);

/**
 * BasicConstraints ASN.1 structure class
 * @name KJUR.asn1.x509.BasicConstraints
 * @class BasicConstraints ASN.1 structure class
 * @param {Array} params JSON object for parameters (ex. {cA:true,critical:true})
 * @extends KJUR.asn1.x509.Extension
 * @see {@link X509#getExtBasicConstraints}
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.9">
 * BasicConstraints extension defined in RFC 5280 4.2.1.9</a>.
 * <pre>
 *  id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }
 *  BasicConstraints ::= SEQUENCE {
 *       cA                      BOOLEAN DEFAULT FALSE,
 *       pathLenConstraint       INTEGER (0..MAX) OPTIONAL }
 * </pre>
 * Its constructor can have following parameters:
 * <ul>
 * <li>{Boolean}cA - cA flag</li>
 * <li>{Integer}pathLen - pathLen field value</li>
 * <li>{Boolean}critical - critical flag</li>
 * </ul>
 * @example
 * new KJUR.asn1.x509.BasicConstraints({
 *   cA: true,
 *   pathLen: 3,
 *   critical: true
 * })
 */
KJUR.asn1.x509.BasicConstraints = function(params) {
    KJUR.asn1.x509.BasicConstraints.superclass.constructor.call(this, params);
    var _KJUR_asn1 = KJUR.asn1,
	_DERBoolean = _KJUR_asn1.DERBoolean,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERSequence = _KJUR_asn1.DERSequence;

    var cA = false;
    var pathLen = -1;

    this.getExtnValueHex = function() {
        var asn1Array = new Array();
        if (this.cA) asn1Array.push(new _DERBoolean());
        if (this.pathLen > -1)
            asn1Array.push(new _DERInteger({'int': this.pathLen}));
        var asn1Seq = new _DERSequence({'array': asn1Array});
        this.asn1ExtnValue = asn1Seq;
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.19";
    this.cA = false;
    this.pathLen = -1;
    if (params !== undefined) {
        if (params.cA !== undefined) {
            this.cA = params.cA;
        }
        if (params.pathLen !== undefined) {
            this.pathLen = params.pathLen;
        }
    }
};
extendClass(KJUR.asn1.x509.BasicConstraints, KJUR.asn1.x509.Extension);

/**
 * CRLDistributionPoints ASN.1 structure class
 * @name KJUR.asn1.x509.CRLDistributionPoints
 * @class CRLDistributionPoints ASN.1 structure class
 * @param {Array} params associative array of parameters (ex. {'uri': 'http://a.com/', 'critical': true})
 * @extends KJUR.asn1.x509.Extension
 * @see {@link X509#getExtCRLDistributionPoints}
 * @see {@link KJUR.asn1.x509.DistributionPoint}
 * @see {@link KJUR.asn1.x509.GeneralNames}
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.13">
 * CRLDistributionPoints extension defined in RFC 5280 4.2.1.13</a>.
 * <pre>
 * id-ce-cRLDistributionPoints OBJECT IDENTIFIER ::=  { id-ce 31 }
 * CRLDistributionPoints ::= SEQUENCE SIZE (1..MAX) OF DistributionPoint
 * DistributionPoint ::= SEQUENCE {
 *      distributionPoint       [0]     DistributionPointName OPTIONAL,
 *      reasons                 [1]     ReasonFlags OPTIONAL,
 *      cRLIssuer               [2]     GeneralNames OPTIONAL }
 * DistributionPointName ::= CHOICE {
 *      fullName                [0]     GeneralNames,
 *      nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }
 * </pre>
 * Constructor can have following parameter:
 * <ul>
 * <li>{Array}array - array of {@link KJUR.asn1.x509.DistributionPoint} parameter</li>
 * <li>{Boolean}critical - critical flag</li>
 * </ul>
 * @example
 * new KJUR.asn1.x509.CRLDistributionPoints({
 *   array: [{fulluri: "http://aaa.com/"}, {fulluri: "ldap://aaa.com/"}],
 *   critical: true
 * })
 */
KJUR.asn1.x509.CRLDistributionPoints = function(params) {
    KJUR.asn1.x509.CRLDistributionPoints.superclass.constructor.call(this, params);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_x509 = _KJUR_asn1.x509;

    this.getExtnValueHex = function() {
        return this.asn1ExtnValue.tohex();
    };

    this.setByDPArray = function(dpArray) {
	var asn1Array = [];
	for (var i = 0; i < dpArray.length; i++) {
	    if (dpArray[i] instanceof KJUR.asn1.ASN1Object) {
		asn1Array.push(dpArray[i]);
	    } else {
		var dp = new _KJUR_asn1_x509.DistributionPoint(dpArray[i]);
		asn1Array.push(dp);
	    }
	}
        this.asn1ExtnValue = new _KJUR_asn1.DERSequence({'array': asn1Array});
    };

    this.setByOneURI = function(uri) {
        var dp1 = new _KJUR_asn1_x509.DistributionPoint({fulluri: uri});
        this.setByDPArray([dp1]);
    };

    this.oid = "2.5.29.31";
    if (params !== undefined) {
        if (params.array !== undefined) {
            this.setByDPArray(params.array);
        } else if (params.uri !== undefined) {
            this.setByOneURI(params.uri);
        }
    }
};
extendClass(KJUR.asn1.x509.CRLDistributionPoints, KJUR.asn1.x509.Extension);

/**
 * DistributionPoint ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.DistributionPoint
 * @class DistributionPoint ASN.1 structure class
 * @param {Array} params JSON object of parameters (OPTIONAL)
 * @extends KJUR.asn1.ASN1Object
 * @see {@link KJUR.asn1.x509.CRLDistributionPoints}
 * @see {@link KJUR.asn1.x509.DistributionPointName}
 * @see {@link KJUR.asn1.x509.GeneralNames}
 * @see {@link X509#getDistributionPoint}
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.13">
 * DistributionPoint defined in RFC 5280 4.2.1.13</a>.
 * <pre>
 * DistributionPoint ::= SEQUENCE {
 *      distributionPoint       [0]     DistributionPointName OPTIONAL,
 *      reasons                 [1]     ReasonFlags OPTIONAL,
 *      cRLIssuer               [2]     GeneralNames OPTIONAL }
 * </pre>
 * Constructor can have following parameter:
 * <ul>
 * <li>{String}fulluri - uri string for fullName uri. This has the same meaning for '{dpname: {full: [{uri: "..."]}}'.</li>
 * <li>{Array}dpname - JSON object for {@link KJUR.asn1.x509.DistributionPointName} parameters</li>
 * <li>{DistrubutionPoint}dpobj - {@link KJUR.asn1.x509.DistributionPointName} object (DEPRECATED)</li>
 * </ul>
 * <br/>
 * NOTE1: Parameter "fulluri" and "dpname" supported 
 * since jsrsasign 9.0.0 asn1x509 2.0.0.
 * <br/>
 * NOTE2: The "reasons" and "cRLIssuer" fields are currently
 * not supported.
 * @example
 * new KJUR.asn1.x509.DistributionPoint(
 *   {fulluri: "http://example.com/crl1.crl"})
 * new KJUR.asn1.x509.DistributionPoint(
 *   {dpname: {full: [{uri: "http://example.com/crl1.crl"}]}})
 * new KJUR.asn1.x509.DistributionPoint(
 *   {dpobj: new DistributionPoint(...)})
 */
KJUR.asn1.x509.DistributionPoint = function(params) {
    KJUR.asn1.x509.DistributionPoint.superclass.constructor.call(this);
    var asn1DP = null,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DistributionPointName = _KJUR_asn1.x509.DistributionPointName;

    this.tohex = function() {
        var seq = new _KJUR_asn1.DERSequence();
        if (this.asn1DP != null) {
            var o1 = new _KJUR_asn1.DERTaggedObject({'explicit': true,
                                                     'tag': 'a0',
                                                     'obj': this.asn1DP});
            seq.appendASN1Object(o1);
        }
        this.hTLV = seq.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
        if (params.dpobj !== undefined) {
            this.asn1DP = params.dpobj;
        } else if (params.dpname !== undefined) {
            this.asn1DP = new _DistributionPointName(params.dpname);
	} else if (params.fulluri !== undefined) {
            this.asn1DP = new _DistributionPointName({full: [{uri: params.fulluri}]});
	}
    }
};
extendClass(KJUR.asn1.x509.DistributionPoint, KJUR.asn1.ASN1Object);

/**
 * DistributionPointName ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.DistributionPointName
 * @class DistributionPointName ASN.1 structure class
 * @param {Array} params JSON object of parameters or GeneralNames object
 * @extends KJUR.asn1.ASN1Object
 * @see {@link KJUR.asn1.x509.CRLDistributionPoints}
 * @see {@link KJUR.asn1.x509.DistributionPoint}
 * @see {@link KJUR.asn1.x509.GeneralNames}
 * @see {@link X509#getDistributionPointName}
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.13">
 * DistributionPointName defined in RFC 5280 4.2.1.13</a>.
 * <pre>
 * DistributionPointName ::= CHOICE {
 *      fullName                [0]     GeneralNames,
 *      nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }
 * </pre>
 * Constructor can have following parameter:
 * <ul>
 * <li>{String}full - JSON object parameter of {@link KJUR.asn1.x509.GeneralNames} for 'fullName' field</li>
 * <li>{GeneralNames} - {@link KJUR.asn1.x509.GeneralNames} object for 'fullName'</li>
 * </ul>
 * NOTE1: 'full' parameter have been suppored since jsrsasign 9.0.0 asn1x509 2.0.0.
 * <br>
 * NOTE2: The 'nameRelativeToCRLIssuer' field is currently not supported.
 * @example
 * new KJUR.asn1.x509.DistributionPointName({full: <<GeneralNamesParameter>>})
 * new KJUR.asn1.x509.DistributionPointName({full: [{uri: <<CDPURI>>}]})
 * new KJUR.asn1.x509.DistributionPointName({full: [{dn: <<DN Parameter>>}]}
 * new KJUR.asn1.x509.DistributionPointName({full: [{uri: "http://example.com/root.crl"}]})
 * new KJUR.asn1.x509.DistributionPointName({full: [{dn {str: "/C=US/O=Test"}}]})
 * new KJUR.asn1.x509.DistributionPointName(new GeneralNames(...))
 */
KJUR.asn1.x509.DistributionPointName = function(params) {
    KJUR.asn1.x509.DistributionPointName.superclass.constructor.call(this);
    var asn1Obj = null,
	type = null,
	tag = null,
	asn1V = null,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject;

    this.tohex = function() {
        if (this.type != "full")
            throw new Error("currently type shall be 'full': " + this.type);
        this.asn1Obj = new _DERTaggedObject({'explicit': false,
                                             'tag': this.tag,
                                             'obj': this.asn1V});
        this.hTLV = this.asn1Obj.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
        if (_KJUR_asn1.x509.GeneralNames.prototype.isPrototypeOf(params)) {
            this.type = "full";
            this.tag = "a0";
            this.asn1V = params;
	} else if (params.full !== undefined) {
            this.type = "full";
            this.tag = "a0";
            this.asn1V = new _KJUR_asn1.x509.GeneralNames(params.full);
        } else {
            throw new Error("This class supports GeneralNames only as argument");
        }
    }
};
extendClass(KJUR.asn1.x509.DistributionPointName, KJUR.asn1.ASN1Object);

/**
 * CertificatePolicies ASN.1 structure class
 * @name KJUR.asn1.x509.CertificatePolicies
 * @class CertificatePolicies ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 8.0.23 asn1x509 1.1.12
 * @see KJUR.asn1.x509.CertificatePolicies
 * @see KJUR.asn1.x509.PolicyInformation
 * @see KJUR.asn1.x509.PolicyQualifierInfo
 * @see KJUR.asn1.x509.UserNotice
 * @see KJUR.asn1.x509.NoticeReference
 * @see KJUR.asn1.x509.DisplayText
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">
 * CertificatePolicies extension defined in RFC 5280 4.2.1.4</a>.
 * <pre>
 * id-ce-certificatePolicies OBJECT IDENTIFIER ::=  { id-ce 32 }
 * CertificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation
 * </pre>
 * Its constructor can have following parameters:
 * <ul>
 * <li>array - array of {@link KJUR.asn1.x509.PolicyInformation} parameter</li>
 * <li>critical - boolean: critical flag</li>
 * </ul>
 * NOTE: Returned JSON value format have been changed without 
 * backward compatibility since jsrsasign 9.0.0 asn1x509 2.0.0.
 * @example
 * e1 = new KJUR.asn1.x509.CertificatePolicies({
 *   array: [
 *     { policyoid: "1.2.3.4.5",
 *       array: [
 *         { cps: "https://example.com/repository" },
 *         { unotice: {
 *           noticeref: { // CA SHOULD NOT use this by RFC
 *             org: {type: "ia5", str: "Sample Org"},
 *             noticenum: [{int: 5}, {hex: "01af"}]
 *           },
 *           exptext: {type: "ia5", str: "Sample Policy"}
 *         }}
 *       ]
 *     }
 *   ],
 *   critical: true
 * });
 */
KJUR.asn1.x509.CertificatePolicies = function(params) {
    KJUR.asn1.x509.CertificatePolicies.superclass.constructor.call(this, params);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_DERSequence = _KJUR_asn1.DERSequence,
	_PolicyInformation = _KJUR_asn1_x509.PolicyInformation;

    this.params = null;

    this.getExtnValueHex = function() {
	var aPI = [];
	for (var i = 0; i < this.params.array.length; i++) {
	    aPI.push(new _PolicyInformation(this.params.array[i]));
	}
	var seq = new _DERSequence({array: aPI});
	this.asn1ExtnValue = seq;
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.32";
    if (params !== undefined) {
	this.params = params;
    }
};
extendClass(KJUR.asn1.x509.CertificatePolicies, KJUR.asn1.x509.Extension);

// ===== BEGIN CertificatePolicies related classes =====
/**
 * PolicyInformation ASN.1 structure class
 * @name KJUR.asn1.x509.PolicyInformation
 * @class PolicyInformation ASN.1 structure class
 * @param {Array} params JSON object of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 8.0.23 asn1x509 1.1.12
 * @see KJUR.asn1.x509.CertificatePolicies
 * @see KJUR.asn1.x509.PolicyInformation
 * @see KJUR.asn1.x509.PolicyQualifierInfo
 * @see KJUR.asn1.x509.UserNotice
 * @see KJUR.asn1.x509.NoticeReference
 * @see KJUR.asn1.x509.DisplayText
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">
 * PolicyInformation defined in RFC 5280 4.2.1.4</a>.
 * <pre>
 * PolicyInformation ::= SEQUENCE {
 *      policyIdentifier   CertPolicyId,
 *      policyQualifiers   SEQUENCE SIZE (1..MAX) OF
 *                         PolicyQualifierInfo OPTIONAL }
 * CertPolicyId ::= OBJECT IDENTIFIER
 * Its constructor can have following parameters:
 * <ul>
 * <li>{String}policyoid - policy OID (ex. "1.2.3.4.5")</li>
 * <li>{Object}array - array of {@link KJUR.asn1.x509.PolicyQualifierInfo}
 * parameters (OPTIONAL)</li>
 * </ul>
 * @example
 * new KJUR.asn1.x509.PolicyInformation({
 *   policyoid: "1.2.3.4.5",
 *   array: [
 *     { cps: "https://example.com/repository" },
 *     { unotice: {
 *       noticeref: { // CA SHOULD NOT use this by RFC
 *         org: {type: "ia5", str: "Sample Org"},
 *         noticenum: [{int: 5}, {hex: "01af"}]
 *       },
 *       exptext: {type: "ia5", str: "Sample Policy"}
 *     }}
 *   ]
 * })
 */
KJUR.asn1.x509.PolicyInformation = function(params) {
    KJUR.asn1.x509.PolicyInformation.superclass.constructor.call(this,
								 params);
    var _KJUR_asn1 = KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_PolicyQualifierInfo = _KJUR_asn1.x509.PolicyQualifierInfo;

    this.params = null;

    this.tohex = function() {
	if (this.params.policyoid === undefined &&
	    this.params.array === undefined)
	    throw new Error("parameter oid and array missing");

	// policy oid
	var a = [new _DERObjectIdentifier(this.params.policyoid)];

	// array of ASN1Object of PolicyQualifierInfo
	if (this.params.array !== undefined) {
	    var aPQI = [];
	    for (var i = 0; i < this.params.array.length; i++) {
		aPQI.push(new _PolicyQualifierInfo(this.params.array[i]));
	    }
	    if (aPQI.length > 0) {
		a.push(new _DERSequence({array: aPQI}));
	    }
	}

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
	this.params = params;
    }
};
extendClass(KJUR.asn1.x509.PolicyInformation, KJUR.asn1.ASN1Object);

/**
 * PolicyQualifierInfo ASN.1 structure class
 * @name KJUR.asn1.x509.PolicyQualifierInfo
 * @class PolicyQualifierInfo ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 8.0.23 asn1x509 1.1.12
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">
 * PolicyQualifierInfo defined in RFC 5280 4.2.1.4</a>.
 * <pre>
 * PolicyQualifierInfo ::= SEQUENCE {
 *      policyQualifierId  PolicyQualifierId,
 *      qualifier          ANY DEFINED BY policyQualifierId }
 * PolicyQualifierId ::= OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )
 * CPSuri ::= IA5String
 * </pre>
 * Its constructor can have one of following two parameters:
 * <ul>
 * <li>{String}cps - URI string for CPS</li>
 * <li>{Object}unotice - {@link KJUR.asn1.x509.UserNotice} parameter</li>
 * </ul>
 * @example
 * new PolicyQualifierInfo({
 *   cps: "https://example.com/repository/cps"
 * })
 *
 * new PolicyQualifierInfo({
 *   unotice: {
 *     noticeref: { // CA SHOULD NOT use this by RFC
 *       org: {type: "bmp", str: "Sample Org"},
 *       noticenum: [{int: 3}, {hex: "01af"}]
 *     },
 *     exptext: {type: "ia5", str: "Sample Policy"}
 *   }
 * })
 */
KJUR.asn1.x509.PolicyQualifierInfo = function(params) {
    KJUR.asn1.x509.PolicyQualifierInfo.superclass.constructor.call(this,
								   params);
    var _KJUR_asn1 = KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERIA5String = _KJUR_asn1.DERIA5String,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_UserNotice = _KJUR_asn1.x509.UserNotice;

    this.params = null;

    this.tohex = function() {
	if (this.params.cps !== undefined) {
	    var seq = new _DERSequence({array: [
		new _DERObjectIdentifier({oid: '1.3.6.1.5.5.7.2.1'}),
		new _DERIA5String({str: this.params.cps})
	    ]});
	    return seq.tohex();
	}
	if (this.params.unotice != undefined) {
	    var seq = new _DERSequence({array: [
		new _DERObjectIdentifier({oid: '1.3.6.1.5.5.7.2.2'}),
		new _UserNotice(this.params.unotice)
	    ]});
	    return seq.tohex();
	}
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
	this.params = params;
    }
};
extendClass(KJUR.asn1.x509.PolicyQualifierInfo, KJUR.asn1.ASN1Object);


/**
 * UserNotice ASN.1 structure class
 * @name KJUR.asn1.x509.UserNotice
 * @class UserNotice ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 8.0.23 asn1x509 1.1.12
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">
 * UserNotice defined in RFC 5280 4.2.1.4</a>.
 * <pre>
 * UserNotice ::= SEQUENCE {
 *      noticeRef        NoticeReference OPTIONAL,
 *      explicitText     DisplayText OPTIONAL }
 * </pre>
 * Its constructor can have following two parameters:
 * <ul>
 * <li>{Object}noticeref - {@link KJUR.asn1.x509.NoticeReference} parameter.
 * This SHALL NOT be set for conforming CA by RFC 5280. (OPTIONAL)</li>
 * <li>{Object}exptext - explicitText value
 * by {@link KJUR.asn1.x509.DisplayText} parameter (OPTIONAL)</li>
 * </ul>
 * @example
 * new UserNotice({
 *   noticeref: {
 *     org: {type: "bmp", str: "Sample Org"},
 *     noticenum: [{int: 3}, {hex: "01af"}]
 *   },
 *   exptext: {type: "ia5", str: "Sample Policy"}
 * })
 */
KJUR.asn1.x509.UserNotice = function(params) {
    KJUR.asn1.x509.UserNotice.superclass.constructor.call(this, params);
    var _DERSequence = KJUR.asn1.DERSequence,
	_DERInteger = KJUR.asn1.DERInteger,
	_DisplayText = KJUR.asn1.x509.DisplayText,
	_NoticeReference = KJUR.asn1.x509.NoticeReference;

    this.params = null;

    this.tohex = function() {
	var a = [];
	if (this.params.noticeref !== undefined) {
	    a.push(new _NoticeReference(this.params.noticeref));
	}
	if (this.params.exptext !== undefined) {
	    a.push(new _DisplayText(this.params.exptext));
	}
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
	this.params = params;
    }
};
extendClass(KJUR.asn1.x509.UserNotice, KJUR.asn1.ASN1Object);

/**
 * NoticeReference ASN.1 structure class
 * @name KJUR.asn1.x509.NoticeReference
 * @class NoticeReference ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 8.0.23 asn1x509 1.1.12
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">
 * NoticeReference defined in RFC 5280 4.2.1.4</a>.
 * <pre>
 * NoticeReference ::= SEQUENCE {
 *      organization     DisplayText,
 *      noticeNumbers    SEQUENCE OF INTEGER }
 * </pre>
 * Its constructor can have following two parameters:
 * <ul>
 * <li>{Object}org - organization by {@link KJUR.asn1.x509.DisplayText}
 * parameter.</li>
 * <li>{Object}noticenum - noticeNumbers value by an array of
 * {@link KJUR.asn1.DERInteger} parameter</li>
 * </ul>
 * @example
 * new NoticeReference({
 *   org: {type: "bmp", str: "Sample Org"},
 *   noticenum: [{int: 3}, {hex: "01af"}]
 * })
 */
KJUR.asn1.x509.NoticeReference = function(params) {
    KJUR.asn1.x509.NoticeReference.superclass.constructor.call(this, params);
    var _DERSequence = KJUR.asn1.DERSequence,
	_DERInteger = KJUR.asn1.DERInteger,
	_DisplayText = KJUR.asn1.x509.DisplayText;

    this.params = null;

    this.tohex = function() {
	var a = [];
	if (this.params.org !== undefined) {
	    a.push(new _DisplayText(this.params.org));
	}
	if (this.params.noticenum !== undefined) {
	    var aNoticeNum = [];
	    var aNumParam = this.params.noticenum;
	    for (var i = 0; i < aNumParam.length; i++) {
		aNoticeNum.push(new _DERInteger(aNumParam[i]));
	    }
	    a.push(new _DERSequence({array: aNoticeNum}));
	}
	if (a.length == 0) throw new Error("parameter is empty");
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    }
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
	this.params = params;
    }
};
extendClass(KJUR.asn1.x509.NoticeReference, KJUR.asn1.ASN1Object);

/**
 * DisplayText ASN.1 structure class
 * @name KJUR.asn1.x509.DisplayText
 * @class DisplayText ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.DERAbstractString
 * @since jsrsasign 8.0.23 asn1x509 1.1.12
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">
 * DisplayText defined in RFC 5280 4.2.1.4</a>.
 * <pre>
 * -- from RFC 5280 Appendix A
 * DisplayText ::= CHOICE {
 *      ia5String        IA5String      (SIZE (1..200)),
 *      visibleString    VisibleString  (SIZE (1..200)),
 *      bmpString        BMPString      (SIZE (1..200)),
 *      utf8String       UTF8String     (SIZE (1..200)) }
 * </pre>
 * {@link KJUR.asn1.DERAbstractString} parameters and methods
 * can be used.
 * Its constructor can also have following parameter:
 * <ul>
 * <li>{String} type - DirectoryString type of DisplayText.
 * "ia5" for IA5String, "vis" for VisibleString,
 * "bmp" for BMPString and "utf8" for UTF8String.
 * Default is "utf8". (OPTIONAL)</li>
 * </ul>
 * @example
 * new DisplayText({type: "bmp", str: "Sample Org"})
 * new DisplayText({type: "ia5", str: "Sample Org"})
 * new DisplayText({str: "Sample Org"})
 */
KJUR.asn1.x509.DisplayText = function(params) {
    KJUR.asn1.x509.DisplayText.superclass.constructor.call(this, params);

    this.hT = "0c"; // DEFAULT "utf8"

    if (params !== undefined) {
	if (params.type === "ia5") {
	    this.hT = "16";
	} else if (params.type === "vis") {
	    this.hT = "1a";
	} else if (params.type === "bmp") {
	    this.hT = "1e";
	}
    }
};
extendClass(KJUR.asn1.x509.DisplayText, KJUR.asn1.DERAbstractString);
// ===== END CertificatePolicies related classes =====

// =====================================================================

/**
 * PolicyMappings ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.PolicyMappings
 * @class PolicyMappings ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 10.6.1 asn1x509 2.1.17
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.5">
 * PolicyMappings extension defined in RFC 5280 4.2.1.5</a>.
 * <pre>
 * id-ce-policyMappings OBJECT IDENTIFIER ::=  { id-ce 33 }
 * PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {
 *    issuerDomainPolicy      CertPolicyId,
 *    subjectDomainPolicy     CertPolicyId }
 * </pre>
 * Its constructor can have following parameters:
 * <ul>
 * <li>array - Array: one or more pairs of OIDS</li>
 * <li>critical - boolean: critical flag</li>
 * </ul>
 * OID in "array" can use an OID name registered in
 * {@link KJUR.asn1.x509.OID} such as "anyPolicy".
 * @example
 * e1 = new KJUR.asn1.x509.PolicyMappings({
 *   array: [["1.2.3", "0.1.2"], ["anyPolicy", "1.2.4"]],
 *   critical: true
 * });
 */
KJUR.asn1.x509.PolicyMappings = function(params) {
    KJUR.asn1.x509.PolicyMappings.superclass.constructor.call(this, params);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_newObject = _KJUR_asn1.ASN1Util.newObject;

    this.params = null;

    this.getExtnValueHex = function() {
	var params = this.params;
	var aItem = [];
	for (var i = 0; i < params.array.length; i++) {
	    var aOid = params.array[i];
	    aItem.push({seq: [{oid: aOid[0]}, {oid: aOid[1]}]});
	}
	this.asn1ExtnValue = _newObject({seq: aItem});
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.33";
    if (params !== undefined) {
	this.params = params;
    }
};
extendClass(KJUR.asn1.x509.PolicyMappings, KJUR.asn1.x509.Extension);

/**
 * PolicyConstraints ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.PolicyConstraints
 * @class PolicyConstraints ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 10.6.1 asn1x509 2.1.17
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.11">
 * PolicyConstraints extension defined in RFC 5280 4.2.1.11</a>.
 * <pre>
 * id-ce-policyConstraints OBJECT IDENTIFIER ::=  { id-ce 36 }
 * PolicyConstraints ::= SEQUENCE {
 *    requireExplicitPolicy  [0] SkipCerts OPTIONAL,
 *    inhibitPolicyMapping   [1] SkipCerts OPTIONAL }
 * SkipCerts ::= INTEGER (0..MAX)
 * </pre>
 * Its constructor can have following parameters:
 * <ul>
 * <li>reqexp - integer: the number of additional certificates that may appear 
 * in the path before an explicit policy is required for the entire path.</li>
 * <li>inhibit - integer: the number of additional certificates that may appear 
 * in the path before policy mapping is no longer permitted.</li>
 * <li>critical - boolean: critical flag</li>
 * </ul>
 * @example
 * e1 = new KJUR.asn1.x509.PolicyConstraints({
 *   reqexp: 3,
 *   inhibit: 3,
 *   critical: true
 * });
 */
KJUR.asn1.x509.PolicyConstraints = function(params) {
    KJUR.asn1.x509.PolicyConstraints.superclass.constructor.call(this, params);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_newObject = _KJUR_asn1.ASN1Util.newObject;

    this.params = null;

    this.getExtnValueHex = function() {
	var params = this.params;
	var aItem = [];
	if (params.reqexp != undefined) {
	    aItem.push({tag: {tagi: "80", obj: {"int": params.reqexp}}});
	}
	if (params.inhibit != undefined) {
	    aItem.push({tag: {tagi: "81", obj: {"int": params.inhibit}}});
	}

	this.asn1ExtnValue = _newObject({"seq": aItem});
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.36";
    if (params !== undefined) {
	this.params = params;
    }
};
extendClass(KJUR.asn1.x509.PolicyConstraints, KJUR.asn1.x509.Extension);

/**
 * InhibitAnyPolicy ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.InhibitAnyPolicy
 * @class InhibitAnyPolicy ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 10.6.1 asn1x509 2.1.17
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.14">
 * InhibitAnyPolicy extension defined in RFC 5280 4.2.1.14</a>.
 * <pre>
 * id-ce-inhibitAnyPolicy OBJECT IDENTIFIER ::=  { id-ce 54 }
 * InhibitAnyPolicy ::= SkipCerts
 * SkipCerts ::= INTEGER (0..MAX)
 * </pre>
 * Its constructor can have following parameters:
 * <ul>
 * <li>skip - the number of additional non-self-issued certificates that may appear
 * in the path before anyPolicy is no longer permitted<li>
 * <li>critical - boolean: critical flag</li>
 * </ul>
 * @example
 * e1 = new KJUR.asn1.x509.InhibitAnyPolicy({
 *   skip: 5,
 *   critical: true
 * });
 */
KJUR.asn1.x509.InhibitAnyPolicy = function(params) {
    KJUR.asn1.x509.InhibitAnyPolicy.superclass.constructor.call(this, params);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_newObject = _KJUR_asn1.ASN1Util.newObject;

    this.params = null;

    this.getExtnValueHex = function() {
	this.asn1ExtnValue = _newObject({"int": this.params.skip});
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.54";
    if (params !== undefined) {
	this.params = params;
    }
};
extendClass(KJUR.asn1.x509.InhibitAnyPolicy, KJUR.asn1.x509.Extension);

// =====================================================================
/**
 * NameConstraints ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.NameConstraints
 * @class NameConstraints ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 10.5.16 asn1x509 2.1.13
 * @see X509#getExtNameConstraints
 * @see KJUR.asn1.x509.GeneralSubtree
 * @see KJUR.asn1.x509.GeneralName

 * @description
 * This class provides X.509v3 NameConstraints extension.
 * defined in 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.10">
 * RFC 5280 4.2.1.10</a>.
 * <pre>
 * id-ce-nameConstraints OBJECT IDENTIFIER ::=  { id-ce 30 }
 * NameConstraints ::= SEQUENCE {
 *   permittedSubtrees  [0]  GeneralSubtrees OPTIONAL,
 *   excludedSubtrees   [1]  GeneralSubtrees OPTIONAL }
 * GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree
 * GeneralSubtree ::= SEQUENCE {
 *   base           GeneralName,
 *   minimum   [0]  BaseDistance DEFAULT 0,
 *   maximum   [1]  BaseDistance OPTIONAL }
 * BaseDistance ::= INTEGER (0..MAX)
 * </pre>
 *
 * @example
 * new NameConstraints({permit: [{dns: "example.com"}], critical: true})
 * new NameConstraints({exclude: [{uri: "example.com"}], critical: true})
 * new NameConstraints({exclude: [{dn: "/C=JP/O=T1"}], critical: true})
 * new NameConstraints({
 *   critical: true,
 *   permit: [{dn: "/C=JP/O=T1"}],
 *   exclude: [{dn: "/C=US/O=T1", max: 2}]})
 */
KJUR.asn1.x509.NameConstraints = function(params) {
    KJUR.asn1.x509.NameConstraints.superclass.constructor.call(this, params);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_newObject = _KJUR_asn1.ASN1Util.newObject,
	_GeneralSubtree = _KJUR_asn1_x509.GeneralSubtree;

    this.params = null;

    this.getExtnValueHex = function() {
	var params = this.params;
	var aItem = [];
	if (params.permit != undefined &&
	    params.permit.length != undefined) {
	    var aPermit = [];
	    for (var i = 0; i < params.permit.length; i++) {
		aPermit.push(new _GeneralSubtree(params.permit[i]));
	    }
	    aItem.push({tag: {tagi: "a0", obj: {seq: aPermit}}});
	}

	if (params.exclude != undefined &&
	    params.exclude.length != undefined) {
	    var aExclude = [];
	    for (var i = 0; i < params.exclude.length; i++) {
		aExclude.push(new _GeneralSubtree(params.exclude[i]));
	    }
	    aItem.push({tag: {tagi: "a1", obj: {seq: aExclude}}});
	}

	this.asn1ExtnValue = _newObject({seq: aItem});
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.30";
    if (params !== undefined) this.params = params;
};
extendClass(KJUR.asn1.x509.NameConstraints, KJUR.asn1.x509.Extension);

/**
 * GeneralSubtree ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.GeneralSubtree
 * @class GeneralSubtree ASN.1 structure class
 * @since jsrsasign 10.5.16 asn1x509 2.1.13
 * @see KJUR.asn1.x509.NameConstraints
 * @see KJUR.asn1.x509.GeneralName
 * @see X509#getExtNameConstraints
 * @see X509#getGeneralSubtree
 *
 * @description
 * This class provides a encoder for GeneralSubtree 
 * defined in 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.10">
 * RFC 5280 4.2.1.10</a>. 
 * This will be used for nameConstraints extension.
 * <br>
 * Here is definition of the ASN.1 syntax:
 * <pre>
 * GeneralSubtree ::= SEQUENCE {
 *   base           GeneralName,
 *   minimum   [0]  BaseDistance DEFAULT 0,
 *   maximum   [1]  BaseDistance OPTIONAL }
 * BaseDistance ::= INTEGER (0..MAX)
 * </pre>
 * An argument for constructor is the same as
 * {@link KJUR.asn1.x509.GeneralName} except
 * this has following optional members:
 * <ul>
 * <li>min - {Number} value for the minimum field</li>
 * <li>max - {Number} value for the maximum field</li>
 * </ul>
 * Please note that min and max can't be specified since
 * they are prohibited in RFC 5280.
 *
 * @example
 * new GeneralSubtree({dns: "example.com"})
 * new GeneralSubtree({uri: ".example.com"})
 * new GeneralSubtree({dn: "/C=JP/O=Test1"})
 */
KJUR.asn1.x509.GeneralSubtree = function(params) {
    KJUR.asn1.x509.GeneralSubtree.superclass.constructor.call(this);

    var _KJUR_asn1 = KJUR.asn1,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_GeneralName = _KJUR_asn1_x509.GeneralName,
	_newObject = _KJUR_asn1.ASN1Util.newObject;

    this.params = null;

    this.setByParam = function(params) {
	this.params = params;
    };

    this.tohex = function() {
	var params = this.params;

	var aItem = [new _GeneralName(params)];
	if (params.min != undefined)
	    aItem.push({tag: {tagi:"80", obj: {"int": params.min}}});
	if (params.max != undefined)
	    aItem.push({tag: {tagi:"81", obj: {"int": params.max}}});

	var dSeq = _newObject({seq: aItem});
	return dSeq.tohex();
    }
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.x509.GeneralSubtree, KJUR.asn1.ASN1Object);

// =====================================================================
/**
 * KeyUsage ASN.1 structure class
 * @name KJUR.asn1.x509.ExtKeyUsage
 * @class ExtKeyUsage ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.x509.Extension
 * @description
 * @example
 * e1 = new KJUR.asn1.x509.ExtKeyUsage({
 *   critical: true,
 *   array: [
 *     {oid: '2.5.29.37.0'},  // anyExtendedKeyUsage
 *     {name: 'clientAuth'},
 *     "1.2.3.4",
 *     "serverAuth"
 *   ]
 * });
 * // id-ce-extKeyUsage OBJECT IDENTIFIER ::= { id-ce 37 }
 * // ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId
 * // KeyPurposeId ::= OBJECT IDENTIFIER
 */
KJUR.asn1.x509.ExtKeyUsage = function(params) {
    KJUR.asn1.x509.ExtKeyUsage.superclass.constructor.call(this, params);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1;

    this.setPurposeArray = function(purposeArray) {
        this.asn1ExtnValue = new _KJUR_asn1.DERSequence();
        for (var i = 0; i < purposeArray.length; i++) {
            var o = new _KJUR_asn1.DERObjectIdentifier(purposeArray[i]);
            this.asn1ExtnValue.appendASN1Object(o);
        }
    };

    this.getExtnValueHex = function() {
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.37";
    if (params !== undefined) {
        if (params.array !== undefined) {
            this.setPurposeArray(params.array);
        }
    }
};
extendClass(KJUR.asn1.x509.ExtKeyUsage, KJUR.asn1.x509.Extension);

/**
 * AuthorityKeyIdentifier ASN.1 structure class
 * @name KJUR.asn1.x509.AuthorityKeyIdentifier
 * @class AuthorityKeyIdentifier ASN.1 structure class
 * @param {Array} params associative array of parameters (ex. {kid: {hex: '89ab...'}, critical: true})
 * @extends KJUR.asn1.x509.Extension
 * @since asn1x509 1.0.8
 * @description
 * This class represents ASN.1 structure for <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.1">AuthorityKeyIdentifier in RFC 5280</a>.
 * Constructor of this class may have following parameters.: 
 * <ul>
 * <li>kid - When key object (RSA, KJUR.crypto.ECDSA/DSA) or PEM string of issuing authority public key or issuer certificate is specified, key identifier will be automatically calculated by the method specified in RFC 5280. When a hexadecimal string is specifed, kid will be set explicitly by it.</li>
 * <li>isscert - When PEM string of authority certificate is specified, both authorityCertIssuer and authorityCertSerialNumber will be set by the certificate.</li>
 * <li>issuer - {@link KJUR.asn1.x509.X500Name} parameter to specify issuer name explicitly.</li>
 * <li>sn - hexadecimal string to specify serial number explicitly.</li>
 * <li>critical - boolean to specify criticality of this extension
 * however conforming CA must mark this extension as non-critical in RFC 5280.</li>
 * </ul>
 * 
 * <pre>
 * d-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 35 }
 * AuthorityKeyIdentifier ::= SEQUENCE {
 *    keyIdentifier             [0] KeyIdentifier           OPTIONAL,
 *    authorityCertIssuer       [1] GeneralNames            OPTIONAL,
 *    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }
 * KeyIdentifier ::= OCTET STRING
 * </pre>
 *
 * @example
 * // 1. kid by key object
 * keyobj = KEYUTIL.getKey("-----BEGIN PUBLIC KEY...");
 * e1 = new KJUR.asn1.x509.AuthorityKeyIdentifier({kid: keyobj});
 * // 2. kid by PEM string of authority certificate or public key
 * e1 = new KJUR.asn1.x509.AuthorityKeyIdentifier({kid: "-----BEGIN..."});
 * // 3. specify kid explicitly
 * e1 = new KJUR.asn1.x509.AuthorityKeyIdentifier({kid: "8ab1d3..."});
 * });
 * // 4. issuer and serial number by auhtority PEM certificate
 * e1 = new KJUR.asn1.x509.AuthorityKeyIdentifier({isscert: "-----BEGIN..."});
 * // 5. issuer and serial number explicitly
 * e1 = new KJUR.asn1.x509.AuthorityKeyIdentifier({
 *   issuer: {ldapstr: "O=test,C=US"},
 *   sn: {hex: "1ac7..."}});
 * // 6. combination
 * e1 = new KJUR.asn1.x509.AuthorityKeyIdentifier({
 *   kid: "-----BEGIN CERTIFICATE...",
 *   isscert: "-----BEGIN CERTIFICATE..."});
 */
KJUR.asn1.x509.AuthorityKeyIdentifier = function(params) {
    KJUR.asn1.x509.AuthorityKeyIdentifier.superclass.constructor.call(this, params);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_GeneralNames = _KJUR_asn1.x509.GeneralNames,
	_isKey = _KJUR.crypto.Util.isKey;

    this.asn1KID = null;
    this.asn1CertIssuer = null; // X500Name hTLV
    this.asn1CertSN = null;

    this.getExtnValueHex = function() {
        var a = new Array();
        if (this.asn1KID)
            a.push(new _DERTaggedObject({'explicit': false,
                                         'tag': '80',
                                         'obj': this.asn1KID}));

        if (this.asn1CertIssuer)
            a.push(new _DERTaggedObject({'explicit': false,
                                         'tag': 'a1',
                                         'obj': new _GeneralNames([{dn: this.asn1CertIssuer}])}));

        if (this.asn1CertSN)
            a.push(new _DERTaggedObject({'explicit': false,
                                         'tag': '82',
                                         'obj': this.asn1CertSN}));

        var asn1Seq = new _KJUR_asn1.DERSequence({'array': a});
        this.asn1ExtnValue = asn1Seq;
        return this.asn1ExtnValue.tohex();
    };

    /**
     * set keyIdentifier value by DEROctetString parameter, key object or PEM file
     * @name setKIDByParam
     * @memberOf KJUR.asn1.x509.AuthorityKeyIdentifier#
     * @function
     * @param {Array} param parameter to set key identifier
     * @since asn1x509 1.0.8
     * @description
     * This method will set keyIdentifier by param.
     * Its key identifier value can be set by following type of param argument:
     * <ul>
     * <li>{str: "123"} - by raw string</li>
     * <li>{hex: "01af..."} - by hexadecimal value</li>
     * <li>RSAKey/DSA/ECDSA - by RSAKey, KJUR.crypto.{DSA/ECDSA} public key object.
     * key identifier value will be calculated by the method described in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.2">RFC 5280 4.2.1.2 (1)</a>.
     * </li>
     * <li>certificate PEM string - extract subjectPublicKeyInfo from specified PEM
     * certificate and
     * key identifier value will be calculated by the method described in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.2">RFC 5280 4.2.1.2 (1)</a>.
     * <li>PKCS#1/#8 public key PEM string - pem will be converted to a key object and
     * to PKCS#8 ASN.1 structure then calculate 
     * a key identifier value will be calculated by the method described in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.2">RFC 5280 4.2.1.2 (1)</a>.
     * </ul>
     *
     * NOTE1: Automatic key identifier calculation is supported
     * since jsrsasign 8.0.16.
     *
     * @see KEYUTIL.getKeyID
     * 
     * @example
     * o = new KJUR.asn1.x509.AuthorityKeyIdentifier();
     * // set by hexadecimal string
     * o.setKIDByParam({hex: '1ad9...'});
     * // set by SubjectPublicKeyInfo of PEM certificate string
     * o.setKIDByParam("-----BEGIN CERTIFICATE...");
     * // set by PKCS#8 PEM public key string
     * o.setKIDByParam("-----BEGIN PUBLIC KEY...");
     * // set by public key object
     * pubkey = KEYUTIL.getKey("-----BEGIN CERTIFICATE...");
     * o.setKIDByParam(pubkey);
     */
    this.setKIDByParam = function(param) {
	if (param.str !== undefined ||
	    param.hex !== undefined) {
	    this.asn1KID = new KJUR.asn1.DEROctetString(param);
	} else if ((typeof param === "object" &&
		    KJUR.crypto.Util.isKey(param)) ||
		   (typeof param === "string" &&
		    param.indexOf("BEGIN ") != -1)) {

	    var keyobj = param;
	    if (typeof param === "string") {
		keyobj = KEYUTIL.getKey(param);
	    }

	    var kid = KEYUTIL.getKeyID(keyobj);
	    this.asn1KID = new KJUR.asn1.DEROctetString({hex: kid});
	}
    };

    /**
     * set authorityCertIssuer value by X500Name parameter
     * @name setCertIssuerByParam
     * @memberOf KJUR.asn1.x509.AuthorityKeyIdentifier#
     * @function
     * @param {Array} param parameter to set issuer name
     * @since asn1x509 1.0.8
     * @description
     * This method will set authorityCertIssuer name by param.
     * Issuer name can be set by following type of param argument:
     * <ul>
     * <li>str/ldapstr/hex/certsubject/certissuer - 
     * set issuer by {@link KJUR.asn1.x509.X500Name}
     * object with specified parameters.</li>
     * <li>PEM CERTIFICATE STRING - extract its subject name from 
     * specified issuer PEM certificate and set.
     * </ul>
     * NOTE1: Automatic authorityCertIssuer setting by certificate
     * is supported since jsrsasign 8.0.16.
     *
     * @see KJUR.asn1.x509.X500Name
     * @see KJUR.asn1.x509.GeneralNames
     * @see X509.getSubjectHex
     *
     * @example
     * var o = new KJUR.asn1.x509.AuthorityKeyIdentifier();
     * // 1. set it by string
     * o.setCertIssuerByParam({str: '/C=US/O=Test'});
     * // 2. set it by issuer PEM certificate
     * o.setCertIssuerByParam("-----BEGIN CERTIFICATE...");
     *
     */
    this.setCertIssuerByParam = function(param) {
	if (param.str !== undefined ||
	    param.ldapstr !== undefined ||
	    param.hex !== undefined ||
	    param.certsubject !== undefined ||
	    param.certissuer !== undefined) {
            this.asn1CertIssuer = new KJUR.asn1.x509.X500Name(param);
	} else if (typeof param === "string" &&
		   param.indexOf("BEGIN ") != -1 &&
		   param.indexOf("CERTIFICATE") != -1) {
            this.asn1CertIssuer = new KJUR.asn1.x509.X500Name({certissuer: param});
	}
    };

    /**
     * set authorityCertSerialNumber value
     * @name setCertSerialNumberByParam
     * @memberOf KJUR.asn1.x509.AuthorityKeyIdentifier#
     * @function
     * @param {Object} param parameter to set serial number
     * @since asn1x509 1.0.8
     * @description
     * This method will set authorityCertSerialNumber by param.
     * Serial number can be set by following type of param argument:
     *
     * <ul>
     * <li>{int: 123} - by integer value</li>
     * <li>{hex: "01af"} - by hexadecimal integer value</li>
     * <li>{bigint: new BigInteger(...)} - by hexadecimal integer value</li>
     * <li>PEM CERTIFICATE STRING - extract serial number from issuer certificate and
     * set serial number.
     * 
     * NOTE1: Automatic authorityCertSerialNumber setting by certificate
     * is supported since jsrsasign 8.0.16.
     *
     * @see X509.getSerialNumberHex
     */
    this.setCertSNByParam = function(param) {
	if (param.str !== undefined ||
	    param.bigint !== undefined ||
	    param.hex !== undefined) {
            this.asn1CertSN = new KJUR.asn1.DERInteger(param);
	} else if (typeof param === "string" &&
		   param.indexOf("BEGIN ") != -1 &&
		   param.indexOf("CERTIFICATE")) {

            var x = new X509();
            x.readCertPEM(param);
	    var sn = x.getSerialNumberHex();
	    this.asn1CertSN = new KJUR.asn1.DERInteger({hex: sn});
	}
    };

    this.oid = "2.5.29.35";
    if (params !== undefined) {
        if (params.kid !== undefined) {
            this.setKIDByParam(params.kid);
        }
        if (params.issuer !== undefined) {
            this.setCertIssuerByParam(params.issuer);
        }
        if (params.sn !== undefined) {
            this.setCertSNByParam(params.sn);
        }

	if (params.issuersn !== undefined &&
	    typeof params.issuersn === "string" &&
	    params.issuersn.indexOf("BEGIN ") != -1 &&
	    params.issuersn.indexOf("CERTIFICATE")) {
	    this.setCertSNByParam(params.issuersn);
	    this.setCertIssuerByParam(params.issuersn);
	}
    }
};
extendClass(KJUR.asn1.x509.AuthorityKeyIdentifier, KJUR.asn1.x509.Extension);

/**
 * SubjectKeyIdentifier extension ASN.1 structure class
 * @name KJUR.asn1.x509.SubjectKeyIdentifier
 * @class SubjectKeyIdentifier ASN.1 structure class
 * @param {Array} params associative array of parameters (ex. {kid: {hex: '89ab...'}, critical: true})
 * @extends KJUR.asn1.x509.Extension
 * @since asn1x509 1.1.7 jsrsasign 8.0.14
 * @description
 * This class represents ASN.1 structure for 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.2">
 * SubjectKeyIdentifier in RFC 5280</a>.
 * Constructor of this class may have following parameters:
 * <ul>
 * <li>kid - When key object (RSA, KJUR.crypto.ECDSA/DSA) or PEM string of subject public key or certificate is specified, key identifier will be automatically calculated by the method specified in RFC 5280. When a hexadecimal string is specifed, kid will be set explicitly by it.</li>
 * <li>critical - boolean to specify criticality of this extension
 * however conforming CA must mark this extension as non-critical in RFC 5280.</li>
 * </ul>
 * <pre>
 * d-ce-subjectKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 14 }
 * SubjectKeyIdentifier ::= KeyIdentifier
 * KeyIdentifier ::= OCTET STRING
 * </pre>
 *
 * @example
 * // set by hexadecimal string
 * e = new KJUR.asn1.x509.SubjectKeyIdentifier({kid: {hex: '89ab'}});
 * // set by PEM public key or certificate string
 * e = new KJUR.asn1.x509.SubjectKeyIdentifier({kid: "-----BEGIN CERTIFICATE..."});
 * // set by public key object
 * pubkey = KEYUTIL.getKey("-----BEGIN CERTIFICATE...");
 * e = new KJUR.asn1.x509.SubjectKeyIdentifier({kid: pubkey});
 */
KJUR.asn1.x509.SubjectKeyIdentifier = function(params) {
    KJUR.asn1.x509.SubjectKeyIdentifier.superclass.constructor.call(this, params);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DEROctetString = _KJUR_asn1.DEROctetString;

    this.asn1KID = null;

    this.getExtnValueHex = function() {
        this.asn1ExtnValue = this.asn1KID;
        return this.asn1ExtnValue.tohex();
    };

    /**
     * set keyIdentifier value by DEROctetString parameter, key object or PEM file
     * @name setKIDByParam
     * @memberOf KJUR.asn1.x509.SubjectKeyIdentifier#
     * @function
     * @param {Array} param array of {@link KJUR.asn1.DERInteger} parameter
     * @since asn1x509 1.1.7 jsrsasign 8.0.14
     * @description
     * <ul>
     * <li>{str: "123"} - by raw string</li>
     * <li>{hex: "01af..."} - by hexadecimal value</li>
     * <li>RSAKey/DSA/ECDSA - by RSAKey, KJUR.crypto.{DSA/ECDSA} public key object.
     * key identifier value will be calculated by the method described in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.2">RFC 5280 4.2.1.2 (1)</a>.
     * </li>
     * <li>certificate PEM string - extract subjectPublicKeyInfo from specified PEM
     * certificate and
     * key identifier value will be calculated by the method described in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.2">RFC 5280 4.2.1.2 (1)</a>.
     * <li>PKCS#1/#8 public key PEM string - pem will be converted to a key object and
     * to PKCS#8 ASN.1 structure then calculate 
     * a key identifier value will be calculated by the method described in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.2">RFC 5280 4.2.1.2 (1)</a>.
     * </ul>
     *
     * NOTE1: Automatic key identifier calculation is supported
     * since jsrsasign 8.0.16.
     *
     * @see KEYUTIL.getKeyID
     *
     * @example
     * o = new KJUR.asn1.x509.SubjectKeyIdentifier();
     * // set by hexadecimal string
     * o.setKIDByParam({hex: '1ad9...'});
     * // set by SubjectPublicKeyInfo of PEM certificate string
     * o.setKIDByParam("-----BEGIN CERTIFICATE...");
     * // set by PKCS#8 PEM public key string
     * o.setKIDByParam("-----BEGIN PUBLIC KEY...");
     * // set by public key object
     * pubkey = KEYUTIL.getKey("-----BEGIN CERTIFICATE...");
     * o.setKIDByParam(pubkey);
     */
    this.setKIDByParam = function(param) {
	if (param.str !== undefined ||
	    param.hex !== undefined) {
	    this.asn1KID = new _DEROctetString(param);
	} else if ((typeof param === "object" &&
		    KJUR.crypto.Util.isKey(param)) ||
		   (typeof param === "string" &&
		    param.indexOf("BEGIN") != -1)) {

	    var keyobj = param;
	    if (typeof param === "string") {
		keyobj = KEYUTIL.getKey(param);
	    }

	    var kid = KEYUTIL.getKeyID(keyobj);
	    this.asn1KID = new KJUR.asn1.DEROctetString({hex: kid});
	}
    };

    this.oid = "2.5.29.14";
    if (params !== undefined) {
	if (params.kid !== undefined) {
	    this.setKIDByParam(params.kid);
	}
    }
};
extendClass(KJUR.asn1.x509.SubjectKeyIdentifier, KJUR.asn1.x509.Extension);

/**
 * AuthorityInfoAccess ASN.1 structure class
 * @name KJUR.asn1.x509.AuthorityInfoAccess
 * @class AuthorityInfoAccess ASN.1 structure class
 * @param {Array} params JSON object of AuthorityInfoAccess parameters
 * @extends KJUR.asn1.x509.Extension
 * @since asn1x509 1.0.8
 * @see {@link X509#getExtAuthorityInfoAccess}
 * @description
 * This class represents 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.2.1">
 * AuthorityInfoAccess extension defined in RFC 5280 4.2.2.1</a>.
 * <pre>
 * id-pe OBJECT IDENTIFIER  ::=  { id-pkix 1 }
 * id-pe-authorityInfoAccess OBJECT IDENTIFIER ::= { id-pe 1 }
 * AuthorityInfoAccessSyntax  ::=
 *         SEQUENCE SIZE (1..MAX) OF AccessDescription
 * AccessDescription  ::=  SEQUENCE {
 *         accessMethod          OBJECT IDENTIFIER,
 *         accessLocation        GeneralName  }
 * id-ad OBJECT IDENTIFIER ::= { id-pkix 48 }
 * id-ad-caIssuers OBJECT IDENTIFIER ::= { id-ad 2 }
 * id-ad-ocsp OBJECT IDENTIFIER ::= { id-ad 1 }
 * </pre>
 * NOTE: Acceptable parameters have been changed since
 * from jsrsasign 9.0.0 asn1x509 2.0.0.
 * Parameter generated by {@link X509#getAuthorityInfoAccess}
 * can be accepted as a argument of this constructor.
 * @example
 * e1 = new KJUR.asn1.x509.AuthorityInfoAccess({
 *   array: [
 *     {ocsp: 'http://ocsp.example.org'},
 *     {caissuer: 'https://repository.example.org/aaa.crt'}
 *   ]
 * });
 */
KJUR.asn1.x509.AuthorityInfoAccess = function(params) {
    KJUR.asn1.x509.AuthorityInfoAccess.superclass.constructor.call(this, params);

    this.setAccessDescriptionArray = function(aParam) {
        var aASN1 = new Array(),
	    _KJUR = KJUR,
	    _KJUR_asn1 = _KJUR.asn1,
	    _DERSequence = _KJUR_asn1.DERSequence,
	    _DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	    _GeneralName = _KJUR_asn1.x509.GeneralName;

        for (var i = 0; i < aParam.length; i++) {
	    var adseq;
	    var adparam = aParam[i];

	    if (adparam.ocsp !== undefined) {
		adseq = new _DERSequence({array: [
		    new _DERObjectIdentifier({oid: "1.3.6.1.5.5.7.48.1"}),
		    new _GeneralName({uri: adparam.ocsp})
		]});
	    } else if (adparam.caissuer !== undefined) {
		adseq = new _DERSequence({array: [
		    new _DERObjectIdentifier({oid: "1.3.6.1.5.5.7.48.2"}),
		    new _GeneralName({uri: adparam.caissuer})
		]});
	    } else {
		throw new Error("unknown AccessMethod parameter: " +
				JSON.stringify(adparam));
	    }
	    aASN1.push(adseq);
        }
        this.asn1ExtnValue = new _DERSequence({'array':aASN1});
    };

    this.getExtnValueHex = function() {
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "1.3.6.1.5.5.7.1.1";
    if (params !== undefined) {
        if (params.array !== undefined) {
            this.setAccessDescriptionArray(params.array);
        }
    }
};
extendClass(KJUR.asn1.x509.AuthorityInfoAccess, KJUR.asn1.x509.Extension);

/**
 * SubjectAltName ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.SubjectAltName
 * @class SubjectAltName ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 6.2.3 asn1x509 1.0.19
 * @see KJUR.asn1.x509.GeneralNames
 * @see KJUR.asn1.x509.GeneralName
 * @description
 * This class provides X.509v3 SubjectAltName extension.
 * <pre>
 * id-ce-subjectAltName OBJECT IDENTIFIER ::=  { id-ce 17 }
 * SubjectAltName ::= GeneralNames
 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 * GeneralName ::= CHOICE {
 *   otherName                  [0] OtherName,
 *   rfc822Name                 [1] IA5String,
 *   dNSName                    [2] IA5String,
 *   x400Address                [3] ORAddress,
 *   directoryName              [4] Name,
 *   ediPartyName               [5] EDIPartyName,
 *   uniformResourceIdentifier  [6] IA5String,
 *   iPAddress                  [7] OCTET STRING,
 *   registeredID               [8] OBJECT IDENTIFIER }
 * </pre>
 * @example
 * e1 = new KJUR.asn1.x509.SubjectAltName({
 *   critical: true,
 *   array: [{uri: 'http://aaa.com/'}, {uri: 'http://bbb.com/'}]
 * });
 */
KJUR.asn1.x509.SubjectAltName = function(params) {
    KJUR.asn1.x509.SubjectAltName.superclass.constructor.call(this, params)

    this.setNameArray = function(paramsArray) {
	this.asn1ExtnValue = new KJUR.asn1.x509.GeneralNames(paramsArray);
    };

    this.getExtnValueHex = function() {
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.17";
    if (params !== undefined) {
        if (params.array !== undefined) {
            this.setNameArray(params.array);
        }
    }
};
extendClass(KJUR.asn1.x509.SubjectAltName, KJUR.asn1.x509.Extension);

/**
 * IssuerAltName ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.IssuerAltName
 * @class IssuerAltName ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 6.2.3 asn1x509 1.0.19
 * @see KJUR.asn1.x509.GeneralNames
 * @see KJUR.asn1.x509.GeneralName
 * @description
 * This class provides X.509v3 IssuerAltName extension.
 * <pre>
 * id-ce-subjectAltName OBJECT IDENTIFIER ::=  { id-ce 18 }
 * IssuerAltName ::= GeneralNames
 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 * GeneralName ::= CHOICE {
 *   otherName                  [0] OtherName,
 *   rfc822Name                 [1] IA5String,
 *   dNSName                    [2] IA5String,
 *   x400Address                [3] ORAddress,
 *   directoryName              [4] Name,
 *   ediPartyName               [5] EDIPartyName,
 *   uniformResourceIdentifier  [6] IA5String,
 *   iPAddress                  [7] OCTET STRING,
 *   registeredID               [8] OBJECT IDENTIFIER }
 * </pre>
 * @example
 * e1 = new KJUR.asn1.x509.IssuerAltName({
 *   critical: true,
 *   array: [{uri: 'http://aaa.com/'}, {uri: 'http://bbb.com/'}]
 * });
 */
KJUR.asn1.x509.IssuerAltName = function(params) {
    KJUR.asn1.x509.IssuerAltName.superclass.constructor.call(this, params)

    this.setNameArray = function(paramsArray) {
	this.asn1ExtnValue = new KJUR.asn1.x509.GeneralNames(paramsArray);
    };

    this.getExtnValueHex = function() {
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.18";
    if (params !== undefined) {
        if (params.array !== undefined) {
            this.setNameArray(params.array);
        }
    }
};
extendClass(KJUR.asn1.x509.IssuerAltName, KJUR.asn1.x509.Extension);

/**
 * SubjectDirectoryAttributes ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.SubjectDirectoryAttributes
 * @class SubjectDirectoryAttributes ASN.1 structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 10.1.9 asn1x509 2.1.7
 * @see
 * 
 * @description
 * This class provides X.509v3 SubjectDirectoryAttributes extension
 * defined in <a href="https://tools.ietf.org/html/rfc3739#section-3.3.2">
 * RFC 3739 Qualified Certificate Profile section 3.3.2</a>.
 * <pre>
 * SubjectDirectoryAttributes ::= Attributes
 * Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
 * Attribute ::= SEQUENCE {
 *   type AttributeType 
 *   values SET OF AttributeValue }
 * AttributeType ::= OBJECT IDENTIFIER
 * AttributeValue ::= ANY DEFINED BY AttributeType
 * </pre>
 * Value of member "array" is an array which as following associative arrays as elements:
 * <ul>
 * <li>attr: OID name or value of attribute type (ex. "gender" or "1.2.3.4")</li>
 * <li>str: attribute value of pre defined types (See example for registered attribute types)</li>
 * <li>array: array of ASN.1 parameters as attribute value (See {@link KJUR.asn1.ASN1Util#newObject})</li>
 * </ul>
 * <br/>
 * NOTE: From jsrsasign 10.8.4, member "array in array" supported for an arbitrary
 * attribute value.
 *
 * @example
 * e1 = new KJUR.asn1.x509.SubjectDirectoryAttributes({
 *   extname: "subjectDirectoryAttributes",
 *   array: [
 *     { attr: "dateOfBirth", str: "19701231230000Z" },
 *     { attr: "placeOfBirth", str: "Tokyo" },
 *     { attr: "gender", str: "F" },
 *     { attr: "countryOfCitizenship", str: "JP" },
 *     { attr: "countryOfResidence", str: "JP" },
 *     { attr: "1.2.3.4.5", array: [{prnstr: {str: "aaa"}}] }
 *   ]
 * });
 */
KJUR.asn1.x509.SubjectDirectoryAttributes = function(params) {
    KJUR.asn1.x509.SubjectDirectoryAttributes.superclass.constructor.call(this, params);
    var _KJUR_asn1 = KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_newObject = _KJUR_asn1.ASN1Util.newObject,
	_name2oid = _KJUR_asn1.x509.OID.name2oid;

    this.params = null;

    this.getExtnValueHex = function() {
	var a = [];
	for (var i = 0; i < this.params.array.length; i++) {
	    var pAttr = this.params.array[i];

	    if (pAttr.attr != undefined && pAttr.array != undefined) {
		var pObj = {"seq": [{"oid": pAttr.attr}, {"set": pAttr.array}]};
		a.push(_newObject(pObj));
		continue;
	    }

	    var newparam = {"seq": [{"oid": "1.2.3.4"}, {"set": [{"utf8str": "DE"}]}]};

	    if (pAttr.attr == "dateOfBirth") {
		newparam.seq[0].oid = _name2oid(pAttr.attr);
		newparam.seq[1].set[0] = {"gentime": pAttr.str};
	    } else if (pAttr.attr == "placeOfBirth") {
		newparam.seq[0].oid = _name2oid(pAttr.attr);
		newparam.seq[1].set[0] = {"utf8str": pAttr.str};
	    } else if (pAttr.attr == "gender") {
		newparam.seq[0].oid = _name2oid(pAttr.attr);
		newparam.seq[1].set[0] = {"prnstr": pAttr.str};
	    } else if (pAttr.attr == "countryOfCitizenship") {
		newparam.seq[0].oid = _name2oid(pAttr.attr);
		newparam.seq[1].set[0] = {"prnstr": pAttr.str};
	    } else if (pAttr.attr == "countryOfResidence") {
		newparam.seq[0].oid = _name2oid(pAttr.attr);
		newparam.seq[1].set[0] = {"prnstr": pAttr.str};
	    } else {
		throw new Error("unsupported attribute: " + pAttr.attr);
	    }
	    a.push(new _newObject(newparam));
	}
	var seq = new _DERSequence({array: a});
	this.asn1ExtnValue = seq;
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.9";
    if (params !== undefined) {
	this.params = params;
    }
};
extendClass(KJUR.asn1.x509.SubjectDirectoryAttributes, KJUR.asn1.x509.Extension);


/**
 * priavte extension ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.PrivateExtension
 * @class private extension ASN.1 structure class
 * @param {Array} params JSON object of private extension
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 9.1.1 asn1x509 
 * @see KJUR.asn1.ASN1Util.newObject
 *
 * @description
 * This class is to represent private extension or 
 * unsupported extension. 
 * <pre>
 * Extension  ::=  SEQUENCE  {
 *      extnID      OBJECT IDENTIFIER,
 *      critical    BOOLEAN DEFAULT FALSE,
 *      extnValue   OCTET STRING }
 * </pre>
 * Following properties can be set for JSON parameter:
 * <ul>
 * <li>{String}extname - string of OID or predefined extension name</li>
 * <li>{Boolean}critical - critical flag</li>
 * <li>{Object}extn - hexadecimal string or 
 * of {@link KJUR.asn1.ASN1Util.newObject} 
 * JSON parameter for extnValue field</li>
 * </li>
 * </ul>
 *
 * @example
 * // extn by hexadecimal
 * new KJUR.asn1.x509.PrivateExtension({
 *   extname: "1.2.3.4",
 *   critical: true,
 *   extn: "13026161" // means PrintableString "aa"
 * });
 *
 * // extn by JSON parameter
 * new KJUR.asn1.x509.PrivateExtension({
 *   extname: "1.2.3.5",
 *   extn: {seq: [{prnstr:"abc"},{utf8str:"def"}]}
 * });
 */
KJUR.asn1.x509.PrivateExtension = function(params) {
    KJUR.asn1.x509.PrivateExtension.superclass.constructor.call(this, params)

    var _KJUR = KJUR,
	_isHex = _KJUR.lang.String.isHex,
	_KJUR_asn1 = _KJUR.asn1,
	_name2oid = _KJUR_asn1.x509.OID.name2oid,
	_newObject = _KJUR_asn1.ASN1Util.newObject;

    this.params = null;

    this.setByParam = function(params) {
	this.oid = _name2oid(params.extname);
	this.params = params;
    };

    this.getExtnValueHex = function() {
	if (this.params.extname == undefined ||
	    this.params.extn == undefined) {
	    throw new Error("extname or extnhex not specified");
	}

	var extn = this.params.extn;
	if (typeof extn == "string" && _isHex(extn)) {
	    return extn;
	} else if (typeof extn == "object") {
	    try {
		return _newObject(extn).tohex();
	    } catch(ex) {}
	}
	throw new Error("unsupported extn value");
    };

    if (params != undefined) {
	this.setByParam(params);
    }
};
extendClass(KJUR.asn1.x509.PrivateExtension, KJUR.asn1.x509.Extension);

// === END   X.509v3 Extensions Related =======================================

// === BEGIN CRL Related ===================================================
/**
 * X.509 CRL class to sign and generate hex encoded CRL<br/>
 * @name KJUR.asn1.x509.CRL
 * @class X.509 CRL class to sign and generate hex encoded certificate
 * @property {Array} params JSON object of parameters
 * @param {Array} params JSON object of CRL parameters
 * @extends KJUR.asn1.ASN1Object
 * @since 1.0.3
 * @see KJUR.asn1.x509.TBSCertList
 * 
 * @description
 * This class represents CertificateList ASN.1 structur of X.509 CRL
 * defined in <a href="https://tools.ietf.org/html/rfc5280#section-5.1">
 * RFC 5280 5.1</a>
 * <pre>
 * CertificateList  ::=  SEQUENCE  {
 *     tbsCertList          TBSCertList,
 *     signatureAlgorithm   AlgorithmIdentifier,
 *     signatureValue       BIT STRING  }
 * </pre>
 * NOTE: CRL class is updated without backward 
 * compatibility from jsrsasign 9.1.0 asn1x509 2.1.0.
 * Most of methods are removed and parameters can be set
 * by JSON object.
 * <br/>
 * Constructor of this class can accept all
 * parameters of {@link KJUR.asn1.x509.TBSCertList}.
 * It also accept following parameters additionally:
 * <ul>
 * <li>{TBSCertList}tbsobj (OPTION) - 
 * specifies {@link KJUR.asn1.x509.TBSCertList} 
 * object to be signed if needed. 
 * When this isn't specified, 
 * this will be set from other parametes of TBSCertList.</li>
 * <li>{Object}cakey (OPTION) - specifies CRL signing private key.
 * Parameter "cakey" or "sighex" shall be specified. Following
 * values can be specified:
 *   <ul>
 *   <li>PKCS#1/5 or PKCS#8 PEM string of private key</li>
 *   <li>RSAKey/DSA/ECDSA key object. {@link KEYUTIL.getKey} is useful
 *   to generate a key object.</li>
 *   </ul>
 * </li>
 * <li>{String}sighex (OPTION) - hexadecimal string of signature value
 * (i.e. ASN.1 value(V) of signatureValue BIT STRING without
 * unused bits)</li>
 * </ul>
 *
 * @example
 * var crl = new KJUR.asn1.x509.CRL({
 *  sigalg: "SHA256withRSA",
 *  issuer: {str:'/C=JP/O=Test1'},
 *  thisupdate: "200821235959Z",
 *  nextupdate: "200828235959Z", // OPTION
 *  revcert: [{sn: {hex: "12ab"}, date: "200401235959Z"}],
 *  ext: [
 *   {extname: "cRLNumber", num: {'int': 8}},
 *   {extname: "authorityKeyIdentifier", "kid": {hex: "12ab"}}
 *  ],
 *  cakey: prvkey
 * });
 * crl.gettohex() &rarr; "30..."
 * crl.getPEM() &rarr; "-----BEGIN X509 CRL..."
 */
KJUR.asn1.x509.CRL = function(params) {
    KJUR.asn1.x509.CRL.superclass.constructor.call(this);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERBitString = _KJUR_asn1.DERBitString,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_AlgorithmIdentifier = _KJUR_asn1_x509.AlgorithmIdentifier,
	_TBSCertList = _KJUR_asn1_x509.TBSCertList;

    this.params = undefined;

    this.setByParam = function(params) {
	this.params = params;
    };

    /**
     * sign CRL<br/>
     * @name sign
     * @memberOf KJUR.asn1.x509.CRL#
     * @function
     * @description
     * This method signs TBSCertList with a specified 
     * private key and algorithm by 
     * this.params.cakey and this.params.sigalg parameter.
     * @example
     * crl = new KJUR.asn1.x509.CRL({..., cakey:prvkey});
     * crl.sign()
     */
    this.sign = function() {
	var hTBSCL = (new _TBSCertList(this.params)).tohex();
	var sig = new KJUR.crypto.Signature({alg: this.params.sigalg});
	sig.init(this.params.cakey);
	sig.updateHex(hTBSCL);
	var sighex = sig.sign();
	this.params.sighex = sighex;
    };

    /**
     * get PEM formatted CRL string after signed<br/>
     * @name getPEM
     * @memberOf KJUR.asn1.x509.CRL#
     * @function
     * @return PEM formatted string of CRL
     * @since jsrsasign 9.1.0 asn1hex 2.1.0
     * @description
     * This method returns a string of PEM formatted 
     * CRL.
     * @example
     * crl = new KJUR.asn1.x509.CRL({...});
     * crl.getPEM() &rarr;
     * "-----BEGIN X509 CRL-----\r\n..."
     */
    this.getPEM = function() {
	return hextopem(this.tohex(), "X509 CRL");
    };

    this.tohex = function() {
	var params = this.params;

	if (params.tbsobj == undefined) {
	    params.tbsobj = new _TBSCertList(params);
	}

	if (params.sighex == undefined && params.cakey != undefined) {
	    this.sign();
	}

	if (params.sighex == undefined) {
	    throw new Error("sighex or cakey parameter not defined");
	}
	
	var a = [];
	a.push(params.tbsobj);
	a.push(new _AlgorithmIdentifier({name: params.sigalg}));
	a.push(new _DERBitString({hex: "00" + params.sighex}));
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.params = params;
};
extendClass(KJUR.asn1.x509.CRL, KJUR.asn1.ASN1Object);

/**
 * ASN.1 TBSCertList ASN.1 structure class for CRL<br/>
 * @name KJUR.asn1.x509.TBSCertList
 * @class TBSCertList ASN.1 structure class for CRL
 * @property {Array} params JSON object of parameters
 * @param {Array} params JSON object of TBSCertList parameters
 * @extends KJUR.asn1.ASN1Object
 * @since 1.0.3
 *
 * @description
 * This class represents TBSCertList of CRL defined in
 * <a href="https://tools.ietf.org/html/rfc5280#section-5.1">
 * RFC 5280 5.1</a>.
 * <pre>
 * TBSCertList  ::=  SEQUENCE  {
 *       version                 Version OPTIONAL,
 *                                    -- if present, MUST be v2
 *       signature               AlgorithmIdentifier,
 *       issuer                  Name,
 *       thisUpdate              Time,
 *       nextUpdate              Time OPTIONAL,
 *       revokedCertificates     SEQUENCE OF SEQUENCE  {
 *            userCertificate         CertificateSerialNumber,
 *            revocationDate          Time,
 *            crlEntryExtensions      Extensions OPTIONAL
 *                                     -- if present, version MUST be v2
 *                                 }  OPTIONAL,
 *       crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
 * }
 * </pre>
 * NOTE: TBSCertList class is updated without backward 
 * compatibility from jsrsasign 9.1.0 asn1x509 2.1.0.
 * Most of methods are removed and parameters can be set
 * by JSON object.
 * <br/>
 * Constructor of this class may have following parameters:
 * <ul>
 * <li>{Integer}version (OPTION) - version number. Omitted by default.</li>
 * <li>{String}sigalg - signature algorithm name</li>
 * <li>{Array}issuer - issuer parameter of {@link KJUR.asn1.x509.X500Name}</li>
 * <li>{String}thisupdate - thisUpdate field value</li>
 * <li>{String}nextupdate (OPTION) - thisUpdate field value</li>
 * <li>{Array}revcert (OPTION) - revokedCertificates field value as array
 *   Its element may have following property:
 *   <ul>
 *   <li>{Array}sn - serialNumber of userCertificate field specified
 *   by {@link KJUR.asn1.DERInteger}</li>
 *   <li>{String}date - revocationDate field specified by
 *   a string of {@link KJUR.asn1.x509.Time} parameter</li>
 *   <li>{Array}ext (OPTION) - array of CRL entry extension parameter</li>
 *   </ul>
 * </li>
 * </ul>
 * 
 * @example
 * var o = new KJUR.asn1.x509.TBSCertList({
 *  sigalg: "SHA256withRSA",
 *  issuer: {array: [[{type:'C',value:'JP',ds:'prn'}],
 *                   [{type:'O',value:'T1',ds:'prn'}]]},
 *  thisupdate: "200821235959Z",
 *  nextupdate: "200828235959Z", // OPTION
 *  revcert: [
 *   {sn: {hex: "12ab"}, date: "200401235959Z", ext: [{extname: "cRLReason", code:1}]},
 *   {sn: {hex: "12bc"}, date: "200405235959Z", ext: [{extname: "cRLReason", code:2}]}
 *  ],
 *  ext: [
 *   {extname: "cRLNumber", num: {'int': 8}},
 *   {extname: "authorityKeyIdentifier", "kid": {hex: "12ab"}}
 *  ]
 * });
 * o.tohex() &rarr; "30..."
 */
KJUR.asn1.x509.TBSCertList = function(params) {
    KJUR.asn1.x509.TBSCertList.superclass.constructor.call(this);
    var	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_AlgorithmIdentifier = _KJUR_asn1_x509.AlgorithmIdentifier,
	_Time = _KJUR_asn1_x509.Time,
	_Extensions = _KJUR_asn1_x509.Extensions,
	_X500Name = _KJUR_asn1_x509.X500Name;
    this.params = null;

    /**
     * get array of ASN.1 object for extensions<br/>
     * @name setByParam
     * @memberOf KJUR.asn1.x509.TBSCertList#
     * @function
     * @param {Array} JSON object of TBSCertList parameters
     * @example
     * tbsc = new KJUR.asn1.x509.TBSCertificate();
     * tbsc.setByParam({version:3, serial:{hex:'1234...'},...});
     */
    this.setByParam = function(params) {
	this.params = params;
    };

    /**
     * get DERSequence for revokedCertificates<br/>
     * @name getRevCertSequence
     * @memberOf KJUR.asn1.x509.TBSCertList#
     * @function
     * @return {@link KJUR.asn1.DERSequence} of revokedCertificates
     */
    this.getRevCertSequence = function() {
	var a = [];
	var aRevCert = this.params.revcert;
	for (var i = 0; i < aRevCert.length; i++) {
	    var aEntry = [
		new _DERInteger(aRevCert[i].sn),
		new _Time(aRevCert[i].date)
	    ];
	    if (aRevCert[i].ext != undefined) {
		aEntry.push(new _Extensions(aRevCert[i].ext));
	    }
	    a.push(new _DERSequence({array: aEntry}));
	}
	return new _DERSequence({array: a});
    };

    this.tohex = function() {
	var a = [];
	var params = this.params;

	if (params.version != undefined) {
	    var version = params.version - 1; 
	    var obj = new _DERInteger({'int': version});
	    a.push(obj);
	}

	a.push(new _AlgorithmIdentifier({name: params.sigalg}));
	a.push(new _X500Name(params.issuer));
	a.push(new _Time(params.thisupdate));
	if (params.nextupdate != undefined) 
	    a.push(new _Time(params.nextupdate))
	if (params.revcert != undefined) {
	    a.push(this.getRevCertSequence());
	}
	if (params.ext != undefined) {
	    var dExt = new _Extensions(params.ext);
	    a.push(new _DERTaggedObject({tag:'a0',
					 explicit:true,
					 obj:dExt}));
	}

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.x509.TBSCertList, KJUR.asn1.ASN1Object);

/**
 * ASN.1 CRLEntry structure class for CRL (DEPRECATED)<br/>
 * @name KJUR.asn1.x509.CRLEntry
 * @class ASN.1 CRLEntry structure class for CRL
 * @param {Array} params JSON object for CRL entry parameter
 * @extends KJUR.asn1.ASN1Object
 * @since 1.0.3
 * @see KJUR.asn1.x509.TBSCertList
 * @deprecated since jsrsasign 9.1.0 asn1x509 2.1.0
 * @description
 * This class is to represent revokedCertificate in TBSCertList.
 * However this is no more used by TBSCertList since
 * jsrsasign 9.1.0. So this class have been deprecated in 
 * jsrsasign 9.1.0.
 * <pre>
 * revokedCertificates     SEQUENCE OF SEQUENCE  {
 *     userCertificate         CertificateSerialNumber,
 *     revocationDate          Time,
 *     crlEntryExtensions      Extensions OPTIONAL
 *                             -- if present, version MUST be v2 }
 * </pre>
 * @example
 * var e = new KJUR.asn1.x509.CRLEntry({'time': {'str': '130514235959Z'}, 'sn': {'int': 234}});
 */
KJUR.asn1.x509.CRLEntry = function(params) {
    KJUR.asn1.x509.CRLEntry.superclass.constructor.call(this);
    var sn = null,
	time = null,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1;

    /**
     * set DERInteger parameter for serial number of revoked certificate
     * @name setCertSerial
     * @memberOf KJUR.asn1.x509.CRLEntry
     * @function
     * @param {Array} intParam DERInteger parameter for certificate serial number
     * @description
     * @example
     * entry.setCertSerial({'int': 3});
     */
    this.setCertSerial = function(intParam) {
        this.sn = new _KJUR_asn1.DERInteger(intParam);
    };

    /**
     * set Time parameter for revocation date
     * @name setRevocationDate
     * @memberOf KJUR.asn1.x509.CRLEntry
     * @function
     * @param {Array} timeParam Time parameter for revocation date
     * @description
     * @example
     * entry.setRevocationDate({'str': '130508235959Z'});
     */
    this.setRevocationDate = function(timeParam) {
        this.time = new _KJUR_asn1.x509.Time(timeParam);
    };

    this.tohex = function() {
        var o = new _KJUR_asn1.DERSequence({"array": [this.sn, this.time]});
        this.TLV = o.tohex();
        return this.TLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
        if (params.time !== undefined) {
            this.setRevocationDate(params.time);
        }
        if (params.sn !== undefined) {
            this.setCertSerial(params.sn);
        }
    }
};
extendClass(KJUR.asn1.x509.CRLEntry, KJUR.asn1.ASN1Object);

/**
 * CRLNumber CRL extension ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.CRLNumber
 * @class CRLNumber CRL extension ASN.1 structure class
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 9.1.0 asn1x509 2.1.0
 * @see KJUR.asn1.x509.TBSCertList
 * @see KJUR.asn1.x509.Extensions
 * @description
 * This class represents ASN.1 structure for
 * CRLNumber CRL extension defined in
 * <a href="https://tools.ietf.org/html/rfc5280#section-5.2.3">
 * RFC 5280 5.2.3</a>.
 * <pre>
 * id-ce-cRLNumber OBJECT IDENTIFIER ::= { id-ce 20 }
 * CRLNumber ::= INTEGER (0..MAX)
 * </pre>
 * Constructor of this class may have following parameters:
 * <ul>
 * <li>{String}extname - name "cRLNumber". It is ignored in this class but
 * required to use with {@link KJUR.asn1.x509.Extensions} class. (OPTION)</li>
 * <li>{Object}num - CRLNumber value to specify
 * {@link KJUR.asn1.DERInteger} parameter.</li>
 * <li>{Boolean}critical - critical flag. Generally false and not specified
 * in this class.(OPTION)</li>
 * </ul>
 *
 * @example
 * new KJUR.asn1.x509.CRLNumber({extname:'cRLNumber',
 *                               num:{'int':147}})
 */
KJUR.asn1.x509.CRLNumber = function(params) {
    KJUR.asn1.x509.CRLNumber.superclass.constructor.call(this, params);
    this.params = undefined;

    this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DERInteger(this.params.num);
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.20";
    if (params != undefined) this.params = params;
};
extendClass(KJUR.asn1.x509.CRLNumber, KJUR.asn1.x509.Extension);

/**
 * CRLReason CRL entry extension ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.CRLReason
 * @class CRLReason CRL entry extension ASN.1 structure class
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 9.1.0 asn1x509 2.1.0
 * @see KJUR.asn1.x509.TBSCertList
 * @see KJUR.asn1.x509.Extensions
 * @description
 * This class represents ASN.1 structure for
 * CRLReason CRL entry extension defined in
 * <a href="https://tools.ietf.org/html/rfc5280#section-5.3.1">
 * RFC 5280 5.3.1</a>
 * <pre>
 * id-ce-cRLReasons OBJECT IDENTIFIER ::= { id-ce 21 }
 * -- reasonCode ::= { CRLReason }
 * CRLReason ::= ENUMERATED {
 *      unspecified             (0),
 *      keyCompromise           (1),
 *      cACompromise            (2),
 *      affiliationChanged      (3),
 *      superseded              (4),
 *      cessationOfOperation    (5),
 *      certificateHold         (6),
 *      removeFromCRL           (8),
 *      privilegeWithdrawn      (9),
 *      aACompromise           (10) }
 * </pre>
 * Constructor of this class may have following parameters:
 * <ul>
 * <li>{String}extname - name "cRLReason". It is ignored in this class but
 * required to use with {@link KJUR.asn1.x509.Extensions} class. (OPTION)</li>
 * <li>{Integer}code - reasonCode value</li>
 * <li>{Boolean}critical - critical flag. Generally false and not specified
 * in this class.(OPTION)</li>
 * </ul>
 *
 * @example
 * new KJUR.asn1.x509.CRLReason({extname:'cRLReason',code:4})
 */
KJUR.asn1.x509.CRLReason = function(params) {
    KJUR.asn1.x509.CRLReason.superclass.constructor.call(this, params);
    this.params = undefined;

    this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DEREnumerated(this.params.code);
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "2.5.29.21";
    if (params != undefined) this.params = params;
};
extendClass(KJUR.asn1.x509.CRLReason, KJUR.asn1.x509.Extension);

// === END   CRL Related ===================================================

// === BEGIN OCSP Related ===================================================
/**
 * Nonce OCSP extension ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.OCSPNonce
 * @class Nonce OCSP extension ASN.1 structure class
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 9.1.6 asn1x509 2.1.2
 * @param {Array} params JSON object for Nonce extension
 * @see KJUR.asn1.ocsp.ResponseData
 * @see KJUR.asn1.x509.Extensions
 * @see X509#getExtOCSPNonce
 * @description
 * This class represents
 * Nonce OCSP extension value defined in
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.4.1">
 * RFC 6960 4.4.1</a> as JSON object.
 * <pre>
 * id-pkix-ocsp           OBJECT IDENTIFIER ::= { id-ad-ocsp }
 * id-pkix-ocsp-nonce     OBJECT IDENTIFIER ::= { id-pkix-ocsp 2 }
 * Nonce ::= OCTET STRING
 * </pre>
 * Constructor of this class may have following parameters:
 * <ul>
 * <li>{String}extname - name "ocspNonce". It is ignored in this class but
 * required to use with {@link KJUR.asn1.x509.Extensions} class. (OPTION)</li>
 * <li>{String}hex - hexadecimal string of nonce value</li>
 * <li>{Number}int - integer of nonce value. "hex" or "int" needs to be
 * specified.</li>
 * <li>{Boolean}critical - critical flag. Generally false and not specified
 * in this class.(OPTION)</li>
 * </ul>
 *
 * @example
 * new KJUR.asn1.x509.OCSPNonce({extname:'ocspNonce',
 *                               hex: '12ab...'})
 */
KJUR.asn1.x509.OCSPNonce = function(params) {
    KJUR.asn1.x509.OCSPNonce.superclass.constructor.call(this, params);
    this.params = undefined;

    this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DEROctetString(this.params);
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "1.3.6.1.5.5.7.48.1.2";
    if (params != undefined) this.params = params;
};
extendClass(KJUR.asn1.x509.OCSPNonce, KJUR.asn1.x509.Extension);

/**
 * OCSPNoCheck certificate ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.OCSPNoCheck
 * @class OCSPNoCheck extension ASN.1 structure class
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 9.1.6 asn1x509 2.1.2
 * @param {Array} params JSON object for OCSPNoCheck extension
 * @see KJUR.asn1.x509.Extensions
 * @see X509#getExtOCSPNoCheck
 * @description
 * This class represents
 * OCSPNoCheck extension value defined in
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.2.2.1">
 * RFC 6960 4.2.2.2.1</a> as JSON object.
 * <pre>
 * id-pkix-ocsp-nocheck OBJECT IDENTIFIER ::= { id-pkix-ocsp 5 }
 * </pre>
 * Constructor of this class may have following parameters:
 * <ul>
 * <li>{String}extname - name "ocspNoCheck". It is ignored in this class but
 * required to use with {@link KJUR.asn1.x509.Extensions} class. (OPTION)</li>
 * <li>{Boolean}critical - critical flag. Generally false and not specified
 * in this class.(OPTION)</li>
 * </ul>
 *
 * @example
 * new KJUR.asn1.x509.OCSPNonce({extname:'ocspNoCheck'})
 */
KJUR.asn1.x509.OCSPNoCheck = function(params) {
    KJUR.asn1.x509.OCSPNoCheck.superclass.constructor.call(this, params);
    this.params = undefined;

    this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DERNull();
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "1.3.6.1.5.5.7.48.1.5";
    if (params != undefined) this.params = params;
};
extendClass(KJUR.asn1.x509.OCSPNoCheck, KJUR.asn1.x509.Extension);

// === END   OCSP Related ===================================================

// === BEGIN Other X.509v3 Extensions========================================

/**
 * AdobeTimeStamp X.509v3 extension ASN.1 encoder class<br/>
 * @name KJUR.asn1.x509.AdobeTimeStamp
 * @class AdobeTimeStamp X.509v3 extension ASN.1 encoder class
 * @extends KJUR.asn1.x509.Extension
 * @since jsrsasign 10.0.1 asn1x509 2.1.4
 * @param {Array} params JSON object for AdobeTimeStamp extension parameter
 * @see KJUR.asn1.x509.Extensions
 * @see X509#getExtAdobeTimeStamp
 * @description
 * This class represents
 * AdobeTimeStamp X.509v3 extension value defined in
 * <a href="https://www.adobe.com/devnet-docs/acrobatetk/tools/DigSigDC/oids.html">
 * Adobe site</a> as JSON object.
 * <pre>
 * adbe- OBJECT IDENTIFIER ::=  { adbe(1.2.840.113583) acrobat(1) security(1) x509Ext(9) 1 }
 *  ::= SEQUENCE {
 *     version INTEGER  { v1(1) }, -- extension version
 *     location GeneralName (In v1 GeneralName can be only uniformResourceIdentifier)
 *     requiresAuth        boolean (default false), OPTIONAL }
 * </pre>
 * Constructor of this class may have following parameters:
 * <ul>
 * <li>{String}uri - RFC 3161 time stamp service URL</li>
 * <li>{Boolean}reqauth - authentication required or not</li>
 * </ul>
 * </pre>
 * <br/>
 * NOTE: This extesion doesn't seem to have official name. This may be called as "pdfTimeStamp".
 * @example
 * new KJUR.asn1.x509.AdobeTimesStamp({
 *   uri: "http://tsa.example.com/",
 *   reqauth: true
 * }
 */
KJUR.asn1.x509.AdobeTimeStamp = function(params) {
    KJUR.asn1.x509.AdobeTimeStamp.superclass.constructor.call(this, params);

    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERBoolean = _KJUR_asn1.DERBoolean,
	_DERSequence = _KJUR_asn1.DERSequence,
	_GeneralName = _KJUR_asn1.x509.GeneralName;

    this.params = null;

    this.getExtnValueHex = function() {
	var params = this.params;
	var a = [new _DERInteger(1)];
	a.push(new _GeneralName({uri: params.uri}));
	if (params.reqauth != undefined) {
	    a.push(new _DERBoolean(params.reqauth));
	}

        this.asn1ExtnValue = new _DERSequence({array: a});
        return this.asn1ExtnValue.tohex();
    };

    this.oid = "1.2.840.113583.1.1.9.1";
    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.x509.AdobeTimeStamp, KJUR.asn1.x509.Extension);
 
// === END   Other X.509v3 Extensions========================================


// === BEGIN X500Name Related =================================================
/**
 * X500Name ASN.1 structure class
 * @name KJUR.asn1.x509.X500Name
 * @class X500Name ASN.1 structure class
 * @param {Array} params associative array of parameters (ex. {'str': '/C=US/O=a'})
 * @extends KJUR.asn1.ASN1Object
 * @see KJUR.asn1.x509.X500Name
 * @see KJUR.asn1.x509.RDN
 * @see KJUR.asn1.x509.AttributeTypeAndValue
 * @see X509#getX500Name
 * @description
 * This class provides DistinguishedName ASN.1 class structure
 * defined in <a href="https://tools.ietf.org/html/rfc2253#section-2">RFC 2253 section 2</a>.
 * <blockquote><pre>
 * DistinguishedName ::= RDNSequence
 * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 * RelativeDistinguishedName ::= SET SIZE (1..MAX) OF
 *   AttributeTypeAndValue
 * AttributeTypeAndValue ::= SEQUENCE {
 *   type  AttributeType,
 *   value AttributeValue }
 * </pre></blockquote>
 * <br/>
 * Argument for the constructor can be one of following parameters:
 * <ul>
 * <li>{Array}array - array of {@link KJUR.asn1.x509.RDN} parameter</li>
 * <li>`String}str - string for distingish name in OpenSSL One line foramt (ex: /C=US/O=test/CN=test) See <a href="https://github.com/kjur/jsrsasign/wiki/NOTE-distinguished-name-representation-in-jsrsasign">this</a> in detail.</li>
 * <li>{String}ldapstr - string for distinguish name in LDAP format (ex: CN=test,O=test,C=US)</li>
 * <li>{String}hex - hexadecimal string for ASN.1 distinguish name structure</li>
 * <li>{String}certissuer - issuer name in the specified PEM certificate</li>
 * <li>{String}certsubject - subject name in the specified PEM certificate</li>
 * <li>{String}rule - DirectoryString rule (ex. "prn" or "utf8")</li>
 * </ul>
 * <br/>
 * NOTE1: The "array" and "rule" parameters have been supported
 * since jsrsasign 9.0.0 asn1x509 2.0.0.
 * <br/>
 * NOTE2: Multi-valued RDN in "str" parameter have been
 * supported since jsrsasign 6.2.1 asn1x509 1.0.17.
 * @example
 * // 1. construct with array
 * new KJUR.asn1.x509.X500Name({array:[
 *   [{type:'C',value:'JP',ds:'prn'}],
 *   [{type:'O',value:'aaa',ds:'utf8'}, // multi-valued RDN
 *    {type:'CN',value:'bob@example.com',ds:'ia5'}]
 * ]})
 * // 2. construct with string
 * new KJUR.asn1.x509.X500Name({str: "/C=US/ST=NY/L=Ballston Spa/STREET=915 Stillwater Ave"});
 * new KJUR.asn1.x509.X500Name({str: "/CN=AAA/2.5.4.42=John/surname=Ray"});
 * new KJUR.asn1.x509.X500Name({str: "/C=US/O=aaa+CN=contact@example.com"}); // multi valued
 * // 3. construct by LDAP string
 * new KJUR.asn1.x509.X500Name({ldapstr: "CN=foo@example.com,OU=bbb,C=US"});
 * // 4. construct by ASN.1 hex string
 * new KJUR.asn1.x509.X500Name({hex: "304c3120..."});
 * // 5. construct by issuer of PEM certificate
 * new KJUR.asn1.x509.X500Name({certsubject: "-----BEGIN CERT..."});
 * // 6. construct by subject of PEM certificate
 * new KJUR.asn1.x509.X500Name({certissuer: "-----BEGIN CERT..."});
 * // 7. construct by object (DEPRECATED)
 * new KJUR.asn1.x509.X500Name({C:"US",O:"aaa",CN:"http://example.com/"});
 */
KJUR.asn1.x509.X500Name = function(params) {
    KJUR.asn1.x509.X500Name.superclass.constructor.call(this);
    this.asn1Array = [];
    this.paramArray = [];
    this.sRule = "utf8";
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_RDN = _KJUR_asn1_x509.RDN,
	_pemtohex = pemtohex;

    /**
     * set DN by OpenSSL oneline distinguished name string<br/>
     * @name setByString
     * @memberOf KJUR.asn1.x509.X500Name#
     * @function
     * @param {String} dnStr distinguished name by string (ex. /C=US/O=aaa)
     * @description
     * Sets distinguished name by string. 
     * dnStr must be formatted as 
     * "/type0=value0/type1=value1/type2=value2...".
     * No need to escape a slash in an attribute value.
     * @example
     * name = new KJUR.asn1.x509.X500Name();
     * name.setByString("/C=US/O=aaa/OU=bbb/CN=foo@example.com");
     * // no need to escape slash in an attribute value
     * name.setByString("/C=US/O=aaa/CN=1980/12/31");
     */
    this.setByString = function(dnStr, sRule) {
	if (sRule !== undefined) this.sRule = sRule;
        var a = dnStr.split('/');
        a.shift();

	var a1 = [];
	for (var i = 0; i < a.length; i++) {
	  if (a[i].match(/^[^=]+=.+$/)) {
	    a1.push(a[i]);
	  } else {
	    var lastidx = a1.length - 1;
	    a1[lastidx] = a1[lastidx] + "/" + a[i];
	  }
	}

        for (var i = 0; i < a1.length; i++) {
            this.asn1Array.push(new _RDN({'str':a1[i], rule:this.sRule}));
        }
    };

    /**
     * set DN by LDAP(RFC 2253) distinguished name string<br/>
     * @name setByLdapString
     * @memberOf KJUR.asn1.x509.X500Name#
     * @function
     * @param {String} dnStr distinguished name by LDAP string (ex. O=aaa,C=US)
     * @since jsrsasign 6.2.2 asn1x509 1.0.18
     * @see {@link KJUR.asn1.x509.X500Name.ldapToCompat}
     * @description
     * @example
     * name = new KJUR.asn1.x509.X500Name();
     * name.setByLdapString("CN=foo@example.com,OU=bbb,O=aaa,C=US");
     */
    this.setByLdapString = function(dnStr, sRule) {
	if (sRule !== undefined) this.sRule = sRule;
	var compat = _KJUR_asn1_x509.X500Name.ldapToCompat(dnStr);
	this.setByString(compat, sRule);
    };

    /**
     * set DN by associative array<br/>
     * @name setByObject
     * @memberOf KJUR.asn1.x509.X500Name#
     * @function
     * @param {Array} dnObj associative array of DN (ex. {C: "US", O: "aaa"})
     * @since jsrsasign 4.9. asn1x509 1.0.13
     * @description
     * @example
     * name = new KJUR.asn1.x509.X500Name();
     * name.setByObject({C: "US", O: "aaa", CN="http://example.com/"1});
     */
    this.setByObject = function(dnObj, sRule) {
	if (sRule !== undefined) this.sRule = sRule;

        // Get all the dnObject attributes and stuff them in the ASN.1 array.
        for (var x in dnObj) {
            if (dnObj.hasOwnProperty(x)) {
                var newRDN = new _RDN({str: x + '=' + dnObj[x], rule: this.sRule});
                // Initialize or push into the ANS1 array.
                this.asn1Array ? this.asn1Array.push(newRDN)
                    : this.asn1Array = [newRDN];
            }
        }
    };

    this.setByParam = function(params) {
	if (params.rule !== undefined) this.sRule = params.rule;

	if (params.array !== undefined) {
	    this.paramArray = params.array;
	} else {
            if (params.str !== undefined) {
		this.setByString(params.str);
            } else if (params.ldapstr !== undefined) {
		this.setByLdapString(params.ldapstr);
	    } else if (params.hex !== undefined) {
		this.hTLV = params.hex;
            } else if (params.certissuer !== undefined) {
		var x = new X509();
		x.readCertPEM(params.certissuer);
		this.hTLV = x.getIssuerHex();
            } else if (params.certsubject !== undefined) {
		var x = new X509();
		x.readCertPEM(params.certsubject);
		this.hTLV = x.getSubjectHex();
		// If params is an object, then set the ASN1 array
		// just using the object attributes. 
		// This is nice for fields that have lots of special
		// characters (i.e. CN: 'https://www.github.com/kjur//').
            } else if (typeof params === "object" &&
		       params.certsubject === undefined &&
		       params.certissuer === undefined) {
		this.setByObject(params);
            }
	}
    }

    this.tohex = function() {
        if (typeof this.hTLV == "string") return this.hTLV;

	if (this.asn1Array.length == 0 && this.paramArray.length > 0) {
	    for (var i = 0; i < this.paramArray.length; i++) {
		var param = {array: this.paramArray[i]};
		if (this.sRule != "utf8") param.rule = this.sRule;
		var asn1RDN = new _RDN(param);
		this.asn1Array.push(asn1RDN);
	    }
	}

        var o = new _KJUR_asn1.DERSequence({"array": this.asn1Array});
        this.hTLV = o.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.x509.X500Name, KJUR.asn1.ASN1Object);

/**
 * convert OpenSSL compat distinguished name format string to LDAP(RFC 2253) format<br/>
 * @name compatToLDAP
 * @memberOf KJUR.asn1.x509.X500Name
 * @function
 * @param {String} s distinguished name string in OpenSSL oneline compat (ex. /C=US/O=test)
 * @return {String} distinguished name string in LDAP(RFC 2253) format (ex. O=test,C=US)
 * @since jsrsasign 8.0.19 asn1x509 1.1.20
 * @description
 * This static method converts a distinguished name string in OpenSSL compat
 * format to LDAP(RFC 2253) format.
 * @see <a href="https://github.com/kjur/jsrsasign/wiki/NOTE-distinguished-name-representation-in-jsrsasign">jsrsasign wiki: distinguished name string difference between OpenSSL compat and LDAP(RFC 2253)</a>
 * @see <a href="https://www.openssl.org/docs/man1.0.2/man1/openssl-x509.html#NAME-OPTIONS">OpenSSL x509 command manual - NAME OPTIONS</a>
 * @example
 * KJUR.asn1.x509.X500Name.compatToLDAP("/C=US/O=test") &rarr; 'O=test,C=US'
 * KJUR.asn1.x509.X500Name.compatToLDAP("/C=US/O=a,a") &rarr; 'O=a\,a,C=US'
 */
KJUR.asn1.x509.X500Name.compatToLDAP = function(s) {
    if (s.substr(0, 1) !== "/") throw "malformed input";

    var result = "";
    s = s.substr(1);

    var a = s.split("/");
    a.reverse();
    a = a.map(function(s) {return s.replace(/,/, "\\,")});

    return a.join(",");
};

/**
 * convert OpenSSL compat distinguished name format string to LDAP(RFC 2253) format (DEPRECATED)<br/>
 * @name onelineToLDAP
 * @memberOf KJUR.asn1.x509.X500Name
 * @function
 * @param {String} s distinguished name string in OpenSSL compat format (ex. /C=US/O=test)
 * @return {String} distinguished name string in LDAP(RFC 2253) format (ex. O=test,C=US)
 * @since jsrsasign 6.2.2 asn1x509 1.0.18
 * @see KJUR.asn1.x509.X500Name.compatToLDAP
 * @description
 * This method is deprecated. Please use 
 * {@link KJUR.asn1.x509.X500Name.compatToLDAP} instead.
 */
KJUR.asn1.x509.X500Name.onelineToLDAP = function(s) {
    return KJUR.asn1.x509.X500Name.compatToLDAP(s);
}

/**
 * convert LDAP(RFC 2253) distinguished name format string to OpenSSL compat format<br/>
 * @name ldapToCompat
 * @memberOf KJUR.asn1.x509.X500Name
 * @function
 * @param {String} s distinguished name string in LDAP(RFC 2253) format (ex. O=test,C=US)
 * @return {String} distinguished name string in OpenSSL compat format (ex. /C=US/O=test)
 * @since jsrsasign 8.0.19 asn1x509 1.1.10
 * @description
 * This static method converts a distinguished name string in 
 * LDAP(RFC 2253) format to OpenSSL compat format.
 * @see <a href="https://github.com/kjur/jsrsasign/wiki/NOTE-distinguished-name-representation-in-jsrsasign">jsrsasign wiki: distinguished name string difference between OpenSSL compat and LDAP(RFC 2253)</a>
 * @example
 * KJUR.asn1.x509.X500Name.ldapToCompat('O=test,C=US') &rarr; '/C=US/O=test'
 * KJUR.asn1.x509.X500Name.ldapToCompat('O=a\,a,C=US') &rarr; '/C=US/O=a,a'
 * KJUR.asn1.x509.X500Name.ldapToCompat('O=a/a,C=US')  &rarr; '/C=US/O=a\/a'
 */
KJUR.asn1.x509.X500Name.ldapToCompat = function(s) {
    var a = s.split(",");

    // join \,
    var isBSbefore = false;
    var a2 = [];
    for (var i = 0; a.length > 0; i++) {
	var item = a.shift();
	//console.log("item=" + item);

	if (isBSbefore === true) {
	    var a2last = a2.pop();
	    var newitem = (a2last + "," + item).replace(/\\,/g, ",");
	    a2.push(newitem);
	    isBSbefore = false;
	} else {
	    a2.push(item);
	}

	if (item.substr(-1, 1) === "\\") isBSbefore = true;
    }

    a2 = a2.map(function(s) {return s.replace("/", "\\/")});
    a2.reverse();
    return "/" + a2.join("/");
};

/**
 * convert LDAP(RFC 2253) distinguished name format string to OpenSSL compat format (DEPRECATED)<br/>
 * @name ldapToOneline
 * @memberOf KJUR.asn1.x509.X500Name
 * @function
 * @param {String} s distinguished name string in LDAP(RFC 2253) format (ex. O=test,C=US)
 * @return {String} distinguished name string in OpenSSL compat format (ex. /C=US/O=test)
 * @since jsrsasign 6.2.2 asn1x509 1.0.18
 * @description
 * This method is deprecated. Please use 
 * {@link KJUR.asn1.x509.X500Name.ldapToCompat} instead.
 */
KJUR.asn1.x509.X500Name.ldapToOneline = function(s) {
    return KJUR.asn1.x509.X500Name.ldapToCompat(s);
};

/**
 * RDN (Relative Distinguished Name) ASN.1 structure class
 * @name KJUR.asn1.x509.RDN
 * @class RDN (Relative Distinguished Name) ASN.1 structure class
 * @param {Array} params associative array of parameters (ex. {'str': 'C=US'})
 * @extends KJUR.asn1.ASN1Object
 * @see KJUR.asn1.x509.X500Name
 * @see KJUR.asn1.x509.RDN
 * @see KJUR.asn1.x509.AttributeTypeAndValue
 * @description
 * This class provides RelativeDistinguishedName ASN.1 class structure
 * defined in <a href="https://tools.ietf.org/html/rfc2253#section-2">RFC 2253 section 2</a>.
 * <blockquote><pre>
 * RelativeDistinguishedName ::= SET SIZE (1..MAX) OF
 *   AttributeTypeAndValue
 *
 * AttributeTypeAndValue ::= SEQUENCE {
 *   type  AttributeType,
 *   value AttributeValue }
 * </pre></blockquote>
 * <br/>
 * NOTE1: The "array" and "rule" parameters have been supported
 * since jsrsasign 9.0.0 asn1x509 2.0.0.
 * <br/>
 * NOTE2: Multi-valued RDN in "str" parameter have been
 * supported since jsrsasign 6.2.1 asn1x509 1.0.17.
 * @example
 * new KJUR.asn1.x509.RDN({array: [ // multi-valued
 *    {type:"CN",value:"Bob",ds:"prn"},
 *    {type:"CN",value:"bob@example.com", ds:"ia5"}
 * ]});
 * new KJUR.asn1.x509.RDN({str: "CN=test"});
 * new KJUR.asn1.x509.RDN({str: "O=a+O=bb+O=c"}); // multi-valued
 * new KJUR.asn1.x509.RDN({str: "O=a+O=b\\+b+O=c"}); // plus escaped
 * new KJUR.asn1.x509.RDN({str: "O=a+O=\"b+b\"+O=c"}); // double quoted
 */
KJUR.asn1.x509.RDN = function(params) {
    KJUR.asn1.x509.RDN.superclass.constructor.call(this);
    this.asn1Array = [];
    this.paramArray = [];
    this.sRule = "utf8"; // DEFAULT "utf8"
    var _AttributeTypeAndValue = KJUR.asn1.x509.AttributeTypeAndValue;

    this.setByParam = function(params) {
	if (params.rule !== undefined) this.sRule = params.rule;
        if (params.str !== undefined) {
            this.addByMultiValuedString(params.str);
        }
	if (params.array !== undefined) this.paramArray = params.array;
    };

    /**
     * add one AttributeTypeAndValue by string<br/>
     * @name addByString
     * @memberOf KJUR.asn1.x509.RDN#
     * @function
     * @param {String} s string of AttributeTypeAndValue
     * @return {Object} unspecified
     * @description
     * This method add one AttributeTypeAndValue to RDN object.
     * @example
     * rdn = new KJUR.asn1.x509.RDN();
     * rdn.addByString("CN=john");
     * rdn.addByString("serialNumber=1234"); // for multi-valued RDN
     */
    this.addByString = function(s) {
        this.asn1Array.push(new KJUR.asn1.x509.AttributeTypeAndValue({'str': s, rule: this.sRule}));
    };

    /**
     * add one AttributeTypeAndValue by multi-valued string<br/>
     * @name addByMultiValuedString
     * @memberOf KJUR.asn1.x509.RDN#
     * @function
     * @param {String} s string of multi-valued RDN
     * @return {Object} unspecified
     * @since jsrsasign 6.2.1 asn1x509 1.0.17
     * @description
     * This method add multi-valued RDN to RDN object.
     * @example
     * rdn = new KJUR.asn1.x509.RDN();
     * rdn.addByMultiValuedString("CN=john+O=test");
     * rdn.addByMultiValuedString("O=a+O=b\+b\+b+O=c"); // multi-valued RDN with quoted plus
     * rdn.addByMultiValuedString("O=a+O=\"b+b+b\"+O=c"); // multi-valued RDN with quoted quotation
     */
    this.addByMultiValuedString = function(s) {
	var a = KJUR.asn1.x509.RDN.parseString(s);
	for (var i = 0; i < a.length; i++) {
	    this.addByString(a[i]);
	}
    };

    this.tohex = function() {
	if (this.asn1Array.length == 0 && this.paramArray.length > 0) {
	    for (var i = 0; i < this.paramArray.length; i++) {
		var param = this.paramArray[i];
		if (param.rule !== undefined &&
		    this.sRule != "utf8") {
		    param.rule = this.sRule;
		}
		//alert(JSON.stringify(param));
		var asn1ATV = new _AttributeTypeAndValue(param);
		this.asn1Array.push(asn1ATV);
	    }
	}
        var o = new KJUR.asn1.DERSet({"array": this.asn1Array});
        this.TLV = o.tohex();
        return this.TLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
	this.setByParam(params);
    }
};
extendClass(KJUR.asn1.x509.RDN, KJUR.asn1.ASN1Object);

/**
 * parse multi-valued RDN string and split into array of 'AttributeTypeAndValue'<br/>
 * @name parseString
 * @memberOf KJUR.asn1.x509.RDN
 * @function
 * @param {String} s multi-valued string of RDN
 * @return {Array} array of string of AttributeTypeAndValue
 * @since jsrsasign 6.2.1 asn1x509 1.0.17
 * @description
 * This static method parses multi-valued RDN string and split into
 * array of AttributeTypeAndValue.
 * @example
 * KJUR.asn1.x509.RDN.parseString("CN=john") &rarr; ["CN=john"]
 * KJUR.asn1.x509.RDN.parseString("CN=john+OU=test") &rarr; ["CN=john", "OU=test"]
 * KJUR.asn1.x509.RDN.parseString('CN="jo+hn"+OU=test') &rarr; ["CN=jo+hn", "OU=test"]
 * KJUR.asn1.x509.RDN.parseString('CN=jo\+hn+OU=test') &rarr; ["CN=jo+hn", "OU=test"]
 * KJUR.asn1.x509.RDN.parseString("CN=john+OU=test+OU=t1") &rarr; ["CN=john", "OU=test", "OU=t1"]
 */
KJUR.asn1.x509.RDN.parseString = function(s) {
    var a = s.split(/\+/);

    // join \+
    var isBSbefore = false;
    var a2 = [];
    for (var i = 0; a.length > 0; i++) {
	var item = a.shift();
	//console.log("item=" + item);

	if (isBSbefore === true) {
	    var a2last = a2.pop();
	    var newitem = (a2last + "+" + item).replace(/\\\+/g, "+");
	    a2.push(newitem);
	    isBSbefore = false;
	} else {
	    a2.push(item);
	}

	if (item.substr(-1, 1) === "\\") isBSbefore = true;
    }

    // join quote
    var beginQuote = false;
    var a3 = [];
    for (var i = 0; a2.length > 0; i++) {
	var item = a2.shift();

	if (beginQuote === true) {
	    var a3last = a3.pop();
	    if (item.match(/"$/)) {
		var newitem = (a3last + "+" + item).replace(/^([^=]+)="(.*)"$/, "$1=$2");
		a3.push(newitem);
		beginQuote = false;
	    } else {
		a3.push(a3last + "+" + item);
	    }
	} else {
	    a3.push(item);
	}

	if (item.match(/^[^=]+="/)) {
	    //console.log(i + "=" + item);
	    beginQuote = true;
	}
    }
    return a3;
};

/**
 * AttributeTypeAndValue ASN.1 structure class
 * @name KJUR.asn1.x509.AttributeTypeAndValue
 * @class AttributeTypeAndValue ASN.1 structure class
 * @param {Array} params JSON object for parameters (ex. {str: 'C=US'})
 * @extends KJUR.asn1.ASN1Object
 * @see KJUR.asn1.x509.X500Name
 * @see KJUR.asn1.x509.RDN
 * @see KJUR.asn1.x509.AttributeTypeAndValue
 * @see X509#getAttrTypeAndValue
 * @description
 * This class generates AttributeTypeAndValue defined in
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.4">
 * RFC 5280 4.1.2.4</a>.
 * <pre>
 * AttributeTypeAndValue ::= SEQUENCE {
 *   type     AttributeType,
 *   value    AttributeValue }
 * AttributeType ::= OBJECT IDENTIFIER
 * AttributeValue ::= ANY -- DEFINED BY AttributeType
 * </pre>
 * The constructor argument can have following parameters:
 * <ul>
 * <li>{String}type - AttributeType name or OID(ex. C,O,CN)</li>
 * <li>{String}value - raw string of ASN.1 value of AttributeValue</li>
 * <li>{String}ds - DirectoryString type of AttributeValue</li>
 * <li>{String}rule - DirectoryString type rule (ex. "prn" or "utf8")
 * set DirectoryString type automatically when "ds" not specified.</li>
 * <li>{String}str - AttributeTypeAndVale string (ex. "C=US").
 * When type and value don't exists, 
 * this "str" will be converted to "type" and "value".
 * </li>
 * </ul>
 * <br
 * NOTE: Parameters "type", "value,", "ds" and "rule" have
 * been supported since jsrsasign 9.0.0 asn1x509 2.0.0.
 * @example
 * new KJUR.asn1.x509.AttributeTypeAndValue({type:'C',value:'US',ds:'prn'})
 * new KJUR.asn1.x509.AttributeTypeAndValue({type:'givenName',value:'John',ds:'prn'})
 * new KJUR.asn1.x509.AttributeTypeAndValue({type:'2.5.4.9',value:'71 Bowman St',ds:'prn'})
 * new KJUR.asn1.x509.AttributeTypeAndValue({str:'O=T1'})
 * new KJUR.asn1.x509.AttributeTypeAndValue({str:'streetAddress=71 Bowman St'})
 * new KJUR.asn1.x509.AttributeTypeAndValue({str:'O=T1',rule='prn'})
 * new KJUR.asn1.x509.AttributeTypeAndValue({str:'O=T1',rule='utf8'})
 */
KJUR.asn1.x509.AttributeTypeAndValue = function(params) {
    KJUR.asn1.x509.AttributeTypeAndValue.superclass.constructor.call(this);
    this.sRule = "utf8";
    this.sType = null;
    this.sValue = null;
    this.dsType = null;
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERUTF8String = _KJUR_asn1.DERUTF8String,
	_DERPrintableString = _KJUR_asn1.DERPrintableString,
	_DERTeletexString = _KJUR_asn1.DERTeletexString,
	_DERIA5String = _KJUR_asn1.DERIA5String,
	_DERVisibleString = _KJUR_asn1.DERVisibleString,
	_DERBMPString = _KJUR_asn1.DERBMPString,
        _DERBitString = _KJUR_asn1.DERBitString,
	_isMail = _KJUR.lang.String.isMail,
	_isPrintable = _KJUR.lang.String.isPrintable;

    this.setByParam = function(params) {
	if (params.rule !== undefined) this.sRule = params.rule;
	if (params.ds !== undefined)   this.dsType = params.ds;

        if (params.value === undefined &&
	    params.str !== undefined) {
	    var str = params.str;
            var matchResult = str.match(/^([^=]+)=(.+)$/);
            if (matchResult) {
		this.sType = matchResult[1];
		this.sValue = matchResult[2];
            } else {
		throw new Error("malformed attrTypeAndValueStr: " +
				attrTypeAndValueStr);
            }
	    
	    //this.setByString(params.str);
        } else {
	    this.sType = params.type;
	    this.sValue = params.value;
	}
    };

    /*
     * @deprecated
     */
    this.setByString = function(sTypeValue, sRule) {
	if (sRule !== undefined) this.sRule = sRule;
        var matchResult = sTypeValue.match(/^([^=]+)=(.+)$/);
        if (matchResult) {
            this.setByAttrTypeAndValueStr(matchResult[1], matchResult[2]);
        } else {
            throw new Error("malformed attrTypeAndValueStr: " +
			    attrTypeAndValueStr);
        }
    };

    this._getDsType = function() {
	var sType = this.sType;
	var sValue = this.sValue;
	var sRule = this.sRule;

	if (sRule === "prn") {
	    if (sType == "CN" && _isMail(sValue)) return "ia5";
	    if (_isPrintable(sValue)) return "prn";
	    return "utf8";
	} else if (sRule === "utf8") {
	    if (sType == "CN" && _isMail(sValue)) return "ia5";
	    if (sType == "C") return "prn";
	    return "utf8";
	}
	return "utf8"; // default
    };

    this.setByAttrTypeAndValueStr = function(sType, sValue, sRule) {
	if (sRule !== undefined) this.sRule = sRule;
	this.sType = sType;
	this.sValue = sValue;
    };

    this.getValueObj = function(dsType, valueStr) {
        if (dsType == "utf8") return new _DERUTF8String({"str": valueStr});
        if (dsType == "prn")  return new _DERPrintableString({"str": valueStr});
        if (dsType == "tel")  return new _DERTeletexString({"str": valueStr});
        if (dsType == "ia5")  return new _DERIA5String({"str": valueStr});
        if (dsType == "vis")  return new _DERVisibleString({"str": valueStr});
        if (dsType == "bmp")  return new _DERBMPString({"str": valueStr});
        if (dsType == "bit")  return new _DERBitString({"hex": valueStr});
        throw new Error("unsupported directory string type: type=" +
			dsType + " value=" + valueStr);
    };

    this.tohex = function() {
	if (this.dsType == null) this.dsType = this._getDsType();
	var asn1Type = KJUR.asn1.x509.OID.atype2obj(this.sType);
	var asn1Value = this.getValueObj(this.dsType, this.sValue);
        var o = new _DERSequence({"array": [asn1Type, asn1Value]});
        this.TLV = o.tohex();
        return this.TLV;
    }

    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
	this.setByParam(params);
    }
};
extendClass(KJUR.asn1.x509.AttributeTypeAndValue, KJUR.asn1.ASN1Object);

// === END   X500Name Related =================================================

// === BEGIN Other ASN1 structure class  ======================================

/**
 * SubjectPublicKeyInfo ASN.1 structure class
 * @name KJUR.asn1.x509.SubjectPublicKeyInfo
 * @class SubjectPublicKeyInfo ASN.1 structure class
 * @param {Object} params parameter for subject public key
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>{@link RSAKey} object</li>
 * <li>{@link KJUR.crypto.ECDSA} object</li>
 * <li>{@link KJUR.crypto.DSA} object</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: DSA/ECDSA key object is also supported since asn1x509 1.0.6.<br/>
 * <h4>EXAMPLE</h4>
 * @example
 * spki = new KJUR.asn1.x509.SubjectPublicKeyInfo(RSAKey_object);
 * spki = new KJUR.asn1.x509.SubjectPublicKeyInfo(KJURcryptoECDSA_object);
 * spki = new KJUR.asn1.x509.SubjectPublicKeyInfo(KJURcryptoDSA_object);
 */
KJUR.asn1.x509.SubjectPublicKeyInfo = function(params) {
    KJUR.asn1.x509.SubjectPublicKeyInfo.superclass.constructor.call(this);
    var asn1AlgId = null,
	asn1SubjPKey = null,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERBitString = _KJUR_asn1.DERBitString,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_DERSequence = _KJUR_asn1.DERSequence,
	_newObject = _KJUR_asn1.ASN1Util.newObject,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_AlgorithmIdentifier = _KJUR_asn1_x509.AlgorithmIdentifier,
	_KJUR_crypto = _KJUR.crypto,
	_KJUR_crypto_ECDSA = _KJUR_crypto.ECDSA,
	_KJUR_crypto_DSA = _KJUR_crypto.DSA;

    /*
     * @since asn1x509 1.0.7
     */
    this.getASN1Object = function() {
        if (this.asn1AlgId == null || this.asn1SubjPKey == null)
            throw "algId and/or subjPubKey not set";
        var o = new _DERSequence({'array':
                                  [this.asn1AlgId, this.asn1SubjPKey]});
        return o;
    };

    this.tohex = function() {
        var o = this.getASN1Object();
        this.hTLV = o.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    /**
     * @name setPubKey
     * @memberOf KJUR.asn1.x509.SubjectPublicKeyInfo#
     * @function
     * @param {Object} {@link RSAKey}, {@link KJUR.crypto.ECDSA} or {@link KJUR.crypto.DSA} object
     * @since jsrsasign 8.0.0 asn1x509 1.1.0
     * @description
     * @example
     * spki = new KJUR.asn1.x509.SubjectPublicKeyInfo();
     * pubKey = KEYUTIL.getKey(PKCS8PUBKEYPEM);
     * spki.setPubKey(pubKey);
     */
    this.setPubKey = function(key) {
	try {
	    if (key instanceof RSAKey) {
		var asn1RsaPub = _newObject({
		    'seq': [{'int': {'bigint': key.n}}, {'int': {'int': key.e}}]
		});
		var rsaKeyHex = asn1RsaPub.tohex();
		this.asn1AlgId = new _AlgorithmIdentifier({'name':'rsaEncryption'});
		this.asn1SubjPKey = new _DERBitString({'hex':'00'+rsaKeyHex});
	    }
	} catch(ex) {};

	try {
	    if (key instanceof KJUR.crypto.ECDSA) {
		var asn1Params = new _DERObjectIdentifier({'name': key.curveName});
		this.asn1AlgId =
		    new _AlgorithmIdentifier({'name': 'ecPublicKey',
					      'asn1params': asn1Params});
		this.asn1SubjPKey = new _DERBitString({'hex': '00' + key.pubKeyHex});
	    }
	} catch(ex) {};

	try {
	    if (key instanceof KJUR.crypto.DSA) {
		var asn1Params = new _newObject({
		    'seq': [{'int': {'bigint': key.p}},
			    {'int': {'bigint': key.q}},
			    {'int': {'bigint': key.g}}]
		});
		this.asn1AlgId =
		    new _AlgorithmIdentifier({'name': 'dsa',
					      'asn1params': asn1Params});
		var pubInt = new _DERInteger({'bigint': key.y});
		this.asn1SubjPKey = 
		    new _DERBitString({'hex': '00' + pubInt.tohex()});
	    }
	} catch(ex) {};
    };

    if (params !== undefined) {
	this.setPubKey(params);
    }
};
extendClass(KJUR.asn1.x509.SubjectPublicKeyInfo, KJUR.asn1.ASN1Object);

/**
 * Time ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.Time
 * @class Time ASN.1 structure class
 * @param {Array} params associative array of parameters (ex. {'str': '130508235959Z'})
 * @extends KJUR.asn1.ASN1Object
 * @see KJUR.asn1.DERUTCTime
 * @see KJUR.asn1.DERGeneralizedTime
 * @description
 * This class represents Time ASN.1 structure defined in 
 * <a href="https://tools.ietf.org/html/rfc5280">RFC 5280</a>
 * <pre>
 * Time ::= CHOICE {
 *      utcTime        UTCTime,
 *      generalTime    GeneralizedTime }
 * </pre>
 *
 * @example
 * var t1 = new KJUR.asn1.x509.Time{'str': '130508235959Z'} // UTCTime by default
 * var t2 = new KJUR.asn1.x509.Time{'type': 'gen',  'str': '20130508235959Z'} // GeneralizedTime
 */
KJUR.asn1.x509.Time = function(params) {
    KJUR.asn1.x509.Time.superclass.constructor.call(this);
    var type = null,
	timeParams = null,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERUTCTime = _KJUR_asn1.DERUTCTime,
	_DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime;
    this.params = null;
    this.type = null;

    // deprecated
    this.setTimeParams = function(timeParams) {
        this.timeParams = timeParams;
    }

    this.setByParam = function(params) {
	this.params = params;
    };

    this.getType = function(s) {
        if (s.match(/^[0-9]{12}Z$/)) return "utc";
        if (s.match(/^[0-9]{14}Z$/)) return "gen";
        if (s.match(/^[0-9]{12}\.[0-9]+Z$/)) return "utc";
        if (s.match(/^[0-9]{14}\.[0-9]+Z$/)) return "gen";
	return null;
    };

    this.tohex = function() {
	var params = this.params;
        var o = null;

	if (typeof params == "string") params = {str: params};
	if (params != null &&
	    params.str && 
	    (params.type == null || params.type == undefined)) {
	    params.type = this.getType(params.str);
	}

	if (params != null && params.str) {
	    if (params.type == "utc") o = new _DERUTCTime(params.str);
	    if (params.type == "gen") o = new _DERGeneralizedTime(params.str);
	} else {
	    if (this.type == "gen") {
		o = new _DERGeneralizedTime();
	    } else {
		o = new _DERUTCTime();
	    }
	}

	if (o == null) throw new Error("wrong setting for Time");
        this.TLV = o.tohex();
        return this.TLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};

KJUR.asn1.x509.Time_bak = function(params) {
    KJUR.asn1.x509.Time_bak.superclass.constructor.call(this);
    var type = null,
	timeParams = null,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERUTCTime = _KJUR_asn1.DERUTCTime,
	_DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime;

    this.setTimeParams = function(timeParams) {
        this.timeParams = timeParams;
    }

    this.tohex = function() {
        var o = null;

        if (this.timeParams != null) {
            if (this.type == "utc") {
                o = new _DERUTCTime(this.timeParams);
            } else {
                o = new _DERGeneralizedTime(this.timeParams);
            }
        } else {
            if (this.type == "utc") {
                o = new _DERUTCTime();
            } else {
                o = new _DERGeneralizedTime();
            }
        }
        this.TLV = o.tohex();
        return this.TLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.type = "utc";
    if (params !== undefined) {
        if (params.type !== undefined) {
            this.type = params.type;
        } else {
            if (params.str !== undefined) {
                if (params.str.match(/^[0-9]{12}Z$/)) this.type = "utc";
                if (params.str.match(/^[0-9]{14}Z$/)) this.type = "gen";
            }
        }
        this.timeParams = params;
    }
};
extendClass(KJUR.asn1.x509.Time, KJUR.asn1.ASN1Object);

/**
 * AlgorithmIdentifier ASN.1 structure class
 * @name KJUR.asn1.x509.AlgorithmIdentifier
 * @class AlgorithmIdentifier ASN.1 structure class
 * @param {Array} params associative array of parameters (ex. {'name': 'SHA1withRSA'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * The 'params' argument is an associative array and has following parameters:
 * <ul>
 * <li>name: algorithm name (MANDATORY, ex. sha1, SHA256withRSA)</li>
 * <li>asn1params: explicitly specify ASN.1 object for algorithm.
 * (OPTION)</li>
 * <li>paramempty: set algorithm parameter to NULL by force.
 * If paramempty is false, algorithm parameter will be set automatically.
 * If paramempty is false and algorithm name is "*withDSA" or "withECDSA" parameter field of
 * AlgorithmIdentifier will be ommitted otherwise
 * it will be NULL by default.
 * (OPTION, DEFAULT = false)</li>
 * </ul>
 * RSA-PSS algorithm names such as SHA{,256,384,512}withRSAandMGF1 are
 * special names. They will set a suite of algorithm OID and multiple algorithm
 * parameters. Its ASN.1 schema is defined in 
 * <a href="https://tools.ietf.org/html/rfc3447#appendix-A.2.3">RFC 3447 PKCS#1 2.1
 * section A.2.3</a>.
 * <blockquote><pre>
 * id-RSASSA-PSS  OBJECT IDENTIFIER ::= { pkcs-1 10 }
 * RSASSA-PSS-params ::= SEQUENCE {
 *   hashAlgorithm      [0] HashAlgorithm    DEFAULT sha1,
 *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT mgf1SHA1,
 *   saltLength         [2] INTEGER          DEFAULT 20,
 *   trailerField       [3] TrailerField     DEFAULT trailerFieldBC }
 * mgf1SHA1    MaskGenAlgorithm ::= {
 *   algorithm   id-mgf1,
 *   parameters  HashAlgorithm : sha1 }
 * id-mgf1     OBJECT IDENTIFIER ::= { pkcs-1 8 }
 * TrailerField ::= INTEGER { trailerFieldBC(1) }
 * </pre></blockquote>
 * Here is a table for PSS parameters:
 * <table>
 * <tr><th>Name</th><th>alg oid</th><th>pss hash</th><th>maskgen</th></th><th>pss saltlen</th><th>trailer</th></tr>
 * <tr><td>SHAwithRSAandMGF1</td><td>1.2.840.113549.1.1.10(rsapss)</td><td>default(sha1)</td><td>default(mgf1sha1)</td><td>default(20)</td><td>default(1)</td></tr>
 * <tr><td>SHA256withRSAandMGF1</td><td>1.2.840.113549.1.1.10(rsapss)</td><td>sha256</td><td>mgf1sha256</td><td>32</td><td>default(1)</td></tr>
 * <tr><td>SHA384withRSAandMGF1</td><td>1.2.840.113549.1.1.10(rsapss)</td><td>sha384</td><td>mgf1sha384</td><td>48</td><td>default(1)</td></tr>
 * <tr><td>SHA512withRSAandMGF1</td><td>1.2.840.113549.1.1.10(rsapss)</td><td>sha512</td><td>mgf1sha512</td><td>64</td><td>default(1)</td></tr>
 * </table>
 * Default value is omitted as defined in ASN.1 schema.
 * These parameters are interoperable to OpenSSL or IAIK toolkit.
 * <br/>
 * NOTE: RSA-PSS algorihtm names are supported since jsrsasign 8.0.21. 
 * @example
 * new KJUR.asn1.x509.AlgorithmIdentifier({name: "sha1"})
 * new KJUR.asn1.x509.AlgorithmIdentifier({name: "SHA256withRSA"})
 * new KJUR.asn1.x509.AlgorithmIdentifier({name: "SHA512withRSAandMGF1"}) // set parameters automatically
 * new KJUR.asn1.x509.AlgorithmIdentifier({name: "SHA256withRSA", paramempty: true})
 * new KJUR.asn1.x509.AlgorithmIdentifier({name: "rsaEncryption"})
 */
KJUR.asn1.x509.AlgorithmIdentifier = function(params) {
    KJUR.asn1.x509.AlgorithmIdentifier.superclass.constructor.call(this);
    this.nameAlg = null;
    this.asn1Alg = null;
    this.asn1Params = null;
    this.paramEmpty = false;

    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_PSSNAME2ASN1TLV = _KJUR_asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;

    this.tohex = function() {
        if (this.nameAlg === null && this.asn1Alg === null) {
            throw new Error("algorithm not specified");
        }

	// for RSAPSS algorithm name
	//  && this.hTLV === null
	if (this.nameAlg !== null) {
	    var hTLV = null;
	    for (var key in _PSSNAME2ASN1TLV) {
		if (key === this.nameAlg) {
		    hTLV = _PSSNAME2ASN1TLV[key];
		}
	    }
	    if (hTLV !== null) {
		this.hTLV = hTLV;
		return this.hTLV;
	    }
	}

        if (this.nameAlg !== null && this.asn1Alg === null) {
            this.asn1Alg = _KJUR_asn1.x509.OID.name2obj(this.nameAlg);
        }
        var a = [this.asn1Alg];
        if (this.asn1Params !== null) a.push(this.asn1Params);

        var o = new _KJUR_asn1.DERSequence({'array': a});
        this.hTLV = o.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
        if (params.name !== undefined) {
            this.nameAlg = params.name;
        }
        if (params.asn1params !== undefined) {
            this.asn1Params = params.asn1params;
        }
        if (params.paramempty !== undefined) {
            this.paramEmpty = params.paramempty;
        }
    }

    // set algorithm parameters will be ommitted for
    // "*withDSA" or "*withECDSA" otherwise will be NULL.
    if (this.asn1Params === null &&
	this.paramEmpty === false &&
	this.nameAlg !== null) {

	if (this.nameAlg.name !== undefined) {
	    this.nameAlg = this.nameAlg.name;
	}
	var lcNameAlg = this.nameAlg.toLowerCase();

	if (lcNameAlg.substr(-7, 7) !== "withdsa" &&
	    lcNameAlg.substr(-9, 9) !== "withecdsa") {
            this.asn1Params = new _KJUR_asn1.DERNull();
	}
    }
};
extendClass(KJUR.asn1.x509.AlgorithmIdentifier, KJUR.asn1.ASN1Object);

/**
 * AlgorithmIdentifier ASN.1 TLV string associative array for RSA-PSS algorithm names
 * @const
 */
KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV = {
    "SHAwithRSAandMGF1":
    "300d06092a864886f70d01010a3000",
    "SHA256withRSAandMGF1":
    "303d06092a864886f70d01010a3030a00d300b0609608648016503040201a11a301806092a864886f70d010108300b0609608648016503040201a203020120",
    "SHA384withRSAandMGF1":
    "303d06092a864886f70d01010a3030a00d300b0609608648016503040202a11a301806092a864886f70d010108300b0609608648016503040202a203020130",
    "SHA512withRSAandMGF1":
    "303d06092a864886f70d01010a3030a00d300b0609608648016503040203a11a301806092a864886f70d010108300b0609608648016503040203a203020140"
};

/**
 * GeneralName ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.GeneralName
 * @class GeneralName ASN.1 structure class
 * @see KJUR.asn1.x509.OtherName
 * @see KJUR.asn1.x509.X500Name
 *
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>rfc822 - rfc822Name[1] (ex. user1@foo.com)</li>
 * <li>dns - dNSName[2] (ex. foo.com)</li>
 * <li>uri - uniformResourceIdentifier[6] (ex. http://foo.com/)</li>
 * <li>dn - directoryName[4] 
 * distinguished name string or X500Name class parameters can be
 * specified (ex. "/C=US/O=Test", {hex: '301c...')</li>
 * <li>ldapdn - directoryName[4] (ex. O=Test,C=US)</li>
 * <li>certissuer - directoryName[4] (PEM or hex string of cert)</li>
 * <li>certsubj - directoryName[4] (PEM or hex string of cert)</li>
 * <li>ip - iPAddress[7] (ex. 192.168.1.1, 2001:db3::43, 3faa0101...)</li>
 * </ul>
 * NOTE1: certissuer and certsubj were supported since asn1x509 1.0.10.<br/>
 * NOTE2: dn and ldapdn were supported since jsrsasign 6.2.3 asn1x509 1.0.19.<br/>
 * NOTE3: ip were supported since jsrsasign 8.0.10 asn1x509 1.1.4.<br/>
 * NOTE4: X500Name parameters in dn were supported since jsrsasign 8.0.16.<br/>
 * NOTE5: otherName is supported since jsrsasign 10.5.3.<br/>
 *
 * Here is definition of the ASN.1 syntax:
 * <pre>
 * -- NOTE: under the CHOICE, it will always be explicit.
 * GeneralName ::= CHOICE {
 *   otherName                  [0] OtherName,
 *   rfc822Name                 [1] IA5String,
 *   dNSName                    [2] IA5String,
 *   x400Address                [3] ORAddress,
 *   directoryName              [4] Name,
 *   ediPartyName               [5] EDIPartyName,
 *   uniformResourceIdentifier  [6] IA5String,
 *   iPAddress                  [7] OCTET STRING,
 *   registeredID               [8] OBJECT IDENTIFIER }
 *
 * OtherName ::= SEQUENCE {
 *   type-id    OBJECT IDENTIFIER,
 *   value      [0] EXPLICIT ANY DEFINED BY type-id }
 * </pre>
 *
 * @example
 * gn = new KJUR.asn1.x509.GeneralName({dn:     '/C=US/O=Test'});
 * gn = new KJUR.asn1.x509.GeneralName({dn:     X500NameObject);
 * gn = new KJUR.asn1.x509.GeneralName({dn:     {str: /C=US/O=Test'});
 * gn = new KJUR.asn1.x509.GeneralName({dn:     {ldapstr: 'O=Test,C=US'});
 * gn = new KJUR.asn1.x509.GeneralName({dn:     {hex: '301c...'});
 * gn = new KJUR.asn1.x509.GeneralName({dn:     {certissuer: PEMCERTSTRING});
 * gn = new KJUR.asn1.x509.GeneralName({dn:     {certsubject: PEMCERTSTRING});
 * gn = new KJUR.asn1.x509.GeneralName({ip:     '192.168.1.1'});
 * gn = new KJUR.asn1.x509.GeneralName({ip:     '2001:db4::4:1'});
 * gn = new KJUR.asn1.x509.GeneralName({ip:     'c0a80101'});
 * gn = new KJUR.asn1.x509.GeneralName({rfc822: 'test@aaa.com'});
 * gn = new KJUR.asn1.x509.GeneralName({dns:    'aaa.com'});
 * gn = new KJUR.asn1.x509.GeneralName({uri:    'http://aaa.com/'});
 * gn = new KJUR.asn1.x509.GeneralName({other: {
 *   oid: "1.2.3.4",
 *   value: {utf8str: "example"} // any ASN.1 which passed to ASN1Util.newObject
 * }});
 *
 * gn = new KJUR.asn1.x509.GeneralName({ldapdn:     'O=Test,C=US'}); // DEPRECATED
 * gn = new KJUR.asn1.x509.GeneralName({certissuer: certPEM});       // DEPRECATED
 * gn = new KJUR.asn1.x509.GeneralName({certsubj:   certPEM});       // DEPRECATED
 */
KJUR.asn1.x509.GeneralName = function(params) {
    KJUR.asn1.x509.GeneralName.superclass.constructor.call(this);

    var pTag = { rfc822: '81', dns: '82', dn: 'a4',  
		 uri: '86', ip: '87', otherName: 'a0'},
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_X500Name = _KJUR_asn1_x509.X500Name,
	_OtherName = _KJUR_asn1_x509.OtherName,
	_DERIA5String = _KJUR_asn1.DERIA5String,
	_DERPrintableString = _KJUR_asn1.DERPrintableString,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_ASN1Object = _KJUR_asn1.ASN1Object,
	_Error = Error;

    this.params = null;

    this.setByParam = function(params) {
	this.params = params;
    };

    this.tohex = function() {
	var params = this.params;
	var hTag, explicitFlag, dObj;
	var explicitFlag = false;
	if (params.other !== undefined) {
	    hTag = "a0",
	    dObj = new _OtherName(params.other);
	} else if (params.rfc822 !== undefined) {
	    hTag = "81";
	    dObj = new _DERIA5String({str: params.rfc822});
	} else if (params.dns !== undefined) {
	    hTag = "82";
	    dObj = new _DERIA5String({str: params.dns});
	} else if (params.dn !== undefined) {
	    hTag = "a4";
	    explicitFlag = true;
	    if (typeof params.dn === "string") {
		dObj = new _X500Name({str: params.dn});
	    } else if (params.dn instanceof KJUR.asn1.x509.X500Name) {
		dObj = params.dn;
	    } else {
		dObj = new _X500Name(params.dn);
	    }
	} else if (params.ldapdn !== undefined) {
	    hTag = "a4";
	    explicitFlag = true;
	    dObj = new _X500Name({ldapstr: params.ldapdn});
	} else if (params.certissuer !== undefined ||
		   params.certsubj !== undefined) {
	    hTag = "a4";
	    explicitFlag = true;
	    var isIssuer, certStr;
	    var certHex = null;
	    if (params.certsubj !== undefined) {
		isIssuer = false;
		certStr = params.certsubj;
	    } else {
		isIssuer = true;
		certStr = params.certissuer;
	    }

	    if (certStr.match(/^[0-9A-Fa-f]+$/)) {
		certHex == certStr;
            }
	    if (certStr.indexOf("-----BEGIN ") != -1) {
		certHex = pemtohex(certStr);
	    }
	    if (certHex == null) 
		throw new Error("certsubj/certissuer not cert");

	    var x = new X509();
	    x.hex = certHex;

	    var hDN;
	    if (isIssuer) {
		hDN = x.getIssuerHex();
	    } else {
		hDN = x.getSubjectHex();
	    }
	    dObj = new _ASN1Object();
	    dObj.hTLV = hDN;
	} else if (params.uri !== undefined) {
	    hTag = "86";
	    dObj = new _DERIA5String({str: params.uri});
	} else if (params.ip !== undefined) {
	    hTag = "87";
	    var hIP;
	    var ip = params.ip;
	    try {
		if (ip.match(/^[0-9a-f]+$/)) {
		    var len = ip.length;
		    if (len == 8 || len == 16 || len == 32 || len == 64) {
			hIP = ip;
		    } else {
			throw "err";
		    }
		} else {
		    hIP = iptohex(ip);
		}
	    } catch(ex) {
		throw new _Error("malformed IP address: " + params.ip + ":" + ex.message);
	    }
	    dObj = new _DEROctetString({hex: hIP});
	} else {
	    throw new _Error("improper params");
	}

	var dTag = new _DERTaggedObject({tag: hTag,
					 explicit: explicitFlag,
					 obj: dObj});
	return dTag.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.x509.GeneralName, KJUR.asn1.ASN1Object);

/**
 * GeneralNames ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.GeneralNames
 * @class GeneralNames ASN.1 structure class
 * @description
 * <br/>
 * <h4>EXAMPLE AND ASN.1 SYNTAX</h4>
 * @example
 * gns = new KJUR.asn1.x509.GeneralNames([{'uri': 'http://aaa.com/'}, {'uri': 'http://bbb.com/'}]);
 *
 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 */
KJUR.asn1.x509.GeneralNames = function(paramsArray) {
    KJUR.asn1.x509.GeneralNames.superclass.constructor.call(this);
    var asn1Array = null,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1;

    /**
     * set a array of {@link KJUR.asn1.x509.GeneralName} parameters<br/>
     * @name setByParamArray
     * @memberOf KJUR.asn1.x509.GeneralNames#
     * @function
     * @param {Array} paramsArray Array of {@link KJUR.asn1.x509.GeneralNames}
     * @description
     * <br/>
     * <h4>EXAMPLES</h4>
     * @example
     * gns = new KJUR.asn1.x509.GeneralNames();
     * gns.setByParamArray([{uri: 'http://aaa.com/'}, {uri: 'http://bbb.com/'}]);
     */
    this.setByParamArray = function(paramsArray) {
        for (var i = 0; i < paramsArray.length; i++) {
            var o = new _KJUR_asn1.x509.GeneralName(paramsArray[i]);
            this.asn1Array.push(o);
        }
    };

    this.tohex = function() {
        var o = new _KJUR_asn1.DERSequence({'array': this.asn1Array});
        return o.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.asn1Array = new Array();
    if (typeof paramsArray != "undefined") {
        this.setByParamArray(paramsArray);
    }
};
extendClass(KJUR.asn1.x509.GeneralNames, KJUR.asn1.ASN1Object);

/**
 * OtherName of GeneralName ASN.1 structure class<br/>
 * @name KJUR.asn1.x509.OtherName
 * @class OtherName ASN.1 structure class
 * @since jsrsasign 10.5.3 asn1x509 2.1.12
 * @see KJUR.asn1.x509.GeneralName
 * @see KJUR.asn1.ASN1Util.newObject
 *
 * @description
 * This class is for OtherName of GeneralName ASN.1 structure.
 * Constructor has two members:
 * <ul>
 * <li>oid - oid string (ex. "1.2.3.4")</li>
 * <li>value - JSON object passed to ASN1Util.newObject or ASN1Object object</li>
 * </ul>
 *
 * <pre>
 * OtherName ::= SEQUENCE {
 *   type-id    OBJECT IDENTIFIER,
 *   value      [0] EXPLICIT ANY DEFINED BY type-id }
 * </pre>
 *
 * @example
 * new KJUR.asn1.x509.OtherName({
 *   oid: "1.2.3.4",
 *   value: {prnstr: {str: "abc"}}
 * })
 */
KJUR.asn1.x509.OtherName = function(params) {
    KJUR.asn1.x509.OtherName.superclass.constructor.call(this);

    var asn1Obj = null,
	type = null,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_DERSequence = _KJUR_asn1.DERSequence,
	_newObject = _KJUR_asn1.ASN1Util.newObject;

    this.params = null;

    this.setByParam = function(params) {
	this.params = params;
    };

    this.tohex = function() {
	var params = this.params;

	if (params.oid == undefined || params.value == undefined)
	    throw new Error("oid or value not specified");

	var dOid = new _DERObjectIdentifier({oid: params.oid});
	var dValue = _newObject({tag: {tag: "a0",
				       explicit: true,
				       obj: params.value}});
	var dSeq = new _DERSequence({array: [dOid, dValue]});

        return dSeq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.x509.OtherName, KJUR.asn1.ASN1Object);

/**
 * static object for OID
 * @name KJUR.asn1.x509.OID
 * @class static object for OID
 * @property {Assoc Array} atype2oidList for short attribute type name and oid (ex. 'C' and '2.5.4.6')
 * @property {Assoc Array} name2oidList for oid name and oid (ex. 'keyUsage' and '2.5.29.15')
 * @property {Assoc Array} objCache for caching name and DERObjectIdentifier object
 *
 * @description
 * This class defines OID name and values.
 * AttributeType names registered in OID.atype2oidList are following:
 * <table style="border-width: thin; border-style: solid; witdh: 100%">
 * <tr><th>short</th><th>long</th><th>OID</th></tr>
 * <tr><td>CN</td>commonName<td></td><td>2.5.4.3</td></tr>
 * <tr><td>L</td><td>localityName</td><td>2.5.4.7</td></tr>
 * <tr><td>ST</td><td>stateOrProvinceName</td><td>2.5.4.8</td></tr>
 * <tr><td>O</td><td>organizationName</td><td>2.5.4.10</td></tr>
 * <tr><td>OU</td><td>organizationalUnitName</td><td>2.5.4.11</td></tr>
 * <tr><td>C</td><td></td>countryName<td>2.5.4.6</td></tr>
 * <tr><td>STREET</td>streetAddress<td></td><td>2.5.4.6</td></tr>
 * <tr><td>DC</td><td>domainComponent</td><td>0.9.2342.19200300.100.1.25</td></tr>
 * <tr><td>UID</td><td>userId</td><td>0.9.2342.19200300.100.1.1</td></tr>
 * <tr><td>SN</td><td>surname</td><td>2.5.4.4</td></tr>
 * <tr><td>DN</td><td>distinguishedName</td><td>2.5.4.49</td></tr>
 * <tr><td>E</td><td>emailAddress</td><td>1.2.840.113549.1.9.1</td></tr>
 * <tr><td></td><td>businessCategory</td><td>2.5.4.15</td></tr>
 * <tr><td></td><td>postalCode</td><td>2.5.4.17</td></tr>
 * <tr><td></td><td>jurisdictionOfIncorporationL</td><td>1.3.6.1.4.1.311.60.2.1.1</td></tr>
 * <tr><td></td><td>jurisdictionOfIncorporationSP</td><td>1.3.6.1.4.1.311.60.2.1.2</td></tr>
 * <tr><td></td><td>jurisdictionOfIncorporationC</td><td>1.3.6.1.4.1.311.60.2.1.3</td></tr>
 * </table>
 *
 * @example
 */
KJUR.asn1.x509.OID = new function() {
    var _DERObjectIdentifier = KJUR.asn1.DERObjectIdentifier;

    this.name2oidList = {
        'sha1':                 '1.3.14.3.2.26',
        'sha256':               '2.16.840.1.101.3.4.2.1',
        'sha384':               '2.16.840.1.101.3.4.2.2',
        'sha512':               '2.16.840.1.101.3.4.2.3',
        'sha224':               '2.16.840.1.101.3.4.2.4',
        'md5':                  '1.2.840.113549.2.5',
        'md2':                  '1.3.14.7.2.2.1',
        'ripemd160':            '1.3.36.3.2.1',

        'MD2withRSA':           '1.2.840.113549.1.1.2',
        'MD4withRSA':           '1.2.840.113549.1.1.3',
        'MD5withRSA':           '1.2.840.113549.1.1.4',
        'SHA1withRSA':          '1.2.840.113549.1.1.5',
	'pkcs1-MGF':		'1.2.840.113549.1.1.8',
	'rsaPSS':		'1.2.840.113549.1.1.10',
        'SHA224withRSA':        '1.2.840.113549.1.1.14',
        'SHA256withRSA':        '1.2.840.113549.1.1.11',
        'SHA384withRSA':        '1.2.840.113549.1.1.12',
        'SHA512withRSA':        '1.2.840.113549.1.1.13',

        'SHA1withECDSA':        '1.2.840.10045.4.1',
        'SHA224withECDSA':      '1.2.840.10045.4.3.1',
        'SHA256withECDSA':      '1.2.840.10045.4.3.2',
        'SHA384withECDSA':      '1.2.840.10045.4.3.3',
        'SHA512withECDSA':      '1.2.840.10045.4.3.4',

        'dsa':                  '1.2.840.10040.4.1',
        'SHA1withDSA':          '1.2.840.10040.4.3',
        'SHA224withDSA':        '2.16.840.1.101.3.4.3.1',
        'SHA256withDSA':        '2.16.840.1.101.3.4.3.2',

        'rsaEncryption':        '1.2.840.113549.1.1.1',

	// X.500 AttributeType defined in RFC 4514
        'commonName':			'2.5.4.3',
        'countryName':			'2.5.4.6',
        'localityName':			'2.5.4.7',
        'stateOrProvinceName':		'2.5.4.8',
        'streetAddress':		'2.5.4.9',
        'organizationName':		'2.5.4.10',
        'organizationalUnitName':	'2.5.4.11',
        'domainComponent':		'0.9.2342.19200300.100.1.25',
        'userId':			'0.9.2342.19200300.100.1.1',
	// other AttributeType name string
	'surname':			'2.5.4.4',
        'givenName':                    '2.5.4.42',
        'title':			'2.5.4.12',
	'distinguishedName':		'2.5.4.49',
	'emailAddress':			'1.2.840.113549.1.9.1',
	// other AttributeType name string (no short name)
	'description':			'2.5.4.13',
	'businessCategory':		'2.5.4.15',
	'postalCode':			'2.5.4.17',
	'uniqueIdentifier':		'2.5.4.45',
	'organizationIdentifier':	'2.5.4.97',
	'jurisdictionOfIncorporationL':	'1.3.6.1.4.1.311.60.2.1.1',
	'jurisdictionOfIncorporationSP':'1.3.6.1.4.1.311.60.2.1.2',
	'jurisdictionOfIncorporationC':	'1.3.6.1.4.1.311.60.2.1.3',

        'subjectDirectoryAttributes': '2.5.29.9',
        'subjectKeyIdentifier': '2.5.29.14',
        'keyUsage':             '2.5.29.15',
        'subjectAltName':       '2.5.29.17',
        'issuerAltName':        '2.5.29.18',
        'basicConstraints':     '2.5.29.19',
        'cRLNumber':     	'2.5.29.20',
        'cRLReason':     	'2.5.29.21',
        'nameConstraints':      '2.5.29.30',
        'cRLDistributionPoints':'2.5.29.31',
        'certificatePolicies':  '2.5.29.32',
        'anyPolicy':  		'2.5.29.32.0',
	'policyMappings':	'2.5.29.33',
        'authorityKeyIdentifier':'2.5.29.35',
        'policyConstraints':    '2.5.29.36',
        'extKeyUsage':          '2.5.29.37',
	'inhibitAnyPolicy':	'2.5.29.54',
        'authorityInfoAccess':  '1.3.6.1.5.5.7.1.1',
        'ocsp':                 '1.3.6.1.5.5.7.48.1',
        'ocspBasic':            '1.3.6.1.5.5.7.48.1.1',
        'ocspNonce':            '1.3.6.1.5.5.7.48.1.2',
        'ocspNoCheck':          '1.3.6.1.5.5.7.48.1.5',
        'caIssuers':            '1.3.6.1.5.5.7.48.2',

        'anyExtendedKeyUsage':  '2.5.29.37.0',
        'serverAuth':           '1.3.6.1.5.5.7.3.1',
        'clientAuth':           '1.3.6.1.5.5.7.3.2',
        'codeSigning':          '1.3.6.1.5.5.7.3.3',
        'emailProtection':      '1.3.6.1.5.5.7.3.4',
        'timeStamping':         '1.3.6.1.5.5.7.3.8',
        'ocspSigning':          '1.3.6.1.5.5.7.3.9',

	// 'otherNameForms':	'1.3.6.1.5.5.7.8',
	'smtpUTF8Mailbox':	'1.3.6.1.5.5.7.8.9',

        'dateOfBirth':          '1.3.6.1.5.5.7.9.1',
        'placeOfBirth':         '1.3.6.1.5.5.7.9.2',
        'gender':               '1.3.6.1.5.5.7.9.3',
        'countryOfCitizenship': '1.3.6.1.5.5.7.9.4',
        'countryOfResidence':   '1.3.6.1.5.5.7.9.5',

        'ecPublicKey':          '1.2.840.10045.2.1',
        'P-256':                '1.2.840.10045.3.1.7',
        'secp256r1':            '1.2.840.10045.3.1.7',
        'secp256k1':            '1.3.132.0.10',
        'secp384r1':            '1.3.132.0.34',
        'secp521r1':            '1.3.132.0.35',

        'pkcs5PBES2':           '1.2.840.113549.1.5.13',
        'pkcs5PBKDF2':          '1.2.840.113549.1.5.12',

        'des-EDE3-CBC':         '1.2.840.113549.3.7',

        'data':                 '1.2.840.113549.1.7.1', // CMS data
        'signed-data':          '1.2.840.113549.1.7.2', // CMS signed-data
        'enveloped-data':       '1.2.840.113549.1.7.3', // CMS enveloped-data
        'digested-data':        '1.2.840.113549.1.7.5', // CMS digested-data
        'encrypted-data':       '1.2.840.113549.1.7.6', // CMS encrypted-data
        'authenticated-data':   '1.2.840.113549.1.9.16.1.2', // CMS authenticated-data
        'tstinfo':              '1.2.840.113549.1.9.16.1.4', // RFC3161 TSTInfo
	'signingCertificate':	'1.2.840.113549.1.9.16.2.12',// SMIME
	'timeStampToken':	'1.2.840.113549.1.9.16.2.14',// sigTS
	'signaturePolicyIdentifier':	'1.2.840.113549.1.9.16.2.15',// cades
	'etsArchiveTimeStamp':	'1.2.840.113549.1.9.16.2.27',// SMIME
	'signingCertificateV2':	'1.2.840.113549.1.9.16.2.47',// SMIME
	'etsArchiveTimeStampV2':'1.2.840.113549.1.9.16.2.48',// SMIME
        'extensionRequest':     '1.2.840.113549.1.9.14',// CSR extensionRequest
	'contentType':		'1.2.840.113549.1.9.3',//PKCS#9
	'messageDigest':	'1.2.840.113549.1.9.4',//PKCS#9
	'signingTime':		'1.2.840.113549.1.9.5',//PKCS#9
	'counterSignature':	'1.2.840.113549.1.9.6',//PKCS#9
	'archiveTimeStampV3':	'0.4.0.1733.2.4',//ETSI EN29319122/TS101733
	'pdfRevocationInfoArchival':'1.2.840.113583.1.1.8', //Adobe
	'adobeTimeStamp':	'1.2.840.113583.1.1.9.1', // Adobe
	// CABF S/MIME BR
	'smimeMailboxLegacy':		'2.23.140.1.5.1.1',
	'smimeMailboxMulti':		'2.23.140.1.5.1.2',
	'smimeMailboxStrict':		'2.23.140.1.5.1.3',
	'smimeOrganizationLegacy':	'2.23.140.1.5.2.1',
	'smimeOrganizationMulti':	'2.23.140.1.5.2.2',
	'smimeOrganizationStrict':	'2.23.140.1.5.2.3',
	'smimeSponsorLegacy':		'2.23.140.1.5.3.1',
	'smimeSponsorMulti':		'2.23.140.1.5.3.2',
	'smimeSponsorStrict':		'2.23.140.1.5.3.3',
	'smimeIndividualLegacy':	'2.23.140.1.5.4.1',
	'smimeIndividualMulti':		'2.23.140.1.5.4.2',
	'smimeIndividualStrict':	'2.23.140.1.5.4.3',
    };

    this.atype2oidList = {
	// RFC 4514 AttributeType name string (MUST recognized)
        'CN':		'2.5.4.3',
        'L':		'2.5.4.7',
        'ST':		'2.5.4.8',
        'O':		'2.5.4.10',
        'OU':		'2.5.4.11',
        'C':		'2.5.4.6',
        'STREET':	'2.5.4.9',
        'DC':		'0.9.2342.19200300.100.1.25',
        'UID':		'0.9.2342.19200300.100.1.1',
	// other AttributeType name string
	// http://blog.livedoor.jp/k_urushima/archives/656114.html
        'SN':		'2.5.4.4', // surname
        'T':		'2.5.4.12', // title
        'GN':		'2.5.4.42', // givenName
        'DN':		'2.5.4.49', // distinguishedName
        'E':		'1.2.840.113549.1.9.1', // emailAddress in MS.NET or Bouncy
	// other AttributeType name string (no short name)
	'description':			'2.5.4.13',
	'businessCategory':		'2.5.4.15',
	'postalCode':			'2.5.4.17',
	'serialNumber':			'2.5.4.5',
	'uniqueIdentifier':		'2.5.4.45',
	'organizationIdentifier':	'2.5.4.97',
	'jurisdictionOfIncorporationL':	'1.3.6.1.4.1.311.60.2.1.1',
	'jurisdictionOfIncorporationSP':'1.3.6.1.4.1.311.60.2.1.2',
	'jurisdictionOfIncorporationC':	'1.3.6.1.4.1.311.60.2.1.3'
    };
    
    this.objCache = {};

    /**
     * get DERObjectIdentifier by registered OID name
     * @name name2obj
     * @memberOf KJUR.asn1.x509.OID
     * @function
     * @param {String} name OID
     * @return {Object} DERObjectIdentifier instance
     * @see KJUR.asn1.DERObjectIdentifier
     *
     * @description
     * This static method returns DERObjectIdentifier object
     * for the specified OID.
     *
     * @example
     * var asn1ObjOID = KJUR.asn1.x509.OID.name2obj('SHA1withRSA');
     */
    this.name2obj = function(name) {
        if (typeof this.objCache[name] != "undefined")
            return this.objCache[name];
        if (typeof this.name2oidList[name] == "undefined")
            throw "Name of ObjectIdentifier not defined: " + name;
        var oid = this.name2oidList[name];
        var obj = new _DERObjectIdentifier({'oid': oid});
        this.objCache[name] = obj;
        return obj;
    };

    /**
     * get DERObjectIdentifier by registered attribute type name such like 'C' or 'CN'<br/>
     * @name atype2obj
     * @memberOf KJUR.asn1.x509.OID
     * @function
     * @param {String} atype short attribute type name such like 'C', 'CN' or OID
     * @return KJUR.asn1.DERObjectIdentifier instance
     * @description
     * @example
     * KJUR.asn1.x509.OID.atype2obj('CN') &rarr; DERObjectIdentifier of 2.5.4.3
     * KJUR.asn1.x509.OID.atype2obj('OU') &rarr; DERObjectIdentifier of 2.5.4.11
     * KJUR.asn1.x509.OID.atype2obj('streetAddress') &rarr; DERObjectIdentifier of 2.5.4.9
     * KJUR.asn1.x509.OID.atype2obj('2.5.4.9') &rarr; DERObjectIdentifier of 2.5.4.9
     */
    this.atype2obj = function(atype) {
        if (this.objCache[atype] !== undefined)
            return this.objCache[atype];

	var oid;

	if (atype.match(/^\d+\.\d+\.[0-9.]+$/)) {
	    oid = atype;
	} else if (this.atype2oidList[atype] !== undefined) {
	    oid = this.atype2oidList[atype];
	} else if (this.name2oidList[atype] !== undefined) {
	    oid = this.name2oidList[atype];
    	} else {
            throw new Error("AttributeType name undefined: " + atype);
	}
        var obj = new _DERObjectIdentifier({'oid': oid});
        this.objCache[atype] = obj;
        return obj;
    };

    /**
     * register OID list<br/>
     * @name registerOIDs
     * @memberOf KJUR.asn1.x509.OID
     * @function
     * @param {object} oids associative array of names and oids
     * @since jsrsasign 10.5.2 asn1x509 2.1.11
     * @see KJUR.asn1.x509.OID.checkOIDs
     * 
     * @description
     * This static method to register an oids to existing list
     * additionally.
     *
     * @example
     * KJUR.asn1.x509.OID.checkOIDs({
     *   "test1": "4.5.7.8"
     * }) // do nothing for invalid list
     *
     * KJUR.asn1.x509.OID.registerOIDs({
     *   "test1": "1.2.3",
     *   "test2": "0.2.3.4.23",
     * }) // successfully registered
     *
     * KJUR.asn1.x509.OID.name2oid("test1") &rarr; "1.2.3"
     */
    this.registerOIDs = function(oids) {
	if (! this.checkOIDs(oids)) return;
	for (var name in oids) {
	    this.name2oidList[name] = oids[name];
	}
    };

    /**
     * check validity for OID list<br/>
     * @name checkOIDs
     * @memberOf KJUR.asn1.x509.OID
     * @function
     * @param {object} oids associative array of names and oids
     * @return {boolean} return true when valid OID list otherwise false
     * @since jsrsasign 10.5.2 asn1x509 2.1.11
     * @see KJUR.asn1.x509.OID.registOIDs
     * 
     * @description
     * This static method validates an associative array
     * as oid list.
     *
     * @example
     * KJUR.asn1.x509.OID.checkOIDs(*non-assoc-array*) &rarr; false
     * KJUR.asn1.x509.OID.checkOIDs({}) &rarr; false
     * KJUR.asn1.x509.OID.checkOIDs({"test1": "apple"}) &rarr; false
     * KJUR.asn1.x509.OID.checkOIDs({
     *   "test1": "1.2.3",
     *   "test2": "0.2.3.4.23",
     * }) &rarr; true // valid oids
     * KJUR.asn1.x509.OID.checkOIDs({
     *   "test1": "4.5.7.8"
     * }) &rarr; false // invalid oid
     */
    this.checkOIDs = function(oids) {
	try {
	    var nameList = Object.keys(oids);
	    if (nameList.length == 0)
		return false;
	    nameList.map(function(value, index, array) {
		var oid = this[value];
		if (! oid.match(/^[0-2]\.[0-9.]+$/))
		    throw new Error("value is not OID");
	    }, oids);
	    return true;
	} catch(ex) {
	    return false;
	}
    };


};

/**
 * convert OID to name<br/>
 * @name oid2name
 * @memberOf KJUR.asn1.x509.OID
 * @function
 * @param {String} oid dot noted Object Identifer string (ex. 1.2.3.4)
 * @return {String} OID name if registered otherwise empty string
 * @since asn1x509 1.0.9
 * @description
 * This static method converts OID string to its name.
 * If OID is undefined then it returns empty string (i.e. '').
 * @example
 * KJUR.asn1.x509.OID.oid2name("1.3.6.1.5.5.7.1.1") &rarr; 'authorityInfoAccess'
 */
KJUR.asn1.x509.OID.oid2name = function(oid) {
    var list = KJUR.asn1.x509.OID.name2oidList;
    for (var name in list) {
        if (list[name] == oid) return name;
    }
    return '';
};

/**
 * convert OID to AttributeType name<br/>
 * @name oid2atype
 * @memberOf KJUR.asn1.x509.OID
 * @function
 * @param {String} oid dot noted Object Identifer string (ex. 1.2.3.4)
 * @return {String} OID AttributeType name if registered otherwise oid
 * @since jsrsasign 6.2.2 asn1x509 1.0.18
 * @description
 * This static method converts OID string to its AttributeType name.
 * If OID is not defined in OID.atype2oidList associative array then it returns OID
 * specified as argument.
 * @example
 * KJUR.asn1.x509.OID.oid2atype("2.5.4.3") &rarr; CN
 * KJUR.asn1.x509.OID.oid2atype("1.3.6.1.4.1.311.60.2.1.3") &rarr; jurisdictionOfIncorporationC
 * KJUR.asn1.x509.OID.oid2atype("0.1.2.3.4") &rarr; 0.1.2.3.4 // unregistered OID
 */
KJUR.asn1.x509.OID.oid2atype = function(oid) {
    var list = KJUR.asn1.x509.OID.atype2oidList;
    for (var atype in list) {
        if (list[atype] == oid) return atype;
    }
    return oid;
};

/**
 * convert OID name to OID value<br/>
 * @name name2oid
 * @memberOf KJUR.asn1.x509.OID
 * @function
 * @param {String} name OID name or OID (ex. "sha1" or "1.2.3.4")
 * @return {String} dot noted Object Identifer string (ex. 1.2.3.4)
 * @since asn1x509 1.0.11
 * @description
 * This static method converts from OID name to OID string.
 * If OID is undefined then it returns empty string (i.e. '').
 * @example
 * KJUR.asn1.x509.OID.name2oid("authorityInfoAccess") &rarr; "1.3.6.1.5.5.7.1.1"
 * KJUR.asn1.x509.OID.name2oid("1.2.3.4") &rarr; "1.2.3.4"
 * KJUR.asn1.x509.OID.name2oid("UNKNOWN NAME") &rarr; ""
 */
KJUR.asn1.x509.OID.name2oid = function(name) {
    if (name.match(/^[0-9.]+$/)) return name;
    var list = KJUR.asn1.x509.OID.name2oidList;
    if (list[name] === undefined) return '';
    return list[name];
};

/**
 * X.509 certificate and CRL utilities class<br/>
 * @name KJUR.asn1.x509.X509Util
 * @class X.509 certificate and CRL utilities class
 */
KJUR.asn1.x509.X509Util = {};

/**
 * issue a certificate in PEM format (DEPRECATED)
 * @name newCertPEM
 * @memberOf KJUR.asn1.x509.X509Util
 * @function
 * @param {Array} param JSON object of parameter to issue a certificate
 * @since asn1x509 1.0.6
 * @deprecated since jsrsasign 9.0.0 asn1x509 2.0.0. please move to {@link KJUR.asn1.x509.Certificate} constructor
 * @description
 * This method can issue a certificate by a simple
 * JSON object.
 * Signature value will be provided by signing with
 * private key using 'cakey' parameter or
 * hexadecimal signature value by 'sighex' parameter.
 * <br/>
 * NOTE: Algorithm parameter of AlgorithmIdentifier will
 * be set automatically by default. 
 * (see {@link KJUR.asn1.x509.AlgorithmIdentifier})
 * from jsrsasign 7.1.1 asn1x509 1.0.20.
 * <br/>
 * NOTE2: 
 * RSA-PSS algorithm has been supported from jsrsasign 8.0.21.
 * As for RSA-PSS signature algorithm names and signing parameters 
 * such as MGF function and salt length, please see
 * {@link KJUR.asn1.x509.AlgorithmIdentifier} class.
 *
 * @example
 * var certPEM = KJUR.asn1.x509.X509Util.newCertPEM({
 *   serial: {int: 4},
 *   sigalg: {name: 'SHA1withECDSA'},
 *   issuer: {str: '/C=US/O=a'},
 *   notbefore: {'str': '130504235959Z'},
 *   notafter: {'str': '140504235959Z'},
 *   subject: {str: '/C=US/O=b'},
 *   sbjpubkey: pubKeyObj,
 *   ext: [
 *     {basicConstraints: {cA: true, critical: true}},
 *     {keyUsage: {bin: '11'}},
 *   ],
 *   cakey: prvKeyObj
 * });
 * // -- or --
 * var certPEM = KJUR.asn1.x509.X509Util.newCertPEM({
 *   serial: {int: 4},
 *   sigalg: {name: 'SHA1withECDSA'},
 *   issuer: {str: '/C=US/O=a'},
 *   notbefore: {'str': '130504235959Z'},
 *   notafter: {'str': '140504235959Z'},
 *   subject: {str: '/C=US/O=b'},
 *   sbjpubkey: pubKeyPEM,
 *   ext: [
 *     {basicConstraints: {cA: true, critical: true}},
 *     {keyUsage: {bin: '11'}},
 *   ],
 *   cakey: [prvkey, pass]}
 * );
 * // -- or --
 * var certPEM = KJUR.asn1.x509.X509Util.newCertPEM({
 *   serial: {int: 1},
 *   sigalg: {name: 'SHA1withRSA'},
 *   issuer: {str: '/C=US/O=T1'},
 *   notbefore: {'str': '130504235959Z'},
 *   notafter: {'str': '140504235959Z'},
 *   subject: {str: '/C=US/O=T1'},
 *   sbjpubkey: pubKeyObj,
 *   sighex: '0102030405..'
 * });
 * // for the issuer and subject field, another
 * // representation is also available
 * var certPEM = KJUR.asn1.x509.X509Util.newCertPEM({
 *   serial: {int: 1},
 *   sigalg: {name: 'SHA256withRSA'},
 *   issuer: {C: "US", O: "T1"},
 *   notbefore: {'str': '130504235959Z'},
 *   notafter: {'str': '140504235959Z'},
 *   subject: {C: "US", O: "T1", CN: "http://example.com/"},
 *   sbjpubkey: pubKeyObj,
 *   sighex: '0102030405..'
 * });
 */
KJUR.asn1.x509.X509Util.newCertPEM = function(param) {
    var _KJUR_asn1_x509 = KJUR.asn1.x509,
	_TBSCertificate = _KJUR_asn1_x509.TBSCertificate,
	_Certificate = _KJUR_asn1_x509.Certificate;
    var cert = new _Certificate(param);
    return cert.getPEM();
};


/* asn1cms-2.0.5.js (c) 2013-2020 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * asn1cms.js - ASN.1 DER encoder and verifier classes for Cryptographic Message Syntax(CMS)
 *
 * Copyright (c) 2013-2020 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name asn1cms-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.5.16 asn1cms 2.0.5 (2022-Apr-08)
 * @since jsrsasign 4.2.4
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/** 
 * kjur's class library name space
 * // already documented in asn1-1.0.js
 * @name KJUR
 * @namespace kjur's class library name space
 */
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};

/**
 * kjur's ASN.1 class library name space
 * // already documented in asn1-1.0.js
 * @name KJUR.asn1
 * @namespace
 */
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};

/**
 * kjur's ASN.1 class for Cryptographic Message Syntax(CMS)
 * <p>
 * This name space provides 
 * <a href="https://tools.ietf.org/html/rfc5652">RFC 5652
 * Cryptographic Message Syntax (CMS)</a> SignedData generator.
 *
 * <h4>FEATURES</h4>
 * <ul>
 * <li>easily generate CMS SignedData</li>
 * <li>easily verify CMS SignedData</li>
 * <li>APIs are very similar to BouncyCastle library ASN.1 classes. So easy to learn.</li>
 * </ul>
 * 
 * <h4>PROVIDED CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.cms.SignedData}</li>
 * <li>{@link KJUR.asn1.cms.SignerInfo}</li>
 * <li>{@link KJUR.asn1.cms.AttributeList}</li>
 * <li>{@link KJUR.asn1.cms.ContentInfo}</li>
 * <li>{@link KJUR.asn1.cms.EncapsulatedContentInfo}</li>
 * <li>{@link KJUR.asn1.cms.IssuerAndSerialNumber}</li>
 * <li>{@link KJUR.asn1.cms.IssuerSerial}</li>
 * <li>{@link KJUR.asn1.cms.CMSUtil}</li>
 * <li>{@link KJUR.asn1.cms.Attribute}</li>
 * <li>{@link KJUR.asn1.cms.ContentType}</li>
 * <li>{@link KJUR.asn1.cms.MessageDigest}</li>
 * <li>{@link KJUR.asn1.cms.SigningTime}</li>
 * <li>{@link KJUR.asn1.cms.SigningCertificate}</li>
 * <li>{@link KJUR.asn1.cms.SigningCertificateV2}</li>
 * </ul>
 * NOTE: Please ignore method summary and document of this namespace. 
 * This caused by a bug of jsdoc2.
 * </p>
 * @name KJUR.asn1.cms
 * @namespace
 */
if (typeof KJUR.asn1.cms == "undefined" || !KJUR.asn1.cms) KJUR.asn1.cms = {};

/**
 * Attribute class for base of CMS attribute<br/>
 * @name KJUR.asn1.cms.Attribute
 * @class Attribute class for base of CMS attribute
 * @param {Array} params JSON object for constructor
 * @property {Array} params JSON object for ASN.1 encode
 * @property {String} typeOid attribute type OID string
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.2.4 asn1cms 1.0.0
 *
 * @description
 * This is an abstract class for CMS attribute
 * ASN.1 encoder as defined in
 * <a href="https://tools.ietf.org/html/rfc5652#section-5.3">
 * RFC 5652 CMS 5.3 SignerInfo</a>.
 * <pre>
 * Attributes ::= SET OF Attribute
 * Attribute ::= SEQUENCE {
 *    type               OBJECT IDENTIFIER,
 *    values             AttributeSetValue }
 * AttributeSetValue ::= SET OF ANY
 * </pre>
 */
KJUR.asn1.cms.Attribute = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERSet = _KJUR_asn1.DERSet,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier;

    this.params = null;
    this.typeOid = null;

    this.setByParam = function(params) {
	this.params = params;
    };

    /**
     * get ASN1Object array for Attributes<br/>
     * @name getValueArray
     * @memberOf KJUR.asn1.cms.Attribute#
     * @function
     * @return {Array} array of Attribute value ASN1Object
     *
     * @description
     * This method shall be implemented in subclass.
     */
    this.getValueArray = function() {
	throw new _Error("not yet implemented abstract");
    };

    this.tohex = function() {
	var dType = new _DERObjectIdentifier({oid: this.typeOid});
	var dValueSet = new _DERSet({array: this.getValueArray()});
	var seq = new _DERSequence({array: [dType, dValueSet]});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };
};
extendClass(KJUR.asn1.cms.Attribute, KJUR.asn1.ASN1Object);

/**
 * class for CMS ContentType attribute
 * @name KJUR.asn1.cms.ContentType
 * @class class for CMS ContentType attribute
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.cms.Attribute
 * @since jsrsasign 4.2.4 asn1cms 1.0.0
 *
 * @description
 * This is an ASN.1 encoder for ContentType attribute
 * defined in
 * <a href="https://tools.ietf.org/html/rfc5652#section-11.1">
 * RFC 5652 CMS section 11.1</a>.
 * <pre>
 * Attribute ::= SEQUENCE {
 *    type               OBJECT IDENTIFIER,
 *    values             AttributeSetValue }
 * AttributeSetValue ::= SET OF ANY
 * ContentType ::= OBJECT IDENTIFIER
 * </pre>
 * Constructor may have following property in argument:
 * <ul>
 * <li>{String}type - name or OID string</li>
 * </ul>
 *
 * @example
 * o = new KJUR.asn1.cms.ContentType({type: 'data'});
 * o = new KJUR.asn1.cms.ContentType({type: '1.2.840.113549.1.9.16.1.4'});
 */
KJUR.asn1.cms.ContentType = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1;

    _KJUR_asn1.cms.ContentType.superclass.constructor.call(this);

    this.typeOid = "1.2.840.113549.1.9.3";

    this.getValueArray = function() {
        var dOid = new _KJUR_asn1.DERObjectIdentifier(this.params.type);
        return [dOid];
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.ContentType, KJUR.asn1.cms.Attribute);

/**
 * class for CMS MessageDigest attribute
 * @name KJUR.asn1.cms.MessageDigest
 * @class class for CMS MessageDigest attribute
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.cms.Attribute
 * @since jsrsasign 4.2.4 asn1cms 1.0.0
 *
 * @description
 * This is an ASN.1 encoder for ContentType attribute
 * defined in
 * <a href="https://tools.ietf.org/html/rfc5652#section-11.2">
 * RFC 5652 CMS section 11.2</a>.
 * <pre>
 * Attribute ::= SEQUENCE {
 *    type               OBJECT IDENTIFIER,
 *    values             AttributeSetValue }
 * AttributeSetValue ::= SET OF ANY
 * MessageDigest ::= OCTET STRING
 * </pre>
 *
 * @example
 * o = new KJUR.asn1.cms.MessageDigest({hex: 'a1a2a3a4...'});
 */
KJUR.asn1.cms.MessageDigest = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_KJUR_asn1_cms = _KJUR_asn1.cms;

    _KJUR_asn1_cms.MessageDigest.superclass.constructor.call(this);

    this.typeOid = "1.2.840.113549.1.9.4";

    this.getValueArray = function() {
	var dHash = new _DEROctetString(this.params);
	return [dHash];
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.MessageDigest, KJUR.asn1.cms.Attribute);

/**
 * class for CMS SigningTime attribute
 * @name KJUR.asn1.cms.SigningTime
 * @class class for CMS SigningTime attribute
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.cms.Attribute
 * @since jsrsasign 4.2.4 asn1cms 1.0.0
 *
 * @description
 * This is an ASN.1 encoder for ContentType attribute
 * defined in
 * <a href="https://tools.ietf.org/html/rfc5652#section-11.3">
 * RFC 5652 CMS section 11.3</a>.
 * <pre>
 * Attribute ::= SEQUENCE {
 *    type               OBJECT IDENTIFIER,
 *    values             AttributeSetValue }
 * AttributeSetValue ::= SET OF ANY
 * SigningTime  ::= Time
 * Time ::= CHOICE {
 *    utcTime UTCTime,
 *    generalTime GeneralizedTime }
 * </pre>
 *
 * @example
 * o = new KJUR.asn1.cms.SigningTime(); // current time UTCTime by default
 * o = new KJUR.asn1.cms.SigningTime({type: 'gen'}); // current time GeneralizedTime
 * o = new KJUR.asn1.cms.SigningTime({str: '20140517093800Z'}); // specified GeneralizedTime
 * o = new KJUR.asn1.cms.SigningTime({str: '140517093800Z'}); // specified UTCTime
 */
KJUR.asn1.cms.SigningTime = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1;

    _KJUR_asn1.cms.SigningTime.superclass.constructor.call(this);

    this.typeOid = "1.2.840.113549.1.9.5";

    this.getValueArray = function() {
	var dTime = new _KJUR_asn1.x509.Time(this.params);
	return [dTime];
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.SigningTime, KJUR.asn1.cms.Attribute);

/**
 * class for CMS SigningCertificate attribute<br/>
 * @name KJUR.asn1.cms.SigningCertificate
 * @class class for CMS SigningCertificate attribute
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.cms.Attribute
 * @since jsrsasign 4.5.1 asn1cms 1.0.1
 * @see KJUR.asn1.cms.ESSCertID
 * @see KJUR.asn1.cms.IssuerSerial
 *
 * @description
 * This is an ASN.1 encoder for SigningCertificate attribute
 * defined in
 * <a href="https://tools.ietf.org/html/rfc5035#section-5">
 * RFC 5035 section 5</a>.
 * <pre>
 * Attribute ::= SEQUENCE {
 *    type               OBJECT IDENTIFIER,
 *    values             AttributeSetValue }
 * AttributeSetValue ::= SET OF ANY
 * SigningCertificate ::= SEQUENCE {
 *    certs SEQUENCE OF ESSCertID,
 *    policies SEQUENCE OF PolicyInformation OPTIONAL }
 * ESSCertID ::= SEQUENCE {
 *    certHash Hash,
 *    issuerSerial IssuerSerial OPTIONAL }
 * IssuerSerial ::= SEQUENCE {
 *    issuer GeneralNames,
 *    serialNumber CertificateSerialNumber }
 * </pre>
 *
 * @example
 * o = new KJUR.asn1.cms.SigningCertificate({array: [certPEM]});
 */
KJUR.asn1.cms.SigningCertificate = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_ESSCertID = _KJUR_asn1_cms.ESSCertID,
	_KJUR_crypto = _KJUR.crypto;

    _KJUR_asn1_cms.SigningCertificate.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.16.2.12";

    this.getValueArray = function() {
	if (this.params == null || 
	    this.params == undefined || 
	    this.params.array == undefined) {
	    throw new _Error("parameter 'array' not specified");
	}
	var aESSCertIDParam = this.params.array;
	var aESSCertID = [];
	for (var i = 0; i < aESSCertIDParam.length; i++) {
	    var idparam = aESSCertIDParam[i];

	    if (params.hasis == false &&
		(typeof idparam == "string" &&
		 (idparam.indexOf("-----BEGIN") != -1 ||
		  ASN1HEX.isASN1HEX(idparam)))) {
		idparam = {cert: idparam};
	    }

	    if (idparam.hasis != false && params.hasis == false) {
		idparam.hasis = false;
	    }

	    aESSCertID.push(new _ESSCertID(idparam));
	}
	var dCerts = new _DERSequence({array: aESSCertID});
	var dSigningCertificate = new _DERSequence({array: [dCerts]});
	return [dSigningCertificate];
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.SigningCertificate, KJUR.asn1.cms.Attribute);

/**
 * class for CMS ESSCertID ASN.1 encoder<br/>
 * @name KJUR.asn1.cms.ESSCertID
 * @class class for CMS ESSCertID ASN.1 encoder
 * @param {Object} params PEM certificate string or JSON of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 10.0.0 asn1cms 2.0.0
 * @see KJUR.asn1.cms.SigningCertificate
 * @see KJUR.asn1.cms.IssuerSerial
 * @see KJUR.asn1.cms.ESSCertIDv2
 * @see KJUR.asn1.cades.OtherCertID
 *
 * @description
 * This is an ASN.1 encoder for ESSCertID class
 * defined in
 * <a href="https://tools.ietf.org/html/rfc5035#section-6">
 * RFC 5035 section 6</a>.
 * <pre>
 * ESSCertID ::= SEQUENCE {
 *    certHash Hash,
 *    issuerSerial IssuerSerial OPTIONAL }
 * IssuerSerial ::= SEQUENCE {
 *    issuer GeneralNames,
 *    serialNumber CertificateSerialNumber }
 * </pre>
 *
 * @example
 * new KJUR.asn1.cms.ESSCertID("-----BEGIN...")
 * new KJUR.asn1.cms.ESSCertID({cert: "-----BEGIN..."})
 * new KJUR.asn1.cms.ESSCertID({cert: "-----BEGIN...", hasis: false})
 * new KJUR.asn1.cms.ESSCertID({
 *   hash: "3f2d...",
 *   issuer: {str: "/C=JP/O=T1"},
 *   serial: {hex: "12ab..."}
 * })
 */
KJUR.asn1.cms.ESSCertID = function(params) {
    KJUR.asn1.cms.ESSCertID.superclass.constructor.call(this);

    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_DERSequence = _KJUR_asn1.DERSequence,
	_IssuerSerial = _KJUR_asn1.cms.IssuerSerial;

    this.params = null;

    this.getCertHash = function(params, defaultAlg) {
	if (params.hash != undefined) return params.hash;

	// hash 
	if (typeof params == "string" &&
	    params.indexOf("-----BEGIN") == -1 &&
	    ! ASN1HEX.isASN1HEX(params)) {
	    return params;
	}

	var certPEMorHex;
	if (typeof params == "string") {
	    certPEMorHex = params;
	} else if (params.cert != undefined) {
	    certPEMorHex = params.cert;
	} else {
	    throw new _Error("hash nor cert unspecified");
	}

	var hCert;
	if (certPEMorHex.indexOf("-----BEGIN") != -1) {
	    hCert = pemtohex(certPEMorHex);
	} else {
	    hCert = certPEMorHex;
	}


	if (typeof params == "string") {
	    if (params.indexOf("-----BEGIN") != -1) {
		hCert = pemtohex(params);
	    } else if (ASN1HEX.isASN1HEX(params)) {
		hCert = params;
	    }
	}

	var alg;
	if (params.alg != undefined) {
	    alg = params.alg;
	} else if (defaultAlg != undefined) {
	    alg = defaultAlg;
	} else {
	    throw new _Error("hash alg unspecified");
	}
	
	return _KJUR.crypto.Util.hashHex(hCert, alg);
    };

    this.tohex = function() {
	var params = this.params;

	var hCertHash = this.getCertHash(params, 'sha1');

	var a = [];
	a.push(new _DEROctetString({hex: hCertHash}));
	if ((typeof params == "string" &&
	     params.indexOf("-----BEGIN") != -1) ||
	    (params.cert != undefined &&
	     params.hasis != false) ||
	    (params.issuer != undefined &&
	     params.serial != undefined))
	    a.push(new _IssuerSerial(params));
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.ESSCertID, KJUR.asn1.ASN1Object);

/**
 * class for CMS SigningCertificateV2 attribute<br/>
 * @name KJUR.asn1.cms.SigningCertificateV2
 * @class class for CMS SigningCertificateV2 attribute
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.cms.Attribute
 * @since jsrsasign 4.5.1 asn1cms 1.0.1
 *
 * @description
 * This is an ASN.1 encoder for SigningCertificateV2 attribute
 * defined in
 * <a href="https://tools.ietf.org/html/rfc5035#section-3">
 * RFC 5035 section 3</a>.
 * <pre>
 * oid-signingCertificateV2 = 1.2.840.113549.1.9.16.2.47
 * Attribute ::= SEQUENCE {
 *    type               OBJECT IDENTIFIER,
 *    values             AttributeSetValue }
 * AttributeSetValue ::= SET OF ANY
 * SigningCertificateV2 ::=  SEQUENCE {
 *    certs        SEQUENCE OF ESSCertIDv2,
 *    policies     SEQUENCE OF PolicyInformation OPTIONAL }
 * ESSCertIDv2 ::=  SEQUENCE {
 *    hashAlgorithm           AlgorithmIdentifier
 *                            DEFAULT {algorithm id-sha256},
 *    certHash                Hash,
 *    issuerSerial            IssuerSerial OPTIONAL }
 * Hash ::= OCTET STRING
 * IssuerSerial ::= SEQUENCE {
 *    issuer                  GeneralNames,
 *    serialNumber            CertificateSerialNumber }
 * </pre>
 *
 * @example
 * new KJUR.asn1.cms.SigningCertificateV2({array: [certPEM]}); // DEFAULT sha256
 * new KJUR.asn1.cms.SigningCertificateV2({array: [certPEM],
 *                                         hashAlg: 'sha512'});
 * new KJUR.asn1.cms.SigningCertificateV2({
 *   array: [
 *     {cert: certPEM1, hashAlg: 'sha512'},
 *     {cert: certPEM2, hashAlg: 'sha256'},
 *     {cert: certPEM3}, // DEFAULT sha256
 *     certPEM4 // DEFAULT sha256
 *   ]
 * })
 * new KJUR.asn1.cms.SigningCertificateV2({
 *   array: [
 *     {cert: certPEM1, hashAlg: 'sha512'},
 *     {cert: certPEM2, hashAlg: 'sha256'},
 *     {cert: certPEM3}, // DEFAULT sha256
 *     certPEM4 // DEFAULT sha256
 *   ]
 * })
 */
KJUR.asn1.cms.SigningCertificateV2 = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_ESSCertIDv2 = _KJUR_asn1_cms.ESSCertIDv2,
	_KJUR_crypto = _KJUR.crypto;

    _KJUR_asn1_cms.SigningCertificateV2.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.16.2.47";

    this.getValueArray = function() {
	if (this.params == null || 
	    this.params == undefined || 
	    this.params.array == undefined) {
	    throw new _Error("parameter 'array' not specified");
	}
	var aESSCertIDv2Param = this.params.array;
	var aESSCertIDv2 = [];
	for (var i = 0; i < aESSCertIDv2Param.length; i++) {
	    var idparam = aESSCertIDv2Param[i];

	    if ((params.alg != undefined ||
		 params.hasis == false) &&
		(typeof idparam == "string" &&
		 (idparam.indexOf("-----BEGIN") != -1 ||
		  ASN1HEX.isASN1HEX(idparam)))) {
		idparam = {cert: idparam};
	    }

	    if (idparam.alg == undefined && params.alg != undefined) {
		idparam.alg = params.alg;
	    }

	    if (idparam.hasis != false && params.hasis == false) {
		idparam.hasis = false;
	    }

	    aESSCertIDv2.push(new _ESSCertIDv2(idparam));
	}
	var dCerts = new _DERSequence({array: aESSCertIDv2});
	var dSigningCertificatev2 = new _DERSequence({array: [dCerts]});
	return [dSigningCertificatev2];
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.SigningCertificateV2, KJUR.asn1.cms.Attribute);

/**
 * class for CMS ESSCertIDv2 ASN.1 encoder<br/>
 * @name KJUR.asn1.cms.ESSCertIDv2
 * @class class for CMS ESSCertIDv2 ASN.1 encoder
 * @param {Object} params PEM certificate string or JSON of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 10.0.0 asn1cms 2.0.0
 * @see KJUR.asn1.cms.SigningCertificate
 * @see KJUR.asn1.cms.IssuerSerial
 * @see KJUR.asn1.cms.ESSCertID
 *
 * @description
 * This is an ASN.1 encoder for SigningCertificateV2 attribute
 * defined in
 * <a href="https://tools.ietf.org/html/rfc5035#section-4">
 * RFC 5035 section 4</a>.
 * <pre>
 * ESSCertIDv2 ::=  SEQUENCE {
 *    hashAlgorithm           AlgorithmIdentifier
 *                            DEFAULT {algorithm id-sha256},
 *    certHash                Hash,
 *    issuerSerial            IssuerSerial OPTIONAL }
 * Hash ::= OCTET STRING
 * IssuerSerial ::= SEQUENCE {
 *    issuer                  GeneralNames,
 *    serialNumber            CertificateSerialNumber }
 * </pre>
 *
 * @example
 * new KJUR.asn1.cms.ESSCertIDv2("-----BEGIN...")
 * new KJUR.asn1.cms.ESSCertIDv2({cert: "-----BEGIN..."})
 * new KJUR.asn1.cms.ESSCertIDv2({cert: "-----BEGIN...", hasis: false})
 * new KJUR.asn1.cms.ESSCertIDv2({
 *   hash: "3f2d...",
 *   alg: "sha512",
 *   issuer: {str: "/C=JP/O=T1"},
 *   serial: {hex: "12ab..."}
 * })
 */
KJUR.asn1.cms.ESSCertIDv2 = function(params) {
    KJUR.asn1.cms.ESSCertIDv2.superclass.constructor.call(this);

    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_DERSequence = _KJUR_asn1.DERSequence,
	_IssuerSerial = _KJUR_asn1.cms.IssuerSerial,
	_AlgorithmIdentifier = _KJUR_asn1.x509.AlgorithmIdentifier;

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	var hCertHash = this.getCertHash(params, 'sha256');

	var a = [];
	if (params.alg != undefined && params.alg != "sha256")
	    a.push(new _AlgorithmIdentifier({name: params.alg}));
	a.push(new _DEROctetString({hex: hCertHash}));
	if ((typeof params == "string" &&
	     params.indexOf("-----BEGIN") != -1) ||
	    (params.cert != undefined &&
	     params.hasis != false) ||
	    (params.issuer != undefined &&
	     params.serial != undefined))
	    a.push(new _IssuerSerial(params));
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.ESSCertIDv2, KJUR.asn1.cms.ESSCertID);

/**
 * class for IssuerSerial ASN.1 structure for CMS<br/>
 * @name KJUR.asn1.cms.IssuerSerial
 * @class class for CMS IssuerSerial ASN.1 structure for CMS
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 8.0.24 asn1cms 1.0.8
 * @see KJUR.asn1.cms.IssuerAndSerialNumber
 * @see KJUR.asn1.cms.SigningCertificate
 * @see KJUR.asn1.cms.SigningCertificateV2
 * @see KJUR.asn1.cms.ESSCertID
 * @see KJUR.asn1.cms.ESSCertIDv2
 * @see KJUR.asn1.x509.GeneralNames
 * @see KJUR.asn1.x509.X500Name
 *
 * @description
 * This class represents IssuerSerial ASN.1 structure
 * used by ESSCertID/v2 of SigningCertificate/V2 attribute
 * defined in 
 * <a href="https://tools.ietf.org/html/rfc5035#page-6">
 * RFC 5034 section 4</a>.
 * <pre>
 * IssuerSerial ::= SEQUENCE {
 *    issuer          GeneralNames,
 *    serialNumber    CertificateSerialNumber }
 * CertificateSerialNumber ::= INTEGER
 * </pre>
 *
 * @example
 * // specify by X500Name parameter and DERInteger
 * o = new KJUR.asn1.cms.IssuerSerial(
 *      {issuer: {str: '/C=US/O=T1'}, serial {int: 3}});
 * // specify by PEM certificate
 * o = new KJUR.asn1.cms.IssuerSerial({cert: certPEM});
 * o = new KJUR.asn1.cms.IssuerSerial(certPEM); // since 1.0.3
 */
KJUR.asn1.cms.IssuerSerial = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_GeneralNames = _KJUR_asn1_x509.GeneralNames,
	_X509 = X509;

    _KJUR_asn1_cms.IssuerSerial.superclass.constructor.call(this);

    this.setByParam = function(params) {
	this.params = params;
    };

    this.tohex = function() {
	var params = this.params;

	var pIssuer, pSerial;
	if ((typeof params == "string" &&
	     params.indexOf("-----BEGIN") != -1) ||
	    params.cert != undefined) {
	    var pem;

	    if (params.cert != undefined) {
		pem = params.cert;
	    } else {
		pem = params;
	    }

	    var x = new _X509();
	    x.readCertPEM(pem);
	    pIssuer = x.getIssuer();
	    pSerial = {hex: x.getSerialNumberHex()};
	} else if (params.issuer != undefined && params.serial) {
	    pIssuer = params.issuer;
	    pSerial = params.serial;
	} else {
	    throw new _Error("cert or issuer and serial parameter not specified");
	}
	
	var dIssuer = new _GeneralNames([{dn: pIssuer}]);
	var dSerial = new _DERInteger(pSerial);
	var seq = new _DERSequence({array: [dIssuer, dSerial]});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.IssuerSerial, KJUR.asn1.ASN1Object);

/**
 * class for SignerIdentifier ASN.1 structure for CMS
 * @name KJUR.asn1.cms.SignerIdentifier
 * @class class for CMS SignerIdentifier ASN.1 structure for CMS
 * @param {Array} params JSON object of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 10.0.0 asn1cms 2.0.0
 * @see KJUR.asn1.cms.SignedData
 * @see KJUR.asn1.cms.SignerInfo
 * @see KJUR.asn1.cms.IssuerAndSerialNumber
 * @see KJUR.asn1.cms.SubjectKeyIdentifier
 * @see KJUR.asn1.x509.X500Name
 *
 * @description
 * This is an ASN.1 encoder for SignerIdentifier
 * ASN.1 structure defined in
 * <a href="https://tools.ietf.org/html/rfc5652#section-5.3">
 * RFC 5652 CMS section 5.3</a>.
 * <pre>
 * SignerIdentifier ::= CHOICE {
 *    issuerAndSerialNumber IssuerAndSerialNumber,
 *    subjectKeyIdentifier [0] SubjectKeyIdentifier }
 * </pre>
 * Constructor argument can have following properties:
 * <ul>
 * <li>{String}type - "isssn" for IssuerAndSerialNumber or "skid"
 * for SubjectKeyIdentifier</li>
 * <li>{Array}issuer - {@link KJUR.asn1.x509.X500Name} parameter for issuer</li>
 * <li>{Array}serial - {@link KJUR.asn1.DERInteger} parameter for serial number</li>
 * <li>{String}skid - hexadecimal string of subject key identifier</li>
 * <li>{String}cert - PEM certificate string for type "isssn" or "skid"</li>
 * </ul>
 * Constructor argument properties can have following combination:
 * <ul>
 * <li>type=isssn, issuer, serial - IssuerAndSerialNumber</li>
 * <li>type=isssn, cert - IssuerAndSerialNumber</li>
 * <li>type=skid, skid - SubjectKeyIdentifier</li>
 * <li>type=skdi, cert - SubjectKeyIdentifier</li>
 * </ul>
 *
 * @example
 * new KJUR.asn1.cms.SignerIdentifier({
 *   type: "isssn",
 *   issuer: {str: "/C=JP/O=T1"},
 *   serial: {hex: "12ab..."}
 * })
 * new KJUR.asn1.cms.SignerIdentifier({
 *   type: "isssn",
 *   cert: "-----BEGIN..."
 * })
 * new KJUR.asn1.cms.SignerIdentifier({
 *   type: "skid",
 *   skid: "12ab..."
 * })
 * new KJUR.asn1.cms.SignerIdentifier({
 *   type: "skid",
 *   cert: "-----BEGIN..."
 * })
 */
KJUR.asn1.cms.SignerIdentifier = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_IssuerAndSerialNumber = _KJUR_asn1_cms.IssuerAndSerialNumber,
	_SubjectKeyIdentifier = _KJUR_asn1_cms.SubjectKeyIdentifier,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_X500Name = _KJUR_asn1_x509.X500Name,
	_X509 = X509,
	_Error = Error;

    _KJUR_asn1_cms.SignerIdentifier.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;
	if (params.type == "isssn") {
	    var dISSSN = new _IssuerAndSerialNumber(params);
	    return dISSSN.tohex();
	} else if (params.type == "skid") {
	    var dSKID = new _SubjectKeyIdentifier(params);
	    return dSKID.tohex();
	} else {
	    throw new Error("wrong property for isssn or skid");
	}
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.SignerIdentifier, KJUR.asn1.ASN1Object);

/**
 * class for IssuerAndSerialNumber ASN.1 structure for CMS<br/>
 * @name KJUR.asn1.cms.IssuerAndSerialNumber
 * @class class for CMS IssuerAndSerialNumber ASN.1 structure for CMS
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.2.4 asn1cms 1.0.0
 * @see KJUR.asn1.cms.IssuerSerial
 *
 * @description
 * This class encodes IssuerAndSerialNumber ASN.1 structure defined in
 * <a href="https://tools.ietf.org/html/rfc5652#section-10.2.4">
 * RFC 5662 CMS 10.2.4</a>. 
 * <pre>
 * IssuerAndSerialNumber ::= SEQUENCE {
 *    issuer           Name,
 *    serialNumber     CertificateSerialNumber }
 * CertificateSerialNumber ::= INTEGER
 * </pre>
 * Constructor of this class can have following parameters:
 * <ul>
 * <li>{String}cert (OPTION) - PEM certificate string to specify issuer and serial</li>
 * <li>{Array}issuer (OPTION) - {@link KJUR.asn1.x509.X500Name} parameter for issuer name</li>
 * <li>{Array}serial (OPTION) - {@link KJUR.asn1.DERInteger} parameter for serialNumber</li>
 * </ul>
 *
 * @example
 * // specify by X500Name and DERInteger
 * o = new KJUR.asn1.cms.IssuerAndSerialNumber(
 *      {issuer: {str: '/C=US/O=T1'}, serial: {int: 3}});
 * // specify by PEM certificate
 * o = new KJUR.asn1.cms.IssuerAndSerialNumber({cert: certPEM});
 * o = new KJUR.asn1.cms.IssuerAndSerialNumber(certPEM); // since 1.0.3
 */
KJUR.asn1.cms.IssuerAndSerialNumber = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_X500Name = _KJUR_asn1_x509.X500Name,
	_X509 = X509,
	_Error = Error;

    _KJUR_asn1_cms.IssuerAndSerialNumber.superclass.constructor.call(this);
    
    this.params = null;

    this.tohex = function() {
	var params = this.params;

	var pIssuer, pSerial;
	if ((typeof params == "string" && params.indexOf("-----BEGIN") != -1) ||
	    params.cert != undefined) {
	    var pem;

	    if (params.cert != undefined) {
		pem = params.cert;
	    } else {
		pem = params;
	    }

	    var x = new _X509();
	    x.readCertPEM(pem);
	    pIssuer = x.getIssuer();
	    pSerial = {hex: x.getSerialNumberHex()};
	} else if (params.issuer != undefined && params.serial) {
	    pIssuer = params.issuer;
	    pSerial = params.serial;
	} else {
	    throw new _Error("cert or issuer and serial parameter not specified");
	}
	
	var dIssuer = new _X500Name(pIssuer);
	var dSerial = new _DERInteger(pSerial);
	var seq = new _DERSequence({array: [dIssuer, dSerial]});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.setByParam = function(params) {
	this.params = params;
    }

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.IssuerAndSerialNumber, KJUR.asn1.ASN1Object);

/**
 * class for SubjectKeyIdentifier ASN.1 structure for CMS SignerInfo<br/>
 * @name KJUR.asn1.cms.SubjectKeyIdentifier
 * @class class for SubjectKeyIdentifier ASN.1 structure for CMS SignerInfo
 * @param {Array} params JSON object of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 10.0.0 asn1cms 2.0.0
 *
 * @description
 * This class encodes SubjectKeyIdentifier ASN.1 structure defined in
 * <a href="https://tools.ietf.org/html/rfc5652#section-12.1">
 * RFC 5652 CMS 12.1</a>. 
 * <pre>
 * SubjectKeyIdentifier ::= OCTET STRING
 * </pre>
 *
 * @example
 * new KJUR.asn1.cms.SubjectKeyIdentifier({cert: "-----BEGIN..."})
 * new KJUR.asn1.cms.SubjectKeyIdentifier({skid: "12ab..."})
 */
KJUR.asn1.cms.SubjectKeyIdentifier = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERSequence = _KJUR_asn1.DERSequence,
	_newObject = _KJUR_asn1.ASN1Util.newObject,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_IssuerAndSerialName = _KJUR_asn1_cms.IssuerAndSerialName,
	_SubjectKeyIdentifier = _KJUR_asn1_cms.SubjectKeyIdentifier,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_X500Name = _KJUR_asn1_x509.X500Name,
	_X509 = X509,
	_Error = Error;

    _KJUR_asn1_cms.SubjectKeyIdentifier.superclass.constructor.call(this);

    this.tohex = function() {
	var params = this.params;

	if (params.cert == undefined && params.skid == undefined)
	    throw new _Error("property cert nor skid undefined");

	var hSKID;
	if (params.cert != undefined) {
	    var x = new _X509(params.cert);
	    var pSKID = x.getExtSubjectKeyIdentifier();
	    hSKID = pSKID.kid.hex;
	} else if (params.skid != undefined) {
	    hSKID = params.skid;
	}
	var dSKID = 
	    _newObject({tag:{tage:"a0",obj:{octstr:{hex:hSKID}}}});
	return dSKID.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.SubjectKeyIdentifier, KJUR.asn1.ASN1Object);

/**
 * class for Attributes ASN.1 structure for CMS<br/>
 * @name KJUR.asn1.cms.AttributeList
 * @class class for Attributes ASN.1 structure for CMS
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.2.4 asn1cms 1.0.0
 *
 * @description
 * <pre>
 * Attributes ::= SET OF Attribute
 * Attribute ::= SEQUENCE {
 *    type               OBJECT IDENTIFIER,
 *    values             AttributeSetValue }
 * </pre>
 *
 * @example
 * new KJUR.asn1.cms.AttributeList({
 *   array: [{
 *     attr: "contentType",
 *     type: "data"
 *   }],
 *   sortflag: false
 * })
 */
KJUR.asn1.cms.AttributeList = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSet = _KJUR_asn1.DERSet,
	_KJUR_asn1_cms = _KJUR_asn1.cms;

    _KJUR_asn1_cms.AttributeList.superclass.constructor.call(this);

    this.params = null;
    this.hTLV = null;

    this.setByParam = function(params) {
	this.params = params;
    };

    this.tohex = function() {
	var params = this.params;
	if (this.hTLV != null) return this.hTLV;

	var sortflag = true;
	if (params.sortflag != undefined) {
	    sortflag = params.sortflag;
	}

        var aAttrParam = params.array;
	var a = [];
	for (var i = 0; i < aAttrParam.length; i++) {
	    var pAttr = aAttrParam[i];
	    var attrName = pAttr.attr;
	    if (attrName == "contentType") {
		a.push(new _KJUR_asn1_cms.ContentType(pAttr));
	    } else if (attrName == "messageDigest") {
		a.push(new _KJUR_asn1_cms.MessageDigest(pAttr));
	    } else if (attrName == "signingTime") {
		a.push(new _KJUR_asn1_cms.SigningTime(pAttr));
	    } else if (attrName == "signingCertificate") {
		a.push(new _KJUR_asn1_cms.SigningCertificate(pAttr));
	    } else if (attrName == "signingCertificateV2") {
		a.push(new _KJUR_asn1_cms.SigningCertificateV2(pAttr));
	    } else if (attrName == "signaturePolicyIdentifier") {
		a.push(new KJUR.asn1.cades.SignaturePolicyIdentifier(pAttr));
	    } else if (attrName == "signatureTimeStamp" ||
		       attrName == "timeStampToken") {
		a.push(new KJUR.asn1.cades.SignatureTimeStamp(pAttr));
	    } else {
		throw new _Error("unknown attr: " + attrName);
	    }
	}
	
	var dSet = new _DERSet({array: a, sortflag: sortflag});
	this.hTLV = dSet.tohex();
	return this.hTLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.AttributeList, KJUR.asn1.ASN1Object);

/**
 * class for SignerInfo ASN.1 structure of CMS SignedData<br/>
 * @name KJUR.asn1.cms.SignerInfo
 * @class class for Attributes ASN.1 structure of CMS SigndData
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.2.4 asn1cms 1.0.0
 * @see KJUR.asn1.cms.SignerIdentifier
 * @see KJUR.asn1.x509.AlgorithmIdentifier
 * @see KJUR.asn1.cms.AttributeList
 *
 * @description
 * This class is an ASN.1 encoder for SignerInfo structure
 * defined in
 * <a https://tools.ietf.org/html/rfc5652#section-5.3">
 * RFC 5652 CMS section 5.3</a>.
 * <pre>
 * SignerInfo ::= SEQUENCE {
 *    version CMSVersion,
 *    sid SignerIdentifier,
 *    digestAlgorithm DigestAlgorithmIdentifier,
 *    signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,
 *    signatureAlgorithm SignatureAlgorithmIdentifier,
 *    signature SignatureValue,
 *    unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL }
 * </pre>
 * Constractor parameter can have following properties:
 * <ul>
 * <li>{Integer}version - version of SignerInfo. </li>
 * <li>{Array}id - {@link KJUR.asn1.cms.SignerIdentifier} parameter for sid</li>
 * <li>{String}hashalg - digestAlgorithm name string (ex. "sha256")</li>
 * <li>{Array}sattrs - {@link KJUR.asn1.cms.AttributeList} parameter for 
 * signedAttributes</li>
 * <li>{String}sigalg - string for signatureAlgorithm name</a>
 * <li>{String}signkey (OPTION) - specifies signing private key.
 * Parameter "signkey" or "sighex" shall be specified. Following
 * values can be specified:
 *   <ul>
 *   <li>PKCS#1/5 or PKCS#8 PEM string of private key</li>
 *   <li>RSAKey/DSA/ECDSA key object. {@link KEYUTIL.getKey} is useful
 *   to generate a key object.</li>
 *   </ul>
 * </li>
 * <li>{String}sighex (OPTION) - hexadecimal string of signature value
 * (i.e. ASN.1 value(V) of signatureValue BIT STRING without
 * unused bits)</li>
 * </ul>
 *
 * @example
 * new KJUR.asn1.cms.SignerInfo({
 *   version: 1,
 *   id: {type: 'isssn', issuer: {str: '/C=US/O=T1'}, serial: {int: 1}},
 *   hashalg: "sha1",
 *   sattrs: {array: [{
 *     attr: "contentType",
 *     type: '1.2.840.113549.1.7.1'
 *   },{
 *     attr: "messageDigest",
 *     hex: 'a1a2a3a4a5a6a7a8a9a0a1a2a3a4a5a6a7a8a9a0'
 *   }]},
 *   sigalg: "SHA1withRSA",
 *   sighex: 'b1b2b...'
 * })
 */
KJUR.asn1.cms.SignerInfo = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_SignerIdentifier = _KJUR_asn1_cms.SignerIdentifier,
	_AttributeList = _KJUR_asn1_cms.AttributeList,
	_ContentType = _KJUR_asn1_cms.ContentType,
	_EncapsulatedContentInfo = _KJUR_asn1_cms.EncapsulatedContentInfo,
	_MessageDigest = _KJUR_asn1_cms.MessageDigest,
	_SignedData = _KJUR_asn1_cms.SignedData,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_AlgorithmIdentifier = _KJUR_asn1_x509.AlgorithmIdentifier,
	_KJUR_crypto = _KJUR.crypto,
	_KEYUTIL = KEYUTIL;

    _KJUR_asn1_cms.SignerInfo.superclass.constructor.call(this);

    this.params = null;
    
    /**
     * sign SignerInfo<br/>
     * @name sign
     * @memberOf KJUR.asn1.cms.SignerInfo#
     * @function
     *
     * @description
     * This method signs SignerInfo with a specified 
     * private key and algorithm by 
     * "params.signkey" and "params.sigalg" parameter.
     * In general, you don't need to call this method.
     * It will be called when tohex() method if necessary.
     *
     * @example
     * si = new KJUR.asn1.cms.SignerInfo({...});
     * si.sign()
     */
    this.sign = function() {
	var params = this.params;
	var sigalg = params.sigalg;

	var hData = (new _AttributeList(params.sattrs)).tohex();
	var prvkey = null;
	var sig;
	if (params.provName === undefined || params.provName.substr(0, 6) !== 'pkcs11') {
		prvkey = _KEYUTIL.getKey(params.signkey, params.signkeypass);
		sig = new _KJUR_crypto.Signature({alg: sigalg});
	 }
	 else {
	   prvkey = params.signkey;
	   sig = new _KJUR_crypto.adds.HSMSignature({alg: sigalg, prov: params.provName, provInfo: params.provInfo});
	 }
	   
	sig.init(prvkey);
	sig.updateHex(hData);
	var hSig = sig.sign();
	params.sighex = hSig;
    };

    this.tohex = function() {
	var params = this.params;

	var a = [];
        a.push(new _DERInteger({"int": params.version}));
	a.push(new _SignerIdentifier(params.id));
	a.push(new _AlgorithmIdentifier({name: params.hashalg}));
	if (params.sattrs != undefined) {
	    var dList = new _AttributeList(params.sattrs);
	    try {
		a.push(new _DERTaggedObject({tag: "a0", 
					     explicit: false,
					     obj: dList}));
	    } catch(ex) {
		throw new _Error("si sattr error: " + ex);
	    }
	}

	if (params.sigalgfield != undefined) {
	    a.push(new _AlgorithmIdentifier({name: params.sigalgfield}));
	} else {
	    a.push(new _AlgorithmIdentifier({name: params.sigalg}));
	}

	if (params.sighex == undefined &&
	    params.signkey != undefined) {
	    this.sign();
	}
	a.push(new _DEROctetString({hex: params.sighex}));

	if (params.uattrs != undefined) {
	    var dList = new _AttributeList(params.uattrs);
	    try {
		a.push(new _DERTaggedObject({tag: "a1", 
					     explicit: false,
					     obj: dList}));
	    } catch(ex) {
		throw new _Error("si uattr error: " + ex);
	    }
	}

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.SignerInfo, KJUR.asn1.ASN1Object);

/**
 * class for EncapsulatedContentInfo ASN.1 structure for CMS<br/>
 * @name KJUR.asn1.cms.EncapsulatedContentInfo
 * @class class for EncapsulatedContentInfo ASN.1 structure for CMS
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.2.4 asn1cms 1.0.0
 *
 * @description
 * <pre>
 * EncapsulatedContentInfo ::= SEQUENCE {
 *    eContentType ContentType,
 *    eContent [0] EXPLICIT OCTET STRING OPTIONAL }
 * ContentType ::= OBJECT IDENTIFIER
 * </pre>
 *
 * @example
 * new KJUR.asn1.cms.EncapsulatedContentInfo({
 *  type: "data",
 *  content: {str: "aaa"}
 * })
 * new KJUR.asn1.cms.EncapsulatedContentInfo({
 *  type: "data",
 *  content: {hex: "616161"}
 * })
 * new KJUR.asn1.cms.EncapsulatedContentInfo({
 *  type: "data",
 *  content: {hex: "616161"},
 *  isDetached: true
 * })
 * new KJUR.asn1.cms.EncapsulatedContentInfo({
 *  type: "tstinfo",
 *  content: ...TSTInfo parameters...
 * })
 */
KJUR.asn1.cms.EncapsulatedContentInfo = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_KJUR_asn1_cms = _KJUR_asn1.cms;

    _KJUR_asn1_cms.EncapsulatedContentInfo.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	var a = [];

	a.push(new _DERObjectIdentifier(params.type));

	if (params.content != undefined &&
	    (params.content.hex != undefined || 
	     params.content.str != undefined) &&
	    params.isDetached != true) {
	    var dOctStr = new _DEROctetString(params.content);
	    var dEContent = new _DERTaggedObject({tag: "a0",
						  explicit: true,
						  obj: dOctStr});
	    a.push(dEContent);
	}

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.setByParam = function(params) {
	this.params = params;
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.EncapsulatedContentInfo, KJUR.asn1.ASN1Object);

// - type
// - obj
/**
 * class for ContentInfo ASN.1 structure for CMS
 * @name KJUR.asn1.cms.ContentInfo
 * @class class for ContentInfo ASN.1 structure for CMS
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.2.4 asn1cms 1.0.0
 * @description
 * <pre>
 * ContentInfo ::= SEQUENCE {
 *    contentType ContentType,
 *    content [0] EXPLICIT ANY DEFINED BY contentType }
 * ContentType ::= OBJECT IDENTIFIER
 * </pre>
 * @example
 * a = [new KJUR.asn1.DERInteger({int: 1}),
 *      new KJUR.asn1.DERInteger({int: 2})];
 * seq = new KJUR.asn1.DERSequence({array: a});
 * o = new KJUR.asn1.cms.ContentInfo({type: 'data', obj: seq});
 */
KJUR.asn1.cms.ContentInfo = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_name2obj = _KJUR_asn1_x509.OID.name2obj;

    KJUR.asn1.cms.ContentInfo.superclass.constructor.call(this);
    
    this.params = null;

    this.tohex = function() {
	var params = this.params;

	var a = [];
	a.push(new _DERObjectIdentifier(params.type));

	var dContent0 = new _DERTaggedObject({
	    tag: "a0",
	    explicit: true,
	    obj: params.obj
	});
	a.push(dContent0);

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.setByParam = function(params) {
	this.params = params;
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.ContentInfo, KJUR.asn1.ASN1Object);

/**
 * class for SignerInfo ASN.1 structure of CMS SignedData
 * @name KJUR.asn1.cms.SignedData
 * @class class for Attributes ASN.1 structure of CMS SigndData
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.2.4 asn1cms 1.0.0
 *
 * @description
 * <pre>
 * ContentInfo ::= SEQUENCE {
 *    contentType ContentType,
 *    content [0] EXPLICIT ANY DEFINED BY contentType }
 * ContentType ::= OBJECT IDENTIFIER
 * SignedData ::= SEQUENCE {
 *    version CMSVersion,
 *    digestAlgorithms DigestAlgorithmIdentifiers,
 *    encapContentInfo EncapsulatedContentInfo,
 *    certificates [0] IMPLICIT CertificateSet OPTIONAL,
 *    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
 *    signerInfos SignerInfos }
 * SignerInfos ::= SET OF SignerInfo
 * CertificateSet ::= SET OF CertificateChoices
 * DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier
 * CertificateSet ::= SET OF CertificateChoices
 * RevocationInfoChoices ::= SET OF RevocationInfoChoice
 * </pre>
 *
 * @example
 * sd = new KJUR.asn1.cms.SignedData({
 *   version: 1,
 *   hashalgs: ["sha1"],
 *   econtent: {
 *     type: "data",
 *     content: {
 *       hex: "616161"
 *     }
 *   },
 *   certs: [PEM1,...],
 *   revinfos: {array: [...]},
 *   sinfos: [{
 *     version: 1,
 *     id: {type:'isssn', issuer: {str: '/C=US/O=T1'}, serial: {int: 1}},
 *     hashalg: "sha1",
 *     sattrs: {array: [{
 *       attr: "contentType",
 *       type: '1.2.840.113549.1.7.1'
 *     },{
 *       attr: "messageDigest",
 *       hex: 'abcd'
 *     }]},
 *     sigalg: "SHA1withRSA",
 *     signkey: PEMPRIVATEKEY
 *   }]
 * });
 * hex = sd.getContentInfoEncodedHex();
 */
KJUR.asn1.cms.SignedData = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_ASN1Object = _KJUR_asn1.ASN1Object,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERSet = _KJUR_asn1.DERSet,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_EncapsulatedContentInfo = _KJUR_asn1_cms.EncapsulatedContentInfo,
	_SignerInfo = _KJUR_asn1_cms.SignerInfo,
	_ContentInfo = _KJUR_asn1_cms.ContentInfo,
	_CertificateSet = _KJUR_asn1_cms.CertificateSet,
	_RevocationInfoChoices = _KJUR_asn1_cms.RevocationInfoChoices,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_AlgorithmIdentifier = _KJUR_asn1_x509.AlgorithmIdentifier;

    KJUR.asn1.cms.SignedData.superclass.constructor.call(this);

    this.params = null;

    /**
     * fix fields before ASN.1 encode<br/>
     * @name checkAndFixParam
     * @memberOf KJUR.asn1.cms.SignedData#
     * @function
     *
     * @description
     * Update following values of "params" property
     * as defined in RFC 5652:
     * <ul>
     * <li>set "digestAlgorithms" field of "signedData" by
     * signerInfos</li>
     * <li>set all "contentType" signed attribute value to
     * the same value of eContent</li>
     * <li>set all "messageDigest" signed attribute value
     * to hash value of eContent contents value</li>
     * <li>all signerInfo version by their fields</li>
     * <li>signedData version by their fields</li>
     * </ul>
     * In general, you don't need to call this method.
     * It will be called automatically when
     * getEncodedHex() method is called.
     * <br>
     * NOTE: If you don't want to do such property value
     * update, set "params.fixed" property to "true".
     */
    this.checkAndFixParam = function() {
	var sdparams = this.params;
	this._setDigestAlgs(sdparams);
	this._setContentTypeByEContent(sdparams);
	this._setMessageDigestByEContent(sdparams);
	this._setSignerInfoVersion(sdparams);
	this._setSignedDataVersion(sdparams);
    };

    /*
     * @description
     * Get params.sinfos[*].hashalg for all "signerInfo"
     * and set "params.hashalgs" of "signedData" as
     * array of hash algorithm names.
     */
    this._setDigestAlgs = function(sdparams) {
	var pHash = {};
	var sinfos = sdparams.sinfos;
	for (var i = 0; i < sinfos.length; i++) {
	    var sinfo = sinfos[i];
	    pHash[sinfo.hashalg] = 1;
	}
	sdparams.hashalgs = Object.keys(pHash).sort();
    };

    /*
     * @description
     * set "contentType" attribute value in 
     * "params.sinfos[*].sattrs" to "params.econtent.type"
     * value.
     */
    this._setContentTypeByEContent = function(sdparams) {
	var type = sdparams.econtent.type;
	var sinfos = sdparams.sinfos;
	for (var i = 0; i < sinfos.length; i++) {
	    var sinfo = sinfos[i];
	    var ctParam = this._getAttrParamByName(sinfo, "contentType");
	    //console.log(ctParam.type + " > " + type);
            if (ctParam !== undefined) 
	        ctParam.type = type;
	}
    };

    /*
     * @description
     * set "messageDigest" attribute value in
     * "params.sinfos[*].sattrs" to a
     * calculated hash value by "econtent.content.hex"
     * with "params.sinfos[*].hashalg" algorithm.
     */
    this._setMessageDigestByEContent = function(sdparams) {
	var econtent = sdparams.econtent;
	var type = sdparams.econtent.type;

	var hContent = econtent.content.hex;
	if (hContent == undefined &&
	    econtent.type == "data" &&
	    econtent.content.str != undefined) {
	    hContent = rstrtohex(econtent.content.str);
	}

	var sinfos = sdparams.sinfos;
	for (var i = 0; i < sinfos.length; i++) {
	    var sinfo = sinfos[i];
	    var hashalg = sinfo.hashalg;
	    var mdParam = this._getAttrParamByName(sinfo, "messageDigest");
	    if (mdParam !== undefined && hContent !== undefined) {  
	       var hNew = KJUR.crypto.Util.hashHex(hContent, hashalg);

	       //console.log(mdParam.hex + " > " + hNew);
	       mdParam.hex = hNew;
	    }
	}
    };

    /*
     * @param {Array}siParam "signerInfo" JSON parameter reference
     * @param {String}attrName attribute name string
     * @return {Array} attribute JSON parameter reference
     * @description
     * Find signed attribute parameter from signerInfo parameter
     * by attribute name.
     */
    this._getAttrParamByName = function(siParam, attrName) {
	if (siParam.sattrs === undefined)
	    return;
	var aSattrs = siParam.sattrs.array;
	for (var i = 0; i < aSattrs.length; i++) {
	    if (aSattrs[i].attr == attrName) return aSattrs[i];
	}
    };

    /*
     * @description
     * set signerInfo version "params.sinfos[*].version" 
     * of all signerInfos by signerInfo parameter.
     * Version will be identified by "signerIdentifier" is
     * "skid" or not.
     */
    this._setSignerInfoVersion = function(sdparams) {
	var sinfos = sdparams.sinfos;
	for (var i = 0; i < sinfos.length; i++) {
	    var sinfo = sinfos[i];
	    var newVersion = 1;
	    if (sinfo.id.type == "skid") newVersion = 3;
	    sinfo.version = newVersion;
	}
    };

    /*
     * @description
     * set "signedData" version "params.version"
     * to value by _getSignedDataVersion()
     */
    this._setSignedDataVersion = function(sdparams) {
	var newVersion = this._getSignedDataVersion(sdparams);
	//console.log("sd version: " + sdparams.version + " > " + newVersion);
	sdparams.version = newVersion;
    };

    /*
     * @description
     * get "signedData" version from parameters.
     * If "revinfos" "ocsp" exists, then version 5.
     * If "signerInfo" version 3 exists, then version 3.
     * If "params.econtent.type" is not "data" then version 3.
     * Otherwise version 1.
     */
    this._getSignedDataVersion = function(sdparams) {
	//alert(JSON.stringify(sdparams));

	if (sdparams.revinfos != undefined) {
	    var revinfos = sdparams.revinfos;
	    for (var i = 0; i < revinfos.length; i++) {
		var revinfo = revinfos[i];
		if (revinfo.ocsp != undefined) return 5;
	    }
	}

	var sinfos = sdparams.sinfos;
	for (var i = 0; i < sinfos.length; i++) {
	    var sinfo = sdparams.sinfos[i];
	    if (sinfo.version == 3) return 3;
	}

	if (sdparams.econtent.type != "data") return 3;
	return 1;
    };

    this.tohex = function() {
	var params = this.params;

	if (this.getEncodedHexPrepare != undefined) {
	    this.getEncodedHexPrepare();
	}

	if (params.fixed != true) {
	    this.checkAndFixParam();
	}

	var a = [];

	a.push(new _DERInteger({"int": params.version}));

	var aHashAlg = [];
	for (var i = 0; i < params.hashalgs.length; i++) {
	    var name = params.hashalgs[i];
	    aHashAlg.push(new _AlgorithmIdentifier({name: name}));
	}
	a.push(new _DERSet({array: aHashAlg}));

	a.push(new _EncapsulatedContentInfo(params.econtent));

	if (params.certs != undefined) {
	    a.push(new _CertificateSet(params.certs));
	}

	if (params.revinfos != undefined) {
	    a.push(new _RevocationInfoChoices(params.revinfos));
	}

	var aSignerInfo = [];
	for (var i = 0; i < params.sinfos.length; i++) {
	    var pSI = params.sinfos[i];
	    aSignerInfo.push(new _SignerInfo(pSI));
	}
	a.push(new _DERSet({array: aSignerInfo}));

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    /**
     * get CotentInfo ASN.1 object concluding CMS SignedData<br/>
     * @name getContentInfo
     * @memberOf KJUR.asn1.cms.SignedData#
     * @function
     * @return {Object} ContentInfo of SigneData as {@link KJUR.asn1.ASN1Object}
     * @see KJUR.asn1.cms.ContentInfo
     *
     * @description
     * This method returns a {@link KJUR.asn1.ASN1Object}
     * of 
     * ContentInfo concludes SignedData.
     *
     * @example
     * sd = new KJUR.asn1.cms.SignedData({...});
     * sd.getContentInfo();
     */
    this.getContentInfo = function() {
	var dContentInfo = new _ContentInfo({
	    type: 'signed-data',
	    obj: this
	});
	return dContentInfo;
    };

    /**
     * get hex of entire ContentInfo of CMS SignedData<br/>
     * @name getContentInfoEncodedHex
     * @memberOf KJUR.asn1.cms.SignedData#
     * @function
     * @return {String} hexadecimal string of entire ContentInfo of CMS SignedData
     * @see KJUR.asn1.cms.SignedData#getContentInfo
     * @see KJUR.asn1.cms.ContentInfo
     *
     * @description
     * This method returns a hexadecimal string of
     * ContentInfo concludes SignedData.
     *
     * @example
     * sd = new KJUR.asn1.cms.SignedData({...});
     * sd.getContentInfoEncodedHex() &rarr "3082..."
     */
    this.getContentInfoEncodedHex = function() {
	return this.getContentInfo().tohex();
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.SignedData, KJUR.asn1.ASN1Object);

/**
 * class for CertificateSet ASN.1 structure for CMS SignedData<br/>
 * @name KJUR.asn1.cms.CertificateSet
 * @class class for CertificateSet ASN.1 structure for CMS SignedData
 * @param {Array} params array of RevocationInfoChoice parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 10.0.0 asn1cms 2.0.0
 * @see KJUR.asn1.cms.SignedData
 * @see KJUR.asn1.cms.RevocationInfoChoice
 *
 * @description
 * This is an ASN.1 encoder for CertificateSet
 * ASN.1 structure defined in
 * <a href="https://tools.ietf.org/html/rfc5652#section-10.2.3">
 * RFC 5652 CMS section 10.2.3</a> and 
 * <a href="https://tools.ietf.org/html/rfc5652#section-10.2.2">
 * section 10.2.2</a>.
 * <pre>
 * CertificateSet ::= SET OF CertificateChoices
 * CertificateChoices ::= CHOICE {
 *   certificate Certificate,
 *   extendedCertificate [0] IMPLICIT ExtendedCertificate, -- Obsolete
 *   v1AttrCert [1] IMPLICIT AttributeCertificateV1,       -- Obsolete
 *   v2AttrCert [2] IMPLICIT AttributeCertificateV2,
 *   other [3] IMPLICIT OtherCertificateFormat }
 * OtherCertificateFormat ::= SEQUENCE {
 *   otherCertFormat OBJECT IDENTIFIER,
 *   otherCert ANY DEFINED BY otherCertFormat }
 * </pre>
 * Currently only "certificate" is supported in
 * CertificateChoices.
 * 
 * @example
 * new KJUR.asn1.cms.CertificateSet([certpem1,certpem2,...])
 * new KJUR.asn1.cms.CertificateSet({
 *   array: [certpem1,certpem2,...],
 *   sortflag: false
 * })
 */
KJUR.asn1.cms.CertificateSet = function(params) {
    KJUR.asn1.cms.CertificateSet.superclass.constructor.call(this);

    var _Error = Error,
	_KJUR_asn1 = KJUR.asn1,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_DERSet = _KJUR_asn1.DERSet,
	_ASN1Object = _KJUR_asn1.ASN1Object;

    this.params = null;

    this.tohex = function() {
	var params = this.params;
	var a = [];

	var aParam;
	if (params instanceof Array) {
	    aParam = params;
	} else if (params.array != undefined) {
	    aParam = params.array;
	} else {
	    throw new _Error("cert array not specified");
	}

	for (var i = 0; i < aParam.length; i++) {
	    var pem = aParam[i];
	    var hCert;
	    if (pem.substring(0,2) === '30')
		hCert = pem
	    else 
		hCert = pemtohex(pem);
	    var dCert = new _ASN1Object();
	    dCert.hTLV = hCert;
	    a.push(dCert);
	}
	var pSet = {array: a};
	if (params.sortflag == false) pSet.sortflag = false;
	var dSet = new _DERSet(pSet);

	var dTagObj = new _DERTaggedObject({
	    tag: "a0",
	    explicit: false,
	    obj: dSet
	});
	return dTagObj.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.CertificateSet, KJUR.asn1.ASN1Object);

/**
 * class for RevocationInfoChoices ASN.1 structure for CMS SignedData<br/>
 * @name KJUR.asn1.cms.RevocationInfoChoices
 * @class class for RevocationInfoChoices ASN.1 structure for CMS SignedData
 * @param {Array} params array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 10.0.0 asn1cms 2.0.0
 * @see KJUR.asn1.cms.SignedData
 *
 * @description
 * This is an ASN.1 encoder for RevocationInfoChoices
 * ASN.1 structure defined in
 * <a href="https://tools.ietf.org/html/rfc5652#section-10.2.1">
 * RFC 5652 CMS section 10.2.1</a>.
 * <pre>
 * RevocationInfoChoices ::= SET OF RevocationInfoChoice
 * RevocationInfoChoice ::= CHOICE {
 *   crl CertificateList,
 *   other [1] IMPLICIT OtherRevocationInfoFormat }
 * OtherRevocationInfoFormat ::= SEQUENCE {
 *   otherRevInfoFormat OBJECT IDENTIFIER,
 *   otherRevInfo ANY DEFINED BY otherRevInfoFormat }
 * </pre>
 *
 * @example
 * new KJUR.asn1.cms.RevocationInfoChoices([
 *   {crl: CRLPEMorHex1},
 *   {ocsp: OCSPResponseHex1},
 *   ...
 * ]})
 */
KJUR.asn1.cms.RevocationInfoChoices = function(params) {
    KJUR.asn1.cms.RevocationInfoChoices.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	if (! params instanceof Array)
	    throw new Error("params is not array");

	var a = [];
	for (var i = 0; i < params.length; i++) {
	    a.push(new KJUR.asn1.cms.RevocationInfoChoice(params[i]));
	}
	var dRevInfos = KJUR.asn1.ASN1Util.newObject({tag: {tagi:"a1",obj:{set:a}}});
	return dRevInfos.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.RevocationInfoChoices, KJUR.asn1.ASN1Object);

/**
 * class for RevocationInfoChoice ASN.1 structure for CMS SignedData<br/>
 * @name KJUR.asn1.cms.RevocationInfoChoice
 * @class class for RevocationInfoChoice ASN.1 structure for CMS SignedData
 * @param {Array} params array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 10.0.0 asn1cms 2.0.0
 * @see KJUR.asn1.cms.SignedData
 * @see KJUR.asn1.cms.RevocationInfoChoices
 *
 * @description
 * This is an ASN.1 encoder for RevocationInfoChoice
 * ASN.1 structure defined in
 * <a href="https://tools.ietf.org/html/rfc5652#section-10.2.1">
 * RFC 5652 CMS section 10.2.1</a>.
 * <pre>
 * RevocationInfoChoice ::= CHOICE {
 *   crl CertificateList,
 *   other [1] IMPLICIT OtherRevocationInfoFormat }
 * OtherRevocationInfoFormat ::= SEQUENCE {
 *   otherRevInfoFormat OBJECT IDENTIFIER,
 *   otherRevInfo ANY DEFINED BY otherRevInfoFormat }
 * </pre>
 *
 * @example
 * new KJUR.asn1.cms.RevocationInfoChoice({
 *   crl: CRLPEMorHex
 * })
 * new KJUR.asn1.cms.RevocationInfoChoice({
 *   ocsp: OCSPResponseHex
 * })
 */
KJUR.asn1.cms.RevocationInfoChoice = function(params) {
    KJUR.asn1.cms.RevocationInfoChoice.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	if (params.crl != undefined && typeof params.crl == "string") {
	    var hCRL = params.crl;
	    if (params.crl.indexOf("-----BEGIN") != -1) {
		hCRL = pemtohex(params.crl);
	    }
	    return hCRL;
	} else if (params.ocsp != undefined) {
	    var dTag1 = KJUR.asn1.ASN1Util.newObject({tag: {
		tagi: "a1",
		obj: new KJUR.asn1.cms.OtherRevocationFormat(params)
	    }});
	    return dTag1.tohex();
	} else {
	    throw new Error("property crl or ocsp undefined");
	}
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.RevocationInfoChoice, KJUR.asn1.ASN1Object);

/**
 * class for OtherRevocationFormat ASN.1 structure for CMS SignedData<br/>
 * @name KJUR.asn1.cms.OtherRevocationFormat
 * @class class for OtherRevocationFormat ASN.1 structure for CMS SignedData
 * @param {Array} params array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 10.0.0 asn1cms 2.0.0
 * @see KJUR.asn1.cms.SignedData
 * @see KJUR.asn1.cms.RevocationInfoChoices
 * @see KJUR.asn1.cms.RevocationInfoChoice
 *
 * @description
 * This is an ASN.1 encoder for OtherRevocationFormat
 * ASN.1 structure defined in
 * <a href="https://tools.ietf.org/html/rfc5940">
 * RFC 5652</a>.
 * <pre>
 * OtherRevocationInfoFormat ::= SEQUENCE {
 *   otherRevInfoFormat  OBJECT IDENTIFIER,
 *   otherRevInfo        ANY DEFINED BY otherRevInfoFormat }
 * id-ri OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
 *   dod(6) internet(1) security(5) mechanisms(5) pkix(7) ri(16) }
 * id-ri-ocsp-response OBJECT IDENTIFIER ::= { id-ri 2 }
 * --  id-ri-ocsp-response 1.3.6.1.5.5.7.16.2
 * </pre>
 * NOTE: Currently this class only supports "ocsp"
 *
 * @example
 * new KJUR.asn1.cms.OtherRevocationFormat({
 *   ocsp: OCSPResponseHex
 * })
 */
KJUR.asn1.cms.OtherRevocationFormat = function(params) {
    KJUR.asn1.cms.OtherRevocationFormat.superclass.constructor.call(this);

    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_newObject = _KJUR_asn1.ASN1Util.newObject,
	_isHex = _KJUR.lang.String.isHex;

    this.params = null;

    this.tohex = function() {
	var params = this.params;
	if (params.ocsp == undefined)
	    throw new _Error("property ocsp not specified");
	if (! _isHex(params.ocsp) ||
	    ! ASN1HEX.isASN1HEX(params.ocsp))
	    throw new _Error("ocsp value not ASN.1 hex string");
	
	var dOtherRev = _newObject({
	    seq: [
		{oid: "1.3.6.1.5.5.7.16.2"},
		{asn1: {tlv: params.ocsp}}
	    ]
	});
	return dOtherRev.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cms.OtherRevocationFormat, KJUR.asn1.ASN1Object);

/**
 * CMS utiliteis class
 * @name KJUR.asn1.cms.CMSUtil
 * @class CMS utilities class
 */
KJUR.asn1.cms.CMSUtil = new function() {
};

/**
 * generate SignedData object specified by JSON parameters (DEPRECATED)<br/>
 * @name newSignedData
 * @memberOf KJUR.asn1.cms.CMSUtil
 * @function
 * @param {Array} params JSON parameter to generate CMS SignedData
 * @return {KJUR.asn1.cms.SignedData} object just generated
 * @deprecated since jsrsasign 10.0.0 asn1cms 2.0.0. 
 *
 * @description
 * This class generates {@link KJUR.asn1.cms.SignedData} object.
 * However this class is deprecated.
 * Please use {@link KJUR.asn1.cms.SignedData} class constructor
 * instead. As for "params" parameter, 
 * {@link KJUR.asn1.cms.SignedData} parameters are available.
 */
KJUR.asn1.cms.CMSUtil.newSignedData = function(param) {
    return new KJUR.asn1.cms.SignedData(param);
};

/**
 * verify SignedData specified by JSON parameters
 * @name verifySignedData
 * @memberOf KJUR.asn1.cms.CMSUtil
 * @function
 * @param {Array} param JSON parameter to verify CMS SignedData
 * @return {Object} JSON data as the result of validation
 * @since jsrsasign 8.0.4 asn1cms 1.0.5
 * @description
 * This method provides validation for CMS SignedData.
 * Following parameters can be applied:
 * <ul>
 * <li>cms - hexadecimal data of DER CMS SignedData (aka. PKCS#7 or p7s)</li>
 *     to verify (OPTION)</li>
 * </ul>
 * @example
 * KJUR.asn1.cms.CMSUtil.verifySignedData({ cms: "3082058a..." }) 
 * &rarr;
 * {
 *   isValid: true,
 *   parse: ... // parsed data
 *   signerInfos: [
 *     {
 *     }
 *   ]
 * }
 */
KJUR.asn1.cms.CMSUtil.verifySignedData = function(param) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_SignerInfo = _KJUR_asn1_cms.SignerInfo,
	_SignedData = _KJUR_asn1_cms.SignedData,
	_SigningTime = _KJUR_asn1_cms.SigningTime,
	_SigningCertificate = _KJUR_asn1_cms.SigningCertificate,
	_SigningCertificateV2 = _KJUR_asn1_cms.SigningCertificateV2,
	_KJUR_asn1_cades = _KJUR_asn1.cades,
	_SignaturePolicyIdentifier = _KJUR_asn1_cades.SignaturePolicyIdentifier,
	_isHex = _KJUR.lang.String.isHex,
	_ASN1HEX = ASN1HEX,
	_getVbyList = _ASN1HEX.getVbyList,
	_getTLVbyList = _ASN1HEX.getTLVbyList,
	_getIdxbyList = _ASN1HEX.getIdxbyList,
	_getChildIdx = _ASN1HEX.getChildIdx,
	_getTLV = _ASN1HEX.getTLV,
	_oidname = _ASN1HEX.oidname,
	_hashHex = _KJUR.crypto.Util.hashHex;

    if (param.cms === undefined &&
        ! _isHex(param.cms)) {
    }

    var hCMS = param.cms;

    var _findSignerInfos = function(hCMS, result) {
	var idx;
	for (var i = 3; i < 6; i++) {
	    idx = _getIdxbyList(hCMS, 0, [1, 0, i]);
	    if (idx !== undefined) {
		var tag = hCMS.substr(idx, 2);
		if (tag === "a0") result.certsIdx = idx;
		if (tag === "a1") result.revinfosIdx = idx;
		if (tag === "31") result.signerinfosIdx = idx;
	    }
	}
    };

    var _parseSignerInfos = function(hCMS, result) {
	var idxSignerInfos = result.signerinfosIdx;
	if (idxSignerInfos === undefined) return;
	var idxList = _getChildIdx(hCMS, idxSignerInfos);
	result.signerInfoIdxList = idxList;
	for (var i = 0; i < idxList.length; i++) {
	    var idxSI = idxList[i];
	    var info = { idx: idxSI };
	    _parseSignerInfo(hCMS, info);
	    result.signerInfos.push(info);
	};
    };

    var _parseSignerInfo = function(hCMS, info) {
	var idx = info.idx;

	// 1. signer identifier
	info.signerid_issuer1 = _getTLVbyList(hCMS, idx, [1, 0], "30");
	info.signerid_serial1 = _getVbyList(hCMS, idx, [1, 1], "02");

	// 2. hash alg
	info.hashalg = _oidname(_getVbyList(hCMS, idx, [2, 0], "06"));

	// 3. [0] singedAtttrs
	var idxSignedAttrs = _getIdxbyList(hCMS, idx, [3], "a0");
	info.idxSignedAttrs = idxSignedAttrs;
	_parseSignedAttrs(hCMS, info, idxSignedAttrs);

	var aIdx = _getChildIdx(hCMS, idx);
	var n = aIdx.length;
	if (n < 6) throw "malformed SignerInfo";
	
	info.sigalg = _oidname(_getVbyList(hCMS, idx, [n - 2, 0], "06"));
	info.sigval = _getVbyList(hCMS, idx, [n - 1], "04");
	//info.sigval = _getVbyList(hCMS, 0, [1, 0, 4, 0, 5], "04");
	//info.sigval = hCMS;
    };

    var _parseSignedAttrs = function(hCMS, info, idx) {
	var aIdx = _getChildIdx(hCMS, idx);
	info.signedAttrIdxList = aIdx;
	for (var i = 0; i < aIdx.length; i++) {
	    var idxAttr = aIdx[i];
	    var hAttrType = _getVbyList(hCMS, idxAttr, [0], "06");
	    var v;

	    if (hAttrType === "2a864886f70d010905") { // siging time
		v = hextoutf8(_getVbyList(hCMS, idxAttr, [1, 0]));
		info.saSigningTime = v;
	    } else if (hAttrType === "2a864886f70d010904") { // message digest
		v = _getVbyList(hCMS, idxAttr, [1, 0], "04");
		info.saMessageDigest = v;
	    }
	}
    };

    var _parseSignedData = function(hCMS, result) {
	// check if signedData (1.2.840.113549.1.7.2) type
	if (_getVbyList(hCMS, 0, [0], "06") !== "2a864886f70d010702") {
	    return result;
	}
	result.cmsType = "signedData";

	// find eContent data
	result.econtent = _getVbyList(hCMS, 0, [1, 0, 2, 1, 0]);

	// find certificates,revInfos,signerInfos index
	_findSignerInfos(hCMS, result);

	result.signerInfos = [];
	_parseSignerInfos(hCMS, result);
    };

    var _verify = function(hCMS, result) {
	var aSI = result.parse.signerInfos;
	var n = aSI.length;
	var isValid = true;
	for (var i = 0; i < n; i++) {
	    var si = aSI[i];
	    _verifySignerInfo(hCMS, result, si, i);
	    if (! si.isValid)
		isValid = false;
	}
	result.isValid = isValid;
    };

    /*
     * _findCert
     * 
     * @param hCMS {String} hexadecimal string of CMS signed data
     * @param result {Object} JSON object of validation result
     * @param si {Object} JSON object of signerInfo in the result above
     * @param idx {Number} index of signerInfo???
     */
    var _findCert = function(hCMS, result, si, idx) {
	var certsIdx = result.parse.certsIdx;
	var aCert;

	if (result.certs === undefined) {
	    aCert = [];
	    result.certkeys = [];
	    var aIdx = _getChildIdx(hCMS, certsIdx);
	    for (var i = 0; i < aIdx.length; i++) {
		var hCert = _getTLV(hCMS, aIdx[i]);
		var x = new X509();
		x.readCertHex(hCert);
		aCert[i] = x;
		result.certkeys[i] = x.getPublicKey();
	    }
	    result.certs = aCert;
	} else {
	    aCert = result.certs;
	}

	result.cccc = aCert.length;
	result.cccci = aIdx.length;

	for (var i = 0; i < aCert.length; i++) {
	    var issuer2 = x.getIssuerHex();
	    var serial2 = x.getSerialNumberHex();
	    if (si.signerid_issuer1 === issuer2 &&
		si.signerid_serial1 === serial2) {
		si.certkey_idx = i;
	    }
	}
    };

    var _verifySignerInfo = function(hCMS, result, si, idx) {
	si.verifyDetail = {};

	var _detail = si.verifyDetail;

	var econtent = result.parse.econtent;

	// verify MessageDigest signed attribute
	var hashalg = si.hashalg;
	var saMessageDigest = si.saMessageDigest;
	
	// verify messageDigest
	_detail.validMessageDigest = false;
	//_detail._econtent = econtent;
	//_detail._hashalg = hashalg;
	//_detail._saMD = saMessageDigest;
	if (_hashHex(econtent, hashalg) === saMessageDigest)
	    _detail.validMessageDigest = true;

	// find signing certificate
	_findCert(hCMS, result, si, idx);
	//if (si.signerid_cert === undefined)
	//    throw Error("can't find signer certificate");

	// verify signature value
	_detail.validSignatureValue = false;
	var sigalg = si.sigalg;
	var hSignedAttr = "31" + _getTLV(hCMS, si.idxSignedAttrs).substr(2);
	si.signedattrshex = hSignedAttr;
	var pubkey = result.certs[si.certkey_idx].getPublicKey();
	var sig = new KJUR.crypto.Signature({alg: sigalg});
	sig.init(pubkey);
	sig.updateHex(hSignedAttr);
	var isValid = sig.verify(si.sigval);
	_detail.validSignatureValue_isValid = isValid;
	if (isValid === true)
	    _detail.validSignatureValue = true;

	// verify SignerInfo totally
	si.isValid =false;
	if (_detail.validMessageDigest &&
	    _detail.validSignatureValue) {
	    si.isValid = true;
	}
    };

    var _findSignerCert = function() {
    };

    var result = { isValid: false, parse: {} };
    _parseSignedData(hCMS, result.parse);

    _verify(hCMS, result);
    
    return result;
};

/**
 * class for parsing CMS SignedData<br/>
 * @name KJUR.asn1.cms.CMSParser
 * @class CMS SignedData parser class
 * @since jsrsasign 10.1.0 asn1cms 2.0.1
 *
 * @description
 * This is an ASN.1 parser for CMS SignedData defined in
 * <a href="https://tools.ietf.org/html/rfc5652">RFC 5652
 * Cryptographic Message Syntax (CMS)</a>.
 * <pre>
 * ContentInfo ::= SEQUENCE {
 *    contentType ContentType,
 *    content [0] EXPLICIT ANY DEFINED BY contentType }
 * ContentType ::= OBJECT IDENTIFIER
 * SignedData ::= SEQUENCE {
 *    version CMSVersion,
 *    digestAlgorithms DigestAlgorithmIdentifiers,
 *    encapContentInfo EncapsulatedContentInfo,
 *    certificates [0] IMPLICIT CertificateSet OPTIONAL,
 *    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
 *    signerInfos SignerInfos }
 * SignerInfos ::= SET OF SignerInfo
 * CertificateSet ::= SET OF CertificateChoices
 * DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier
 * CertificateSet ::= SET OF CertificateChoices
 * RevocationInfoChoices ::= SET OF RevocationInfoChoice
 * </pre>
 */
KJUR.asn1.cms.CMSParser = function() {
    var _Error = Error,
	_X509 = X509,
	_x509obj = new _X509(),
	_ASN1HEX = ASN1HEX,
	_getV = _ASN1HEX.getV,
	_getTLV = _ASN1HEX.getTLV,
	_getIdxbyList = _ASN1HEX.getIdxbyList,
	_getTLVbyList = _ASN1HEX.getTLVbyList,
	_getTLVbyListEx = _ASN1HEX.getTLVbyListEx,
	_getVbyList = _ASN1HEX.getVbyList,
	_getVbyListEx = _ASN1HEX.getVbyListEx,
	_getChildIdx = _ASN1HEX.getChildIdx;

    /**
     * parse ASN.1 ContentInfo with SignedData<br/>
     * @name getCMSSignedData
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 ContentInfo with SignedData
     * @return {Array} array of JSON object of SignedData parameter
     * @see KJUR.asn1.cms.SignedData
     * @see KJUR.asn1.cms.CMSParser#getSignedData
     *
     * @description
     * This method parses ASN.1 ContentInfo with SignedData defined in 
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-3">section 3</a>
     * and 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5">section 5</a>.
     * The result parameter can be passed to
     * {@link KJUR.asn1.cms.SignedData} constructor.
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getCMSSignedData("30...") &rarr;
     * {
     *   version: 1,
     *   hashalgs: ["sha1"],
     *   econtent: {
     *     type: "data",
     *     content: {hex:"616161"}
     *   },
     *   certs: [PEM1,...],
     *   sinfos: [{
     *     version: 1,
     *     id: {type:'isssn',issuer:{str:'/C=US/O=T1'},serial:{int: 1}},
     *     hashalg: "sha1",
     *     sattrs: {array: [{
     *       attr: "contentType",
     *       type: '1.2.840.113549.1.7.1'
     *     },{
     *       attr: "messageDigest",
     *       hex: 'abcd'
     *     }]},
     *     sigalg: "SHA1withRSA",
     *     sighex: "1234abcd..."
     *   }]
     * }
     */
    this.getCMSSignedData = function(h) {
	var hSignedData = _getTLVbyList(h, 0, [1, 0]);
	var pResult = this.getSignedData(hSignedData);
	return pResult;
    };

    /**
     * parse ASN.1 SignedData<br/>
     * @name getSignedData
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 SignedData
     * @return {Array} array of JSON object of SignedData parameter
     * @see KJUR.asn1.cms.SignedData
     * @see KJUR.asn1.cms.CMSParser#getSignedData
     *
     * @description
     * This method parses ASN.1 SignedData defined in 
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5">section 5</a>.
     * The result parameter can be passed to
     * {@link KJUR.asn1.cms.SignedData} constructor.
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getSignedData("30...")
     */
    this.getSignedData = function(h) {
	var aIdx = _getChildIdx(h, 0);
	var pResult = {};

	var hVersion = _getV(h, aIdx[0]);
	var iVersion = parseInt(hVersion, 16);
	pResult.version = iVersion;
	
	var hHashAlgs = _getTLV(h, aIdx[1]);
	pResult.hashalgs = this.getHashAlgArray(hHashAlgs);

	var hEContent = _getTLV(h, aIdx[2]);
	pResult.econtent = this.getEContent(hEContent);

	var hCerts = _getTLVbyListEx(h, 0, ["[0]"]);
	if (hCerts != null) {
	    pResult.certs = this.getCertificateSet(hCerts);
	}

	// RevocationInfoChoices not supported yet
	var hRevInfos = _getTLVbyListEx(h, 0, ["[1]"]);
	if (hRevInfos != null) {
	}

	var hSignerInfos = _getTLVbyListEx(h, 0, [3]);
	pResult.sinfos = this.getSignerInfos(hSignerInfos);

	return pResult;
    };

    /**
     * parse ASN.1 DigestAlgorithmIdentifiers<br/>
     * @name getHashAlgArray
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 DigestAlgorithmIdentifiers
     * @return {Array} array of JSON object of digest algorithm names
     * @see KJUR.asn1.cms.SignedData
     * @see KJUR.asn1.cms.CMSParser#getSignedData
     *
     * @description
     * This method parses ASN.1 SignedData defined in 
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5.1">
     * section 5.1</a>.
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getHashAlgArray("30...") &rarr; ["sha256"]
     */
    this.getHashAlgArray = function(h) {
	var aIdx = _getChildIdx(h, 0);
	var x = new _X509();
	var a = [];
	for (var i = 0; i < aIdx.length; i++) {
	    var hAlg = _getTLV(h, aIdx[i]);
	    var sAlg = x.getAlgorithmIdentifierName(hAlg);
	    a.push(sAlg);
	}
	return a;
    };

    /**
     * parse ASN.1 EncapsulatedContentInfo<br/>
     * @name getEContent
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 EncapsulatedContentInfo
     * @return {Array} array of JSON object of EncapsulatedContentInfo parameter
     * @see KJUR.asn1.cms.EncapsulatedContentInfo
     * @see KJUR.asn1.cms.CMSParser#getSignedData
     *
     * @description
     * This method parses ASN.1 SignedData defined in 
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5.1">
     * section 5</a>.
     * The result parameter can be passed to
     * {@link KJUR.asn1.cms.EncapsulatedContentInfo} constructor.
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getEContent("30...") &rarr;
     * {type: "tstinfo", content: {hex: "30..."}}
     */
    this.getEContent = function(h) {
	var pResult = {};
	var hType = _getVbyList(h, 0, [0]);
	var hContent = _getVbyList(h, 0, [1, 0]);
	pResult.type = KJUR.asn1.x509.OID.oid2name(ASN1HEX.hextooidstr(hType));
	pResult.content = {hex: hContent};
	return pResult;
    };

    /**
     * parse ASN.1 SignerInfos<br/>
     * @name getSignerInfos
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 SignerInfos
     * @return {Array} array of JSON object of SignerInfos parameter
     * @see KJUR.asn1.cms.SignerInfos
     * @see KJUR.asn1.cms.CMSParser#getSignedData
     *
     * @description
     * This method parses ASN.1 SignerInfos defined in 
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5.1">
     * section 5</a>.
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getSignerInfos("30...") &rarr;
     * [{
     *   version: 1,
     *   id: {type: 'isssn', issuer: {str: '/C=US/O=T1'}, serial: {int: 1}},
     *   hashalg: "sha1",
     *   sattrs: {array: [{
     *     attr: "contentType",
     *     type: '1.2.840.113549.1.7.1'
     *   },{
     *     attr: "messageDigest",
     *     hex: 'a1a2a3a4a5a6a7a8a9a0a1a2a3a4a5a6a7a8a9a0'
     *   }]},
     *   sigalg: "SHA1withRSA",
     *   sighex: 'b1b2b...'
     * }]
     */
    this.getSignerInfos = function(h) {
	var aResult = [];

	var aIdx = _getChildIdx(h, 0);
	for (var i = 0; i < aIdx.length; i++) {
	    var hSignerInfo = _getTLV(h, aIdx[i]);
	    var pSignerInfo = this.getSignerInfo(hSignerInfo);
	    aResult.push(pSignerInfo);
	}

	return aResult;
    };

    /**
     * parse ASN.1 SignerInfo<br/>
     * @name getSignerInfo
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 SignerInfo
     * @return {Array} array of JSON object of SignerInfo parameter
     * @see KJUR.asn1.cms.SignerInfo
     * @see KJUR.asn1.cms.CMSParser#getSignedData
     *
     * @description
     * This method parses ASN.1 SignerInfos defined in 
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5.1">
     * section 5</a>.
     * <pre>
     * SignerInfo ::= SEQUENCE {
     *    version CMSVersion,
     *    sid SignerIdentifier,
     *    digestAlgorithm DigestAlgorithmIdentifier,
     *    signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,
     *    signatureAlgorithm SignatureAlgorithmIdentifier,
     *    signature SignatureValue,
     *    unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL }
     * </pre>
     * The result parameter can be passed to
     * {@link KJUR.asn1.cms.SignerInfo} constructor.
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getSignerInfos("30...") &rarr;
     * [{
     *   version: 1,
     *   id: {type: 'isssn', issuer: {str: '/C=US/O=T1'}, serial: {int: 1}},
     *   hashalg: "sha1",
     *   sattrs: {array: [{
     *     attr: "contentType",
     *     type: '1.2.840.113549.1.7.1'
     *   },{
     *     attr: "messageDigest",
     *     hex: 'a1a2a3a4a5a6a7a8a9a0a1a2a3a4a5a6a7a8a9a0'
     *   }]},
     *   sigalg: "SHA1withRSA",
     *   sighex: 'b1b2b...'
     * }]
     */
    this.getSignerInfo = function(h) {
	var pResult = {};
	var aIdx = _getChildIdx(h, 0);

	var iVersion = _ASN1HEX.getInt(h, aIdx[0], -1);
	if (iVersion != -1) pResult.version = iVersion;

	var hSI = _getTLV(h, aIdx[1]);
	var pSI = this.getIssuerAndSerialNumber(hSI);
	pResult.id = pSI;

	var hAlg = _getTLV(h, aIdx[2]);
	//alert(hAlg);
	var sAlg = _x509obj.getAlgorithmIdentifierName(hAlg);
	pResult.hashalg = sAlg;

	var hSattrs = _getTLVbyListEx(h, 0, ["[0]"]);
	if (hSattrs != null) {
	    var aSattrs = this.getAttributeList(hSattrs);
	    pResult.sattrs = aSattrs;
	}

	var hSigAlg = _getTLVbyListEx(h, 0, [3]);
	var sSigAlg = _x509obj.getAlgorithmIdentifierName(hSigAlg);
	pResult.sigalg = sSigAlg;

	var hSigHex = _getVbyListEx(h, 0, [4]);
	pResult.sighex = hSigHex;

	var hUattrs = _getTLVbyListEx(h, 0, ["[1]"]);
	if (hUattrs != null) {
	    var aUattrs = this.getAttributeList(hUattrs);
	    pResult.uattrs = aUattrs;
	}

	return pResult;
    };

    /**
     * parse ASN.1 SignerIdentifier<br/>
     * @name getSignerIdentifier
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 SignerIdentifier
     * @return {Array} array of JSON object of SignerIdentifier parameter
     * @see KJUR.asn1.cms.SignerInfo
     * @see KJUR.asn1.cms.SignerIdentifier
     * @see KJUR.asn1.cms.CMSParser#getSignedData
     *
     * @description
     * This method parses ASN.1 SignerIdentifier defined in 
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5.1">
     * section 5</a>.
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getSignerIdentifier("30...") &rarr;
     * { type: "isssn",
     *   issuer: {
     *     array: [[{type:"C",value:"JP",ds:"prn"},...]]
     *     str: '/C=US/O=T1'
     *   },
     *   serial: {int: 1} }
     */
    this.getSignerIdentifier = function(h) {
	if (h.substr(0, 2) == "30") {
	    return this.getIssuerAndSerialNumber(h);
	} else {
	    throw new Error("SKID of signerIdentifier not supported");
	}
    };

    /**
     * parse ASN.1 IssuerAndSerialNumber<br/>
     * @name getIssuerAndSerialNumber
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 IssuerAndSerialNumber
     * @return {Array} array of JSON object of IssuerAndSerialNumber parameter
     * @see KJUR.asn1.cms.SignerInfo
     * @see KJUR.asn1.cms.CMSParser#getSignedData
     *
     * @description
     * This method parses ASN.1 IssuerAndSerialNumber defined in 
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5.1">
     * section 5</a>.
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getIssuerAndSerialNumber("30...") &rarr;
     * { type: "isssn",
     *   issuer: {
     *     array: [[{type:"C",value:"JP",ds:"prn"},...]]
     *     str: '/C=US/O=T1'
     *   },
     *   serial: {int: 1} }
     */
    this.getIssuerAndSerialNumber = function(h) {
	var pResult = {type: "isssn"};

	var aIdx = _getChildIdx(h, 0);

	var hName = _getTLV(h, aIdx[0]);
	pResult.issuer = _x509obj.getX500Name(hName);

	var hSerial = _getV(h, aIdx[1]);
	pResult.serial = {hex: hSerial};

	return pResult;
    };

    /**
     * parse ASN.1 SET OF Attributes<br/>
     * @name getAttributeList
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 SET OF Attribute
     * @return {Array} array of JSON object of Attribute parameter
     * @see KJUR.asn1.cms.SignerInfo
     * @see KJUR.asn1.cms.CMSParser#getAttribute
     *
     * @description
     * This method parses ASN.1 SET OF Attribute defined in 
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5.1">
     * section 5</a>.
     * This can be used for SignedAttributes and UnsignedAttributes.
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getAttributeList("30...") &rarr;
     * [{attr: "contentType", type: "tstinfo"},
     *  {attr: "messageDigest", hex: "1234abcd..."}]
     */
    this.getAttributeList = function(h) {
	var a = [];

	var aIdx = _getChildIdx(h, 0);
	for (var i = 0; i < aIdx.length; i++) {
	    var hAttr = _getTLV(h, aIdx[i]);
	    var pAttr = this.getAttribute(hAttr);
	    a.push(pAttr);
	}

	return {array: a};
    };

    /**
     * parse ASN.1 Attributes<br/>
     * @name getAttribute
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 Attribute
     * @return {Array} array of JSON object of Attribute parameter
     * @see KJUR.asn1.cms.SignerInfo
     * @see KJUR.asn1.cms.CMSParser#getAttributeList
     *
     * @description
     * This method parses ASN.1 Attribute defined in 
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5.1">
     * section 5</a>.
     * Following attribute type are supported in the
     * latest version:
     * <ul>
     * <li>contentType - {@link KJUR.asn1.cms.CMSParser.setContentType}</li>
     * <li>messageDigest - {@link KJUR.asn1.cms.CMSParser.setMessageDigest}</li>
     * <li>signingTime - {@link KJUR.asn1.cms.CMSParser.setSigningTime}</li>
     * <li>signingCertificate - {@link KJUR.asn1.cms.CMSParser.setSigningCertificate}</li>
     * <li>signingCertificateV2 - {@link KJUR.asn1.cms.CMSParser.setSigningCertificateV2}</li>
     * </ul>
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getAttribute("30...") &rarr;
     * {attr: "contentType", type: "tstinfo"}
     */
    this.getAttribute = function(h) {
	var pResult = {};
	var aIdx = _getChildIdx(h, 0);

	var attrTypeOID = _ASN1HEX.getOID(h, aIdx[0]);
	var attrType = KJUR.asn1.x509.OID.oid2name(attrTypeOID);
	pResult.attr = attrType;

	var hSet = _getTLV(h, aIdx[1]);
	var aSetIdx = _getChildIdx(hSet, 0);
	if (aSetIdx.length == 1) {
	    pResult.valhex = _getTLV(hSet, aSetIdx[0]);
	} else {
	    var a = [];
	    for (var i = 0; i < aSetIdx.length; i++) {
		a.push(_getTLV(hSet, aSetIdx[i]));
	    }
	    pResult.valhex = a;
	}

	if (attrType == "contentType") {
	    this.setContentType(pResult);
	} else if (attrType == "messageDigest") {
	    this.setMessageDigest(pResult);
	} else if (attrType == "signingTime") {
	    this.setSigningTime(pResult);
	} else if (attrType == "signingCertificate") {
	    this.setSigningCertificate(pResult);
	} else if (attrType == "signingCertificateV2") {
	    this.setSigningCertificateV2(pResult);
	} else if (attrType == "signaturePolicyIdentifier") {
	    this.setSignaturePolicyIdentifier(pResult);
	}

	return pResult;
    };

    /**
     * set ContentType attribute<br/>
     * @name setContentType
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {Array} pAttr JSON object of attribute parameter
     * @see KJUR.asn1.cms.CMSParser#getAttribute
     *
     * @description
     * This sets an attribute as ContentType defined in
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5.1">
     * section 5</a>.
     *
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * pAttr = {
     *   attr: "contentType"
     *   valhex: '060b2a864886f70d0109100104'
     * };
     * parser.setContentInfo(pAttr);
     * pAttr &rarr; {
     *   attr: "contentType"
     *   type: "tstinfo"
     * }
     */
    this.setContentType = function(pAttr) {
	var contentType = _ASN1HEX.getOIDName(pAttr.valhex, 0, null);
	if (contentType != null) {
	    pAttr.type = contentType;
	    delete pAttr.valhex;
	}
    };

    /**
     * set SigningTime attribute<br/>
     * @name setSigningTime
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {Array} pAttr JSON object of attribute parameter
     * @see KJUR.asn1.cms.CMSParser#getAttribute
     *
     * @description
     * This sets an attribute as SigningTime defined in
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5.1">
     * section 5</a>.
     *
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * pAttr = {
     *   attr: "signingTime"
     *   valhex: '170d3230313233313233353935395a'
     * };
     * parser.setSigningTime(pAttr);
     * pAttr &rarr; {
     *   attr: "signingTime",
     *   str: "2012315959Z"
     * }
     */
    this.setSigningTime = function(pAttr) {
	var hSigningTime = _getV(pAttr.valhex, 0);
	var signingTime = hextoutf8(hSigningTime);
	pAttr.str = signingTime;
	delete pAttr.valhex;
    };

    /**
     * set MessageDigest attribute<br/>
     * @name setMessageDigest
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {Array} pAttr JSON object of attribute parameter
     * @see KJUR.asn1.cms.CMSParser#getAttribute
     *
     * @description
     * This sets an attribute as SigningTime defined in
     * RFC 5652 
     * <a href="https://tools.ietf.org/html/rfc5652#section-5.1">
     * section 5</a>.
     *
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * pAttr = {
     *   attr: "messageDigest"
     *   valhex: '0403123456'
     * };
     * parser.setMessageDigest(pAttr);
     * pAttr &rarr; {
     *   attr: "messageDigest",
     *   hex: "123456"
     * }
     */
    this.setMessageDigest = function(pAttr) {
	var hMD = _getV(pAttr.valhex, 0);
	pAttr.hex = hMD;
	delete pAttr.valhex;
    };

    /**
     * set SigningCertificate attribute<br/>
     * @name setSigningCertificate
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {Array} pAttr JSON object of attribute parameter
     * @see KJUR.asn1.cms.CMSParser#getAttribute
     *
     * @description
     * This sets an attribute as SigningCertificate defined in
     * <a href="https://tools.ietf.org/html/rfc5035#section-5">
     * RFC 5035 section 5</a>.
     *
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * pAttr = {
     *   attr: "signingCertificate"
     *   valhex: '...'
     * };
     * parser.setSigningCertificate(pAttr);
     * pAttr &rarr; {
     *   attr: "signingCertificate",
     *   array: [{
     *     hash: "123456...",
     *     issuer: {
     *       array: [[{type:"C",value:"JP",ds:"prn"},...]],
     *       str: "/C=JP/O=T1"
     *     },
     *     serial: {hex: "123456..."}
     *   }]
     * }
     */
    this.setSigningCertificate = function(pAttr) {
	var aIdx = _getChildIdx(pAttr.valhex, 0);
	if (aIdx.length > 0) {
	    var hCerts = _getTLV(pAttr.valhex, aIdx[0]);
	    var aCertIdx = _getChildIdx(hCerts, 0);
	    var a = [];
	    for (var i = 0; i < aCertIdx.length; i++) {
		var hESSCertID = _getTLV(hCerts, aCertIdx[i]);
		var pESSCertID = this.getESSCertID(hESSCertID);
		a.push(pESSCertID);
	    }
	    pAttr.array = a;
	}

	if (aIdx.length > 1) {
	    var hPolicies = _getTLV(pAttr.valhex, aIdx[1]);
	    pAttr.polhex = hPolicies;
	}
	delete pAttr.valhex;
    };

    /**
     * set SignaturePolicyIdentifier attribute<br/>
     * @name setSignaturePolicyIdentifier
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {Array} pAttr JSON object of attribute parameter
     * @since jsrsasign 10.1.5 asn1cms 2.0.4
     * @see KJUR.asn1.cms.CMSParser#getAttribute
     * @see KJUR.asn1.cades.SignaturePolicyIdentifier
     *
     * @description
     * This sets an attribute as SignaturePolicyIdentifier defined in
     * <a href="https://tools.ietf.org/html/rfc5126#section-5.8.1">
     * RFC 5126 CAdES section 5.8.1</a>.
     *
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * pAttr = {
     *   attr: "signaturePolicyIdentifier"
     *   valhex: '...'
     * };
     * parser.setSignaturePolicyIdentifier(pAttr);
     * pAttr &rarr; {
     *   attr: "signaturePolicyIdentifier",
     *   oid: "1.2.3.4.5",
     *   alg: "sha1",
     *   hash: "1a2b..."
     * }
     */
    this.setSignaturePolicyIdentifier = function(pAttr) {
	var aIdx = _getChildIdx(pAttr.valhex, 0);
	if (aIdx.length > 0) {
	    var oid = _ASN1HEX.getOID(pAttr.valhex, aIdx[0]);
	    pAttr.oid = oid;
	}
	if (aIdx.length > 1) {
	    var x = new _X509();
	    var a2Idx = _getChildIdx(pAttr.valhex, aIdx[1]);
	    var hAlg = _getTLV(pAttr.valhex, a2Idx[0]);
	    var sAlg = x.getAlgorithmIdentifierName(hAlg);
	    pAttr.alg = sAlg;

	    var hHash = _getV(pAttr.valhex, a2Idx[1]);
	    pAttr.hash = hHash;
	}
	delete pAttr.valhex;
    };

    /**
     * set SigningCertificateV2 attribute<br/>
     * @name setSigningCertificateV2
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {Array} pAttr JSON object of attribute parameter
     * @since jsrsasign 10.1.2 asn1cms 2.0.3
     * @see KJUR.asn1.cms.CMSParser#getAttribute
     * @see KJUR.asn1.cms.CMSParser#getESSCertIDv2
     * @see KJUR.asn1.cms.SigningCertificateV2
     * @see KJUR.asn1.cms.ESSCertIDv2
     *
     * @description
     * This sets an attribute as SigningCertificateV2 defined in
     * <a href="https://tools.ietf.org/html/rfc5035#section-3">
     * RFC 5035 section 3</a>.
     *
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * pAttr = {
     *   attr: "signingCertificateV2"
     *   valhex: '...'
     * };
     * parser.setSigningCertificateV2(pAttr);
     * pAttr &rarr; {
     *   attr: "signingCertificateV2",
     *   array: [{
     *     hash: "123456...",
     *     alg: "sha256",
     *     issuer: {
     *       array: [[{type:"C",value:"JP",ds:"prn"},...]],
     *       str: "/C=JP/O=T1"
     *     },
     *     serial: {hex: "123456..."}
     *   }]
     * }
     */
    this.setSigningCertificateV2 = function(pAttr) {
	var aIdx = _getChildIdx(pAttr.valhex, 0);
	if (aIdx.length > 0) {
	    var hCerts = _getTLV(pAttr.valhex, aIdx[0]);
	    var aCertIdx = _getChildIdx(hCerts, 0);
	    var a = [];
	    for (var i = 0; i < aCertIdx.length; i++) {
		var hESSCertIDv2 = _getTLV(hCerts, aCertIdx[i]);
		var pESSCertIDv2 = this.getESSCertIDv2(hESSCertIDv2);
		a.push(pESSCertIDv2);
	    }
	    pAttr.array = a;
	}

	if (aIdx.length > 1) {
	    var hPolicies = _getTLV(pAttr.valhex, aIdx[1]);
	    pAttr.polhex = hPolicies;
	}
	delete pAttr.valhex;
    };

    /**
     * parse ASN.1 ESSCertID<br/>
     * @name getESSCertID
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 ESSCertID
     * @return {Array} array of JSON object of ESSCertID parameter
     * @see KJUR.asn1.cms.ESSCertID
     *
     * @description
     * This method parses ASN.1 ESSCertID defined in 
     * <a href="https://tools.ietf.org/html/rfc5035#section-6">
     * RFC 5035 section 6</a>.
     * <pre>
     * ESSCertID ::= SEQUENCE {
     *    certHash Hash,
     *    issuerSerial IssuerSerial OPTIONAL }
     * IssuerSerial ::= SEQUENCE {
     *    issuer GeneralNames,
     *    serialNumber CertificateSerialNumber }
     * </pre>
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getESSCertID("30...") &rarr;
     * { hash: "12ab...",
     *   issuer: {
     *     array: [[{type:"C",value:"JP",ds:"prn"}],...],
     *     str: "/C=JP/O=T1"
     *   },
     *   serial: {hex: "12ab..."} }
     */
    this.getESSCertID = function(h) {
	var pResult = {};
	var aIdx = _getChildIdx(h, 0);

	if (aIdx.length > 0) {
	    var hCertHash = _getV(h, aIdx[0]);
	    pResult.hash = hCertHash;
	}

	if (aIdx.length > 1) {
	    var hIssuerSerial = _getTLV(h, aIdx[1]);
	    var pIssuerSerial = 
		this.getIssuerSerial(hIssuerSerial);

	    if (pIssuerSerial.serial != undefined)
		pResult.serial = pIssuerSerial.serial;

	    if (pIssuerSerial.issuer != undefined)
		pResult.issuer = pIssuerSerial.issuer;
	}

	return pResult;
    };

    /**
     * parse ASN.1 ESSCertIDv2<br/>
     * @name getESSCertIDv2
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 ESSCertIDv2
     * @return {Array} array of JSON object of ESSCertIDv2 parameter
     * @since jsrsasign 10.1.2 asn1cms 2.0.3
     * @see KJUR.asn1.cms.ESSCertIDv2
     * @see KJUR.asn1.cms.CMSParser.getESSCertID
     *
     * @description
     * This method parses ASN.1 ESSCertIDv2 defined in 
     * <a href="https://tools.ietf.org/html/rfc5035#section-4">
     * RFC 5035 section 4</a>.
     * <pre>
     * ESSCertIDv2 ::=  SEQUENCE {
     *    hashAlgorithm           AlgorithmIdentifier
     *                            DEFAULT {algorithm id-sha256},
     *    certHash                Hash,
     *    issuerSerial            IssuerSerial OPTIONAL }
     * Hash ::= OCTET STRING
     * IssuerSerial ::= SEQUENCE {
     *    issuer                  GeneralNames,
     *    serialNumber            CertificateSerialNumber }
     * </pre>
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getESSCertID("30...") &rarr;
     * {
     *   hash: "3f2d...",
     *   alg: "sha512",
     *   issuer: {str: "/C=JP/O=T1"},
     *   serial: {hex: "12ab..."}
     * }
     */
    this.getESSCertIDv2 = function(h) {
	var aResult = {};
	var aIdx = _getChildIdx(h, 0); 

	if (aIdx.length < 1 || 3 < aIdx.length)
	    throw new _Error("wrong number of elements");

	var offset = 0;
	if (h.substr(aIdx[0], 2) == "30") {
	    var hHashAlg = _getTLV(h, aIdx[0]);
	    aResult.alg = 
		_x509obj.getAlgorithmIdentifierName(hHashAlg);
	    offset++;
	} else {
	    aResult.alg = "sha256";
	}

	var hHash = _getV(h, aIdx[offset]);
	aResult.hash = hHash;

	if (aIdx.length > offset + 1) {
	    var hIssuerSerial = _getTLV(h, aIdx[offset + 1]);
	    var pIssuerSerial = 
		this.getIssuerSerial(hIssuerSerial);
	    aResult.issuer = pIssuerSerial.issuer;
	    aResult.serial = pIssuerSerial.serial;
	}

	return aResult;
    };

    /**
     * parse ASN.1 IssuerSerial<br/>
     * @name getIssuerSerial
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 IssuerSerial
     * @return {Array} array of JSON object of IssuerSerial parameter
     * @see KJUR.asn1.cms.IssuerSerial
     * @see KJUR.asn1.x509.X500Name
     *
     * @description
     * This method parses ASN.1 IssuerSerial defined in 
     * <a href="https://tools.ietf.org/html/rfc5035#section-6">
     * RFC 5035 section 6</a>.
     * <pre>
     * IssuerSerial ::= SEQUENCE {
     *    issuer GeneralNames,
     *    serialNumber CertificateSerialNumber }
     * </pre>
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getIssuerSerial("30...") &rarr;
     * { issuer: {
     *     array: [[{type:"C",value:"JP",ds:"prn"}],...],
     *     str: "/C=JP/O=T1",
     *   },
     *   serial: {hex: "12ab..."} }
     */
    this.getIssuerSerial = function(h) {
	var pResult = {};
	var aIdx = _getChildIdx(h, 0);

	var hIssuer = _getTLV(h, aIdx[0]);
	var pIssuerGN = _x509obj.getGeneralNames(hIssuer);
	var pIssuerName = pIssuerGN[0].dn;
	pResult.issuer = pIssuerName;

	var hSerial = _getV(h, aIdx[1]);
	pResult.serial = {hex: hSerial};

	return pResult;
    };

    /**
     * parse ASN.1 CertificateSet<br/>
     * @name getCertificateSet
     * @memberOf KJUR.asn1.cms.CMSParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 CertificateSet
     * @return {Array} array of JSON object of CertificateSet parameter
     * @see KJUR.asn1.cms.CertificateSet
     *
     * @description
     * This method parses ASN.1 IssuerSerial defined in 
     * <a href="https://tools.ietf.org/html/rfc5652#section-10.2.3">
     * RFC 5652 CMS section 10.2.3</a> and 
     * <a href="https://tools.ietf.org/html/rfc5652#section-10.2.2">
     * section 10.2.2</a>.
     * <pre>
     * CertificateSet ::= SET OF CertificateChoices
     * CertificateChoices ::= CHOICE {
     *   certificate Certificate,
     *   extendedCertificate [0] IMPLICIT ExtendedCertificate, -- Obsolete
     *   v1AttrCert [1] IMPLICIT AttributeCertificateV1,       -- Obsolete
     *   v2AttrCert [2] IMPLICIT AttributeCertificateV2,
     *   other [3] IMPLICIT OtherCertificateFormat }
     * OtherCertificateFormat ::= SEQUENCE {
     *   otherCertFormat OBJECT IDENTIFIER,
     *   otherCert ANY DEFINED BY otherCertFormat }
     * </pre>
     * Currently only "certificate" is supported in
     * CertificateChoices.
     * 
     * @example
     * parser = new KJUR.asn1.cms.CMSParser();
     * parser.getCertificateSet("a0...") &rarr;
     * [ "-----BEGIN CERTIFICATE...", ... ]
     */
    this.getCertificateSet = function(h) {
	var aIdx = _getChildIdx(h, 0);
	var  a = [];
	for (var i = 0; i < aIdx.length; i++) {
	    var hCert = _getTLV(h, aIdx[i]);
	    if (hCert.substr(0, 2) == "30") {
		var pem = hextopem(hCert, "CERTIFICATE");
		a.push(pem);
	    }
	}
	return {array: a, sortflag: false};
    };
};

/* asn1tsp-2.0.9.js (c) 2014-2022 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * asn1tsp.js - ASN.1 DER encoder classes for RFC 3161 Time Stamp Protocol
 *
 * Copyright (c) 2014-2022 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name asn1tsp-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.5.22 asn1tsp 2.0.9 (2022-May-24)
 * @since jsrsasign 4.5.1
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/* 
 * kjur's class library name space
 * // already documented in asn1-1.0.js
 * @name KJUR
 * @namespace kjur's class library name space
 */
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};

/*
 * kjur's ASN.1 class library name space
 * // already documented in asn1-1.0.js
 * @name KJUR.asn1
 * @namespace
 */
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};

/**
 * kjur's ASN.1 class for RFC 3161 Time Stamp Protocol
 * <p>
 * This name space provides 
 * <a href="https://tools.ietf.org/html/rfc3161">RFC 3161
 * Time-Stamp Protocol(TSP)</a> data generator.
 *
 * <h4>FEATURES</h4>
 * <ul>
 * <li>easily generate CMS SignedData</li>
 * <li>APIs are very similar to BouncyCastle library ASN.1 classes. So easy to learn.</li>
 * </ul>
 * 
 * <h4>PROVIDED CLASSES</h4>
 * <ul>
 * </ul>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * </p>
 * @name KJUR.asn1.tsp
 * @namespace
 */
if (typeof KJUR.asn1.tsp == "undefined" || !KJUR.asn1.tsp) KJUR.asn1.tsp = {};

/**
 * class for TSP TimeStampToken ASN.1 object<br/>
 * @name KJUR.asn1.tsp.TimeStampToken
 * @class class for TSP TimeStampToken ASN.1 object
 * @param {Array} params JSON object for constructor parameters
 * @extends KJUR.asn1.cms.SignedData
 * @since jsrsasign 10.0.0 asn1tsp 2.0.0
 * @see KJUR.asn1.tsp.TimeStampResp
 * @see KJUR.asn1.tsp.TSTInfo
 *
 * @description
 * This is an ASN.1 encoder for TimeStampToken
 * ASN.1 structure defined in
 * <a href="https://tools.ietf.org/html/rfc3161#section-2.4.2">
 * RFC 3161 TSP section 2.4.2</a>.
 * <pre>
 * TimeStampToken ::= ContentInfo
 *   -- contentType is id-signedData ([CMS])
 *   -- content is SignedData ([CMS])
 * id-ct-TSTInfo  OBJECT IDENTIFIER ::= { iso(1) member-body(2)
 * us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) ct(1) 4}
 * </pre>
 * Constructor argument "params" is similar to
 * {@link KJUR.asn1.cms.SignedData} however "econtent"
 * value is different as follows:
 * <ul>
 * <li>econtent.type - shall be "tstinfo"</li>
 * <li>econtent.content - shall be {@link KJUR.asn1.tsp.TSTInfo} parameter</li>
 * </ul>
 *
 * @example
 * new KJUR.asn1.tsp.TimeStampToken({
 *   version: 1,
 *   hashalgs: ["sha256"],
 *   econtent: {
 *     type: "tstinfo",
 *     content: {
 *       policy: '1.2.3.4.5',
 *       messageImprint: { hashAlg: 'sha1', hashValue: 'a1a2a3a4' },
 *       serial: {'int': 3},
 *       genTime: {str: '20131231235959.123Z', millis: true},
 *       accuracy: { millis: 500 },
 *       ordering: true,
 *       nonce: {'int': 3},
 *     }
 *   },
 *   sinfos: [{
 *     version: 1,
 *     id: {type:'isssn', cert: sZ4_CERPEM},
 *     hashalg: "sha256",
 *     sattrs: {array: [{
 *       attr: "contentType",
 *       type: "data"
 *     },{
 *       attr: "signingTime",
 *       str: '131231235959Z'
 *     },{
 *       attr: "messageDigest",
 *       hex: 'ffff'
 *     }]},
 *     sigalg: "SHA256withRSA",
 *     signkey: sZ4_PRVP8PPEM
 *   }]
 * })
 */
KJUR.asn1.tsp.TimeStampToken = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_tsp = _KJUR_asn1.tsp;

    _KJUR_asn1_tsp.TimeStampToken.superclass.constructor.call(this);

    this.params = null;

    this.getEncodedHexPrepare = function() {
	//alert("getEncodedHexPrepare called...");
	var dTSTInfo = new _KJUR_asn1_tsp.TSTInfo(this.params.econtent.content);
	this.params.econtent.content.hex = dTSTInfo.tohex();
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.tsp.TimeStampToken, KJUR.asn1.cms.SignedData);

/**
 * class for TSP TSTInfo ASN.1 object
 * @name KJUR.asn1.tsp.TSTInfo
 * @class class for TSP TSTInfo ASN.1 object
 * @param {Array} params JSON object for TSTInfo parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.6.0 asn1tsp 1.0.0
 * @see KJUR.asn1.x509.X500Name
 * @see KJUR.asn1.x509.GeneralName
 * @description
 * This class represents TSTInfo ASN.1 structure.
 * <pre>
 * TSTInfo ::= SEQUENCE  {
 *    version         INTEGER  { v1(1) },
 *    policy          TSAPolicyId,
 *    messageImprint  MessageImprint,
 *    serialNumber    INTEGER, -- up to 160bit
 *    genTime         GeneralizedTime,
 *    accuracy        Accuracy                 OPTIONAL,
 *    ordering        BOOLEAN                  DEFAULT FALSE,
 *    nonce           INTEGER                  OPTIONAL,
 *    tsa             [0] GeneralName          OPTIONAL,
 *    extensions      [1] IMPLICIT Extensions  OPTIONAL   }
 * </pre>
 * For "params" arguent, following properties are accepted:
 * <ul>
 * <li>{Array}tsa - {@link KJUR.asn1.x509.X500Name} parameter for
 * tsa field even though tsa field is GeneralName.</li>
 * </ul>
 * @example
 * o = new KJUR.asn1.tsp.TSTInfo({
 *     policy:    '1.2.3.4.5',
 *     messageImprint: {alg: 'sha256', hash: '1abc...'},
 *     serial:    {int: 3},
 *     genTime:   {millis: true},         // OPTION
 *     accuracy:  {micros: 500},          // OPTION
 *     ordering:  true,                   // OPITON
 *     nonce:     {hex: '52fab1...'},     // OPTION
 *     tsa:       {str: '/C=US/O=TSA1'}   // OPITON
 * });
 */
KJUR.asn1.tsp.TSTInfo = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERBoolean = _KJUR_asn1.DERBoolean,
	_DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_KJUR_asn1_tsp = _KJUR_asn1.tsp,
	_MessageImprint = _KJUR_asn1_tsp.MessageImprint,
	_Accuracy = _KJUR_asn1_tsp.Accuracy,
        _X500Name = _KJUR_asn1.x509.X500Name,
        _GeneralName = _KJUR_asn1.x509.GeneralName;
        _Extensions = _KJUR_asn1.x509.Extensions;
	

    _KJUR_asn1_tsp.TSTInfo.superclass.constructor.call(this);

    this.dVersion = new _DERInteger({'int': 1});
    this.dPolicy = null;
    this.dMessageImprint = null;
    this.dSerial = null;
    this.dGenTime = null;
    this.dAccuracy = null;
    this.dOrdering = null;
    this.dNonce = null;
    this.dTsa = null;
    this.dExtensions = null;

    this.tohex = function() {
        var a = [this.dVersion];

        if (this.dPolicy == null) throw new Error("policy shall be specified.");
        a.push(this.dPolicy);

        if (this.dMessageImprint == null)
            throw new Error("messageImprint shall be specified.");
        a.push(this.dMessageImprint);

        if (this.dSerial == null)
            throw new Error("serialNumber shall be specified.");
        a.push(this.dSerial);

        if (this.dGenTime == null)
            throw new Error("genTime shall be specified.");
        a.push(this.dGenTime);

        if (this.dAccuracy != null) a.push(this.dAccuracy);
        if (this.dOrdering != null) a.push(this.dOrdering);
        if (this.dNonce != null) a.push(this.dNonce);
        if (this.dTsa != null) a.push(this.dTsa);
        if (this.dExtensions != null) a.push(this.dExtensions);

        var seq = new _DERSequence({array: a});
        this.hTLV = seq.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
        if (typeof params.policy == "string") {
            if (! params.policy.match(/^[0-9.]+$/))
                throw "policy shall be oid like 0.1.4.134";
            this.dPolicy = new _DERObjectIdentifier({oid: params.policy});
        }
        if (params.messageImprint !== undefined) {
            this.dMessageImprint = new _MessageImprint(params.messageImprint);
        }
        if (params.serial !== undefined) {
            this.dSerial = new _DERInteger(params.serial);
        }
        if (params.genTime !== undefined) {
            this.dGenTime = new _DERGeneralizedTime(params.genTime);
        }
        if (params.accuracy !== undefined) {
            this.dAccuracy = new _Accuracy(params.accuracy);
        }
        if (params.ordering !== undefined &&
            params.ordering == true) {
            this.dOrdering = new _DERBoolean();
        }
        if (params.nonce !== undefined) {
            this.dNonce = new _DERInteger(params.nonce);
        }
        if (params.tsa !== undefined) {
            this.dTsa = new _DERTaggedObject({
		tag: "a0",
		explicit: true,
		obj: new _GeneralName({dn: params.tsa})
	    });
        }
        if (params.ext !== undefined) {
            this.dExtensions = new _DERTaggedObject({
                tag: 'a1',
                explicit: false,
                obj: new _Extensions(params.ext) 
            });
        }
    }
};
extendClass(KJUR.asn1.tsp.TSTInfo, KJUR.asn1.ASN1Object);

/**
 * class for TSP Accuracy ASN.1 object
 * @name KJUR.asn1.tsp.Accuracy
 * @class class for TSP Accuracy ASN.1 object
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.6.0 asn1tsp 1.0.0
 *
 * @description
 * This is an ASN.1 encoder for Accuracy
 * ASN.1 structure defined in
 * <a href="https://tools.ietf.org/html/rfc3161#section-2.4.2">
 * RFC 3161 TSP section 2.4.2</a>.
 * <pre>
 * Accuracy ::= SEQUENCE {
 *    seconds        INTEGER              OPTIONAL,
 *    millis     [0] INTEGER  (1..999)    OPTIONAL,
 *    micros     [1] INTEGER  (1..999)    OPTIONAL  }
 * </pre>
 *
 * @example
 * new KJUR.asn1.tsp.Accuracy({
 *   seconds: 1,   // OPTION
 *   millis: 500,  // OPTION
 *   micros: 500   // OPTION
 * });
 */
KJUR.asn1.tsp.Accuracy = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_newObject = _KJUR_asn1.ASN1Util.newObject;

    _KJUR_asn1.tsp.Accuracy.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;
	var a = [];
	if (params.seconds != undefined &&
	    typeof params.seconds == "number") {
	    a.push({"int": params.seconds});
	}
	if (params.millis != undefined &&
	    typeof params.millis == "number") {
	    a.push({tag: {tagi:"80", obj:{"int": params.millis}}});
	}
	if (params.micros != undefined &&
	    typeof params.micros == "number") {
	    a.push({tag: {tagi:"81", obj:{"int": params.micros}}});
	}
	return _newObject({"seq": a}).tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.tsp.Accuracy, KJUR.asn1.ASN1Object);

/**
 * class for TSP MessageImprint ASN.1 object
 * @name KJUR.asn1.tsp.MessageImprint
 * @class class for TSP MessageImprint ASN.1 object
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.6.0 asn1tsp 1.0.0
 *
 * @description
 * This is an ASN.1 encoder for Accuracy
 * ASN.1 structure defined in
 * <a href="https://tools.ietf.org/html/rfc3161#section-2.4.2">
 * RFC 3161 TSP section 2.4.2</a>.
 * <pre>
 * MessageImprint ::= SEQUENCE  {
 *      hashAlgorithm                AlgorithmIdentifier,
 *      hashedMessage                OCTET STRING  }
 * </pre>
 *
 * @example
 * // OLD
 * new KJUR.asn1.tsp.MessageImprint({
 *   hashAlg: 'sha256',
 *   hashValue: '1f3dea...'
 * });
 * // NEW
 * new KJUR.asn1.tsp.MessageImprint({
 *   alg: 'sha256',
 *   hash: '1f3dea...'
 * });
 */
KJUR.asn1.tsp.MessageImprint = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_AlgorithmIdentifier = _KJUR_asn1_x509.AlgorithmIdentifier;

    _KJUR_asn1.tsp.MessageImprint.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;
	var dAlg = new _AlgorithmIdentifier({name: params.alg});
	var dHash = new _DEROctetString({hex: params.hash});
	var seq = new _DERSequence({array: [dAlg, dHash]});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.tsp.MessageImprint, KJUR.asn1.ASN1Object);

/**
 * class for TSP TimeStampReq ASN.1 object<br/>
 * @name KJUR.asn1.tsp.TimeStampReq
 * @class class for TSP TimeStampReq ASN.1 object
 * @param {Array} params JSON object of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.6.0 asn1tsp 1.0.0
 * @see KJUR.asn1.tsp.MessageImprint
 *
 * @description
 * <pre>
 * TimeStampReq ::= SEQUENCE  {
 *    version          INTEGER  { v1(1) },
 *    messageImprint   MessageImprint,
 *    reqPolicy        TSAPolicyId               OPTIONAL,
 *    nonce            INTEGER                   OPTIONAL,
 *    certReq          BOOLEAN                   DEFAULT FALSE,
 *    extensions       [0] IMPLICIT Extensions   OPTIONAL  }
 * </pre>
 *
 * @example
 * new KJUR.asn1.tsp.TimeStampReq({
 *   messageImprint: {alg: "sha256", hash: "12ab..."},
 *   policy: "1.2.3.4.5",
 *   nonce: {hex: "1a2b..."},
 *   certreq: true
 * })
 */
KJUR.asn1.tsp.TimeStampReq = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERBoolean = _KJUR_asn1.DERBoolean,
	_ASN1Object = _KJUR_asn1.ASN1Object,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_KJUR_asn1_tsp = _KJUR_asn1.tsp,
	_MessageImprint = _KJUR_asn1_tsp.MessageImprint;

    _KJUR_asn1_tsp.TimeStampReq.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	var a = [];
	a.push(new _DERInteger({'int': 1}));
	if (params.messageImprint instanceof KJUR.asn1.ASN1Object) {
	    a.push(params.messageImprint);
	} else {
	    a.push(new _MessageImprint(params.messageImprint));
	}
	if (params.policy != undefined)
	    a.push(new _DERObjectIdentifier(params.policy));
	if (params.nonce != undefined)
	    a.push(new _DERInteger(params.nonce));
	if (params.certreq == true)
	    a.push(new _DERBoolean());

        var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.tsp.TimeStampReq, KJUR.asn1.ASN1Object);

/**
 * class for TSP TimeStampResp ASN.1 object<br/>
 * @name KJUR.asn1.tsp.TimeStampResp
 * @class class for TSP TimeStampResp ASN.1 object
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.6.0 asn1tsp 1.0.0
 * @see KJUR.asn1.tsp.TimeStampToken
 * @see KJUR.asn1.tsp.PKIStatusInfo
 *
 * @description
 * This is an ASN.1 encoder for TimeStampResp
 * ASN.1 structure defined in
 * <a href="https://tools.ietf.org/html/rfc3161#section-2.4.2">
 * RFC 3161 TSP section 2.4.2</a>.
 * 
 * <pre>
 * TimeStampResp ::= SEQUENCE  {
 *    status                  PKIStatusInfo,
 *    timeStampToken          TimeStampToken     OPTIONAL  }
 *
 * TimeStampToken ::= ContentInfo
 *
 * TSTInfo ::= SEQUENCE  {
 *    version           INTEGER  { v1(1) },
 *    policy            TSAPolicyId,
 *    messageImprint    MessageImprint,
 *    serialNumber      INTEGER,
 *    genTime           GeneralizedTime,
 *    accuracy          Accuracy                 OPTIONAL,
 *    ordering          BOOLEAN                  DEFAULT FALSE,
 *    nonce             INTEGER                  OPTIONAL,
 *    tsa               [0] GeneralName          OPTIONAL,
 *    extensions        [1] IMPLICIT Extensions  OPTIONAL  }
 * </pre>
 *
 * The constructor argument "params" can be used all of 
 * {@link KJUR.asn1.tsp.TimeStampToken} object further more
 * following members can be specified:
 * <ul>
 * <li>statusinfo: any {@link KJUR.asn1.tsp.PKIStatusInfo} parameter.
 * When parameters for TimeStampToken is specified and statusinfo member is omitted, 
 * status will be "granted" by default. (OPTIONAL)</li>
 * <li>tst: {@link KJUR.asn1.tsp.TimeStampToken} object instead of TimeStampToken members (OPTIONAL)</li>
 * </ul>
 *
 * @example
 * // by TimeStampToken parameters (statusinfo will be "granted" by default)
 * new KJUR.asn1.tsp.TimeStampResp({
 *   version: 1,
 *   hashalgs: ["sha256"],
 *   econtent: {
 *     type: "tstinfo",
 *     content: {
 *       policy: "1.2.3.4.5",
 *       messageImprint: {alg:"sha256", hash:"12ab..."},
 *       serial: {"int": 3},
 *       genTime: {millis: true}, // current time with millis
 *       accuracy: { millis: 500 }
 *     }
 *   }
 *   certs: [...],
 *   sinfos: [{
 *     version: 1,
 *     id: {type:"isssn", cert: ...},
 *     hashalg: "sha256",
 *     sattrs: {array: [{...}]},
 *     sigalg: "SHA256withRSA",
 *     signkey: ...
 *   }]
 * })
 * // by TimeStampToken object
 * new KJUR.asn1.tsp.TimeStampResp({
 *   tst: new KJUR.asn1.tsp.TimeStapToken(...)
 * })
 * // error case
 * new KJUR.asn1.tsp.TimeStampResp({statusinfo: "rejection"}})
 * new KJUR.asn1.tsp.TimeStampResp({
 *    statusinfo: {
 *      status: "rejection",
 *      statusstr: ["policy shall be 1.2.3.4.5"],
 *      failinfo: "unacceptedPolicy"
 *    }
 * })
 * // finally, encode to hexadecimal string
 * new KJUR.asn1.tsp.TimeStampResp(...).tohex() &rarr; "3082..."
 */
KJUR.asn1.tsp.TimeStampResp = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_ASN1Object = _KJUR_asn1.ASN1Object,
	_KJUR_asn1_tsp = _KJUR_asn1.tsp,
	_PKIStatusInfo = _KJUR_asn1_tsp.PKIStatusInfo;

    _KJUR_asn1_tsp.TimeStampResp.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	var a = [];

	if (params.econtent != undefined || params.tst != undefined) {
	    // statusInfo
	    if (params.statusinfo != undefined) {
		a.push(new _PKIStatusInfo(params.statusinfo));
	    } else {
		a.push(new _PKIStatusInfo("granted"));
	    }
	    
	    // TimeStampToken
	    if (params.econtent != undefined) {
		a.push((new _KJUR_asn1_tsp.TimeStampToken(params)).getContentInfo());
	    } else if (params.tst instanceof _KJUR_asn1.ASN1Object) {
		a.push(params.tst);
	    } else {
		throw new Error("improper member tst value");
	    }
	} else if (params.statusinfo != undefined) {
	    a.push(new _PKIStatusInfo(params.statusinfo));
	} else {
	    throw new Error("parameter for token nor statusinfo not specified");
	}
	    
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.tsp.TimeStampResp, KJUR.asn1.ASN1Object);

// --- BEGIN OF RFC 2510 CMP -----------------------------------------------

/**
 * class for TSP PKIStatusInfo ASN.1 object
 * @name KJUR.asn1.tsp.PKIStatusInfo
 * @class class for TSP PKIStatusInfo ASN.1 object
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.6.0 asn1tsp 1.0.0
 * @see KJUR.asn1.tsp.PKIStatus
 * @see KJUR.asn1.tsp.PKIFreeText
 * @see KJUR.asn1.tsp.PKIFailureInfo
 * @see KJUR.asn1.tsp.TSPParser#getPKIStatusInfo
 *
 * @description
 * This class provides ASN.1 PKIStatusInfo encoder
 * defined in 
 * <a href="https://tools.ietf.org/html/rfc3161#section-2.4.2">
 * RFC 3161 section 2.4.2</a>.
 * <pre>
 * PKIStatusInfo ::= SEQUENCE {
 *    status                  PKIStatus,
 *    statusString            PKIFreeText     OPTIONAL,
 *    failInfo                PKIFailureInfo  OPTIONAL  }
 * </pre>
 *
 * @example
 * new KJUR.asn1.tsp.PKIStatusInfo("granted")
 * new KJUR.asn1.tsp.PKIStatusInfo({status: "granted"})
 * new KJUR.asn1.tsp.PKIStatusInfo({
 *   status: 2, // rejection
 *   statusstr: ["unsupported algorithm"], // OPTION
 *   failinfo: 'badAlg' // OPTION
 * })
 */
KJUR.asn1.tsp.PKIStatusInfo = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_tsp = _KJUR_asn1.tsp,
	_PKIStatus = _KJUR_asn1_tsp.PKIStatus,
	_PKIFreeText = _KJUR_asn1_tsp.PKIFreeText,
	_PKIFailureInfo = _KJUR_asn1_tsp.PKIFailureInfo;

    _KJUR_asn1_tsp.PKIStatusInfo.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	var a = [];
	if (typeof params == "string") {
	    a.push(new _PKIStatus(params));
	} else {
	    if (params.status == undefined)
		throw new _Error("property 'status' unspecified");

	    a.push(new _PKIStatus(params.status));

	    if (params.statusstr != undefined)
		a.push(new _PKIFreeText(params.statusstr));

	    if (params.failinfo != undefined)
		a.push(new _PKIFailureInfo(params.failinfo));
	}

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.tsp.PKIStatusInfo, KJUR.asn1.ASN1Object);

/**
 * class for TSP PKIStatus ASN.1 object
 * @name KJUR.asn1.tsp.PKIStatus
 * @class class for TSP PKIStatus ASN.1 object
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.6.0 asn1tsp 1.0.0
 * @description
 * <pre>
 * PKIStatus ::= INTEGER {
 *    granted                (0),
 *    grantedWithMods        (1),
 *    rejection              (2),
 *    waiting                (3),
 *    revocationWarning      (4),
 *    revocationNotification (5) }
 * </pre>
 *
 * @example
 * new KJUR.asn1.tsp.PKIStatus('granted')
 * new KJUR.asn1.tsp.PKIStatus(2)
 */
KJUR.asn1.tsp.PKIStatus = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERInteger = _KJUR_asn1.DERInteger,
	_KJUR_asn1_tsp = _KJUR_asn1.tsp;

    _KJUR_asn1_tsp.PKIStatus.superclass.constructor.call(this);

    var _nameValue = {
	granted:                0,
	grantedWithMods:        1,
	rejection:              2,
	waiting:                3,
	revocationWarning:      4,
	revocationNotification: 5
    };

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	var dObj, value;

	if (typeof params == "string") {
	    try {
		value = _nameValue[params];
	    } catch (ex) {
		throw new _Error("undefined name: " + params);
		}
	} else if (typeof params == "number") {
	    value = params;
	} else {
	    throw new _Error("unsupported params");
	}

	return (new _DERInteger({"int": value})).tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.tsp.PKIStatus, KJUR.asn1.ASN1Object);

/**
 * class for TSP PKIFreeText ASN.1 object
 * @name KJUR.asn1.tsp.PKIFreeText
 * @class class for TSP PKIFreeText ASN.1 object
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.6.0 asn1tsp 1.0.0
 * @description
 * This class provides ASN.1 encoder for PKIFreeText
 * defined in <a href="https://tools.ietf.org/html/rfc4210#section-5.1.1">
 * RFC 4210 CMP section 5.1.1</a>.
 * <pre>
 * PKIFreeText ::= SEQUENCE { SIZE (1..MAX) OF UTF8String }
 * </pre>
 * 
 * @example
 * new KJUR.asn1.tsp.PKIFreeText([
 *   "aaa", "bbb", "ccc"
 * ])
 */
KJUR.asn1.tsp.PKIFreeText = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERUTF8String = _KJUR_asn1.DERUTF8String,
	_KJUR_asn1_tsp = _KJUR_asn1.tsp;

    _KJUR_asn1_tsp.PKIFreeText.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	if (! params instanceof Array)
	    throw new _Error("wrong params: not array");

	var a = [];
	for (var i = 0; i < params.length; i++) {
	    a.push(new _DERUTF8String({str: params[i]}));
	};
	
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.tsp.PKIFreeText, KJUR.asn1.ASN1Object);

/**
 * class for TSP PKIFailureInfo ASN.1 object<br/>
 * @name KJUR.asn1.tsp.PKIFailureInfo
 * @class class for TSP PKIFailureInfo ASN.1 object
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.6.0 asn1tsp 1.0.0
 * @see KJUR.asn1.tsp.PKIStatusInfo
 *
 * @description
 * This class provides ASN.1 PKIFailureInfo encoder
 * defined in 
 * <a href="https://tools.ietf.org/html/rfc3161#section-2.4.2">
 * RFC 3161 section 2.4.2</a>.
 * <pre>
 * PKIFailureInfo ::= BIT STRING {
 *    badAlg                 (0),
 *    badRequest             (2),
 *    badDataFormat          (5),
 *    timeNotAvailable       (14),
 *    unacceptedPolicy       (15),
 *    unacceptedExtension    (16),
 *    addInfoNotAvailable    (17),
 *    systemFailure          (25) }
 * </pre>
 * NOTE: Constructor of an array of failureInfo names string
 * has been supported since jsrsasign 10.5.21.
 * Ordering of names will be ignored so that
 * ['unacceptedPolicy', 'badAlg'] is also fine.
 * 
 * @example
 * new KJUR.asn1.tsp.PKIFailureInfo('badAlg')
 * new KJUR.asn1.tsp.PKIFailureInfo(5)
 * new KJUR.asn1.tsp.PKIFailureInfo(['badAlg', 'unacceptedPolicy'])
 */
KJUR.asn1.tsp.PKIFailureInfo = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERBitString = _KJUR_asn1.DERBitString,
	_KJUR_asn1_tsp = _KJUR_asn1.tsp,
	_PKIFailureInfo = _KJUR_asn1_tsp.PKIFailureInfo;

    var _nameValue = {
	badAlg:                 0,
	badRequest:             2,
	badDataFormat:          5,
	timeNotAvailable:       14,
	unacceptedPolicy:       15,
	unacceptedExtension:    16,
	addInfoNotAvailable:    17,
	systemFailure:          25
    };

    _PKIFailureInfo.superclass.constructor.call(this);

    this.params = null;

    this.getBinValue = function() {
	var params = this.params;

	var d = 0;

	if (typeof params == "number" && 
	    0 <= params && params <= 25) {
	    d |= 1 << params;
	    var s = d.toString(2);
	    var r = "";
	    for (var i = s.length - 1; i >= 0; i--) r += s[i];
	    return r;
	} else if (typeof params == "string" &&
		   _nameValue[params] != undefined) {
	    return namearraytobinstr([params], _nameValue);
	} else if (typeof params == "object" &&
		   params.length != undefined) {
	    return namearraytobinstr(params, _nameValue);
	} else {
	    throw new _Error("wrong params");
	}

	return 
    };

    this.tohex = function() {
	var params = this.params;

	var binValue = this.getBinValue();
	return (new _DERBitString({"bin": binValue})).tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.tsp.PKIFailureInfo, KJUR.asn1.ASN1Object);

// --- END OF RFC 2510 CMP -------------------------------------------

/**
 * abstract class for TimeStampToken generator (DEPRECATED)<br/>
 * @name KJUR.asn1.tsp.AbstractTSAAdapter
 * @class abstract class for TimeStampToken generator
 * @param {Array} params associative array of parameters
 * @since jsrsasign 4.7.0 asn1tsp 1.0.1
 * @deprecated since jsrsasign 10.0.0 asn1tsp 2.0.0
 *
 * @description
 * This is abstract class for TimeStampToken generator.
 */
KJUR.asn1.tsp.AbstractTSAAdapter = function(params) {
    this.getTSTHex = function(msgHex, hashAlg) {
        throw "not implemented yet";
    };
};

/**
 * class for simple TimeStampToken generator (DEPRECATED)<br/>
 * @name KJUR.asn1.tsp.SimpleTSAAdapter
 * @class class for simple TimeStampToken generator
 * @extends KJUR.asn1.tsp.AbstractTSAAdapter
 * @param {Array} params associative array of parameters
 * @since jsrsasign 4.7.0 asn1tsp 1.0.1
 * @deprecated since jsrsasign 10.0.0 asn1tsp 2.0.0
 *
 * @description
 * This is a simple TimeStampToken generator class.
 */
KJUR.asn1.tsp.SimpleTSAAdapter = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_tsp = _KJUR_asn1.tsp,
	_hashHex = _KJUR.crypto.Util.hashHex;

    _KJUR_asn1_tsp.SimpleTSAAdapter.superclass.constructor.call(this);
    this.params = null;
    this.serial = 0;

    this.getTSTHex = function(msgHex, hashAlg) {
        // messageImprint
        var hashHex = _hashHex(msgHex, hashAlg);
        this.params.econtent.content.messageImprint =
            {alg: hashAlg, hash: hashHex};

        // serial
        this.params.econtent.content.serial =
	    {'int': this.serial++};

        // nonce
        var nonceValue = Math.floor(Math.random() * 1000000000);
        this.params.econtent.content.nonce =
	    {'int': nonceValue};

        var obj = 
            new _KJUR_asn1_tsp.TimeStampToken(this.params);
        return obj.getContentInfoEncodedHex();
    };

    if (params !== undefined) this.params = params;
};
extendClass(KJUR.asn1.tsp.SimpleTSAAdapter,
            KJUR.asn1.tsp.AbstractTSAAdapter);

/**
 * class for fixed TimeStampToken generator (DEPRECATED)<br/>
 * @name KJUR.asn1.tsp.FixedTSAAdapter
 * @class class for fixed TimeStampToken generator
 * @extends KJUR.asn1.tsp.AbstractTSAAdapter
 * @param {Array} params associative array of parameters
 * @since jsrsasign 4.7.0 asn1tsp 1.0.1
 * @deprecated since jsrsasign 10.0.0 asn1tsp 2.0.0
 *
 * @description
 * This class generates fixed TimeStampToken except messageImprint
 * for testing purpose.
 * General TSA generates TimeStampToken which varies following
 * fields:
 * <ul>
 * <li>genTime</li>
 * <li>serialNumber</li>
 * <li>nonce</li>
 * </ul>
 * Those values are provided by initial parameters.
 */
KJUR.asn1.tsp.FixedTSAAdapter = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_tsp = _KJUR_asn1.tsp,
	_hashHex = _KJUR.crypto.Util.hashHex;

    _KJUR_asn1_tsp.FixedTSAAdapter.superclass.constructor.call(this);
    this.params = null;

    this.getTSTHex = function(msgHex, hashAlg) {
        // fixed serialNumber
        // fixed nonce        
        var hashHex = _hashHex(msgHex, hashAlg);
        this.params.econtent.content.messageImprint =
            {alg: hashAlg, hash: hashHex};
        var obj = new _KJUR_asn1_tsp.TimeStampToken(this.params);
        return obj.getContentInfoEncodedHex();
    };

    if (params !== undefined) this.params = params;
};
extendClass(KJUR.asn1.tsp.FixedTSAAdapter,
            KJUR.asn1.tsp.AbstractTSAAdapter);

// --- TSP utilities -------------------------------------------------

/**
 * TSP utiliteis class
 * @name KJUR.asn1.tsp.TSPUtil
 * @class TSP utilities class
 */
KJUR.asn1.tsp.TSPUtil = new function() {
};
/**
 * generate TimeStampToken ASN.1 object specified by JSON parameters (DEPRECATED)<br/>
 * @name newTimeStampToken
 * @memberOf KJUR.asn1.tsp.TSPUtil
 * @function
 * @param {Array} param JSON parameter to generate TimeStampToken
 * @return {KJUR.asn1.cms.SignedData} object just generated
 * @deprecated since jsrsasign 10.0.0 asn1tsp 2.0.0. Please use TimeStampToken class
 * @see KJUR.asn1.tsp.TimeStampToken
 *
 * @description
 * @example
 */
KJUR.asn1.tsp.TSPUtil.newTimeStampToken = function(params) {
    return new KJUR.asn1.tsp.TimeStampToken(params);
};

/**
 * parse hexadecimal string of TimeStampReq
 * @name parseTimeStampReq
 * @memberOf KJUR.asn1.tsp.TSPUtil
 * @function
 * @param {String} hexadecimal string of TimeStampReq
 * @return {Array} JSON object of parsed parameters
 * @see KJUR.asn1.tsp.TSPParser#getTimeStampReq
 * @deprecated since jsrsasign 10.5.18 asn1tsp 2.0.6. Please use TSPParser.getTimeStampReq instead.
 *
 * @description
 * This method parses a hexadecimal string of TimeStampReq
 * and returns parsed their fields:
 *
 * @example
 * var json = KJUR.asn1.tsp.TSPUtil.parseTimeStampReq("302602...");
 * // resulted DUMP of above 'json':
 * {
 *  messageImprint: {
 *       alg: 'sha256',          // MessageImprint hashAlg
 *       hash: 'a1a2a3a4...'},   // MessageImprint hashValue
 *  policy: '1.2.3.4.5',             // tsaPolicy (OPTION)
 *  nonce: '9abcf318...',            // nonce (OPTION)
 *  certreq: true}                   // certReq (OPTION)
 */
KJUR.asn1.tsp.TSPUtil.parseTimeStampReq = function(reqHex) {
    var parser = new KJUR.asn1.tsp.TSPParser();
    return parser.getTimeStampReq(reqHex);
};

/**
 * parse hexadecimal string of MessageImprint
 * @name parseMessageImprint
 * @memberOf KJUR.asn1.tsp.TSPUtil
 * @function
 * @param {String} hexadecimal string of MessageImprint
 * @return {Array} JSON object of parsed parameters
 * @see KJUR.asn1.tsp.TSPParser#getMessageImprint
 * @deprecated since jsrsasign 10.5.18 asn1tsp 2.0.6. Please use TSPParser.getMessageImprint instead.
 *
 * @description
 * This method parses a hexadecimal string of MessageImprint
 * and returns parsed their fields:
 *
 * @example
 * KJUR.asn1.tsp.TSPUtil.parseMessageImprint("302602...") &rarr;
 * { alg:  'sha256', hash: 'a1a2a3a4...'}
 */
KJUR.asn1.tsp.TSPUtil.parseMessageImprint = function(miHex) {
    var parser = new KJUR.asn1.tsp.TSPParser();
    return parser.getMessageImprint(miHex);
/*
    var _ASN1HEX = ASN1HEX;
    var _getChildIdx = _ASN1HEX.getChildIdx;
    var _getV = _ASN1HEX.getV;
    var _getIdxbyList = _ASN1HEX.getIdxbyList;
    var json = {};

    if (miHex.substr(0, 2) != "30")
        throw "head of messageImprint hex shall be '30'";

    var idxList = _getChildIdx(miHex, 0);
    var hashAlgOidIdx = _getIdxbyList(miHex, 0, [0, 0]);
    var hashAlgHex = _getV(miHex, hashAlgOidIdx);
    var hashAlgOid = _ASN1HEX.hextooidstr(hashAlgHex);
    var hashAlgName = KJUR.asn1.x509.OID.oid2name(hashAlgOid);
    if (hashAlgName == '')
        throw "hashAlg name undefined: " + hashAlgOid;
    var hashAlg = hashAlgName;
    var hashValueIdx = _getIdxbyList(miHex, 0, [1]);

    json.alg = hashAlg;
    json.hash = _getV(miHex, hashValueIdx); 

    return json;
*/
};

/**
 * class for parsing RFC 3161 TimeStamp protocol data<br/>
 * @name KJUR.asn1.tsp.TSPParser
 * @class RFC 3161 TimeStamp protocol parser class
 * @since jsrsasign 10.1.0 asn1tsp 2.0.1
 *
 * @description
 * This is an ASN.1 parser for 
 * <a href="https://tools.ietf.org/html/rfc3161">RFC 3161</a>.
 */
KJUR.asn1.tsp.TSPParser = function() {
    var _Error = Error,
	_X509 = X509,
	_x509obj = new _X509(),
	_ASN1HEX = ASN1HEX,
	_getV = _ASN1HEX.getV,
	_getTLV = _ASN1HEX.getTLV,
	_getIdxbyList = _ASN1HEX.getIdxbyList,
	_getTLVbyListEx = _ASN1HEX.getTLVbyListEx,
	_getChildIdx = _ASN1HEX.getChildIdx;
    var _aSTATUSSTR = [
	"granted", "grantedWithMods", "rejection", "waiting",
	"revocationWarning", "revocationNotification" ];
    var _pFAILUREINFO = {
	0: "badAlg", 2: "badRequest", 5: "badDataFormat",
	14: "timeNotAvailable", 15: "unacceptedPolicy",
	16: "unacceptedExtension", 17: "addInfoNotAvailable",
	25: "systemFailure"
    };
    
    /**
     * parse ASN.1 TimeStampResp<br/>
     * @name getResponse
     * @memberOf KJUR.asn1.tsp.TSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 TimeStampResp
     * @return {Array} JSON object of TimeStampResp parameter
     * @see KJUR.asn1.tsp.TimeStampResp
     * @see KJUR.asn1.tsp.TimeStampToken
     * @see KJUR.asn1.cms.CMSParser#getCMSSignedData
     *
     * @description
     * This method parses ASN.1 TimeStampRsp defined in RFC 3161.
     * <pre>
     * TimeStampResp ::= SEQUENCE {
     *   status          PKIStatusInfo,
     *   timeStampToken  TimeStampToken  OPTIONAL }
     * </pre>
     * When "h" is a TSP error response,
     * returned parameter contains "statusinfo" only.
     *
     * @example
     * parser = new KJUR.asn1.tsp.TSPParser();
     * parser.getResponse("30...") &rarr;
     * { 
     *   statusinfo: 'granted',
     *   ... // almost the same as CMS SignedData parameters
     *   econtent: {
     *     type: "tstinfo",
     *     content: { // TSTInfo parameter
     *       policy: '1.2.3.4.5',
     *       messageImprint: {alg: 'sha256', hash: 'a1a2a3a4...'},
     *       serial: {'int': 3},
     *       genTime: {str: '20131231235959.123Z'},
     *       accuracy: {millis: 500},
     *       ordering: true,
     *       nonce: {int: 3}
     *     }
     *   },
     *   ...
     * }
     */
    this.getResponse = function(h) {
	var aIdx = _getChildIdx(h, 0);
	
	if (aIdx.length == 1) {
	    return this.getPKIStatusInfo(_getTLV(h, aIdx[0]));
	} else if (aIdx.length > 1) {
	    var pPKIStatusInfo = this.getPKIStatusInfo(_getTLV(h, aIdx[0]));
	    var hTST = _getTLV(h, aIdx[1]);
	    var pResult = this.getToken(hTST);
	    pResult.statusinfo = pPKIStatusInfo;
	    return pResult;
	}
    };

    /**
     * parse ASN.1 TimeStampToken<br/>
     * @name getToken
     * @memberOf KJUR.asn1.tsp.TSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 TimeStampToken
     * @return {Array} JSON object of TimeStampToken parameter
     * @see KJUR.asn1.tsp.TimeStampToken
     * @see KJUR.asn1.cms.CMSParser#getCMSSignedData
     * @see KJUR.asn1.tsp.TSPParser#setTSTInfo
     *
     * @description
     * This method parses ASN.1 TimeStampRsp defined in RFC 3161.
     * This method will parse "h" as CMS SigneData by
     * {@link KJUR.asn1.cms.CMSParser#getCMSSignedData}, then
     * parse and modify "econtent.content" parameter by
     * {@link KJUR.asn1.tsp.TSPParser#setTSTInfo} method.
     *
     * @example
     * parser = new KJUR.asn1.tsp.TSPParser();
     * parser.getToken("30...") &rarr;
     * { 
     *   ... // almost the same as CMS SignedData parameters
     *   econtent: {
     *     type: "tstinfo",
     *     content: { // TSTInfo parameter
     *       policy: '1.2.3.4.5',
     *       messageImprint: {alg: 'sha256', hash: 'a1a2a3a4...'},
     *       serial: {'int': 3},
     *       genTime: {str: '20131231235959.123Z'},
     *       accuracy: {millis: 500},
     *       ordering: true,
     *       nonce: {int: 3}
     *     }
     *   },
     *   ...
     * }
     */
    this.getToken = function(h) {
	var _CMSParser = new KJUR.asn1.cms.CMSParser;
	var p = _CMSParser.getCMSSignedData(h);
	this.setTSTInfo(p);
	return p;
    };

    /**
     * set ASN.1 TSTInfo parameter to CMS SignedData parameter<br/>
     * @name setTSTInfo
     * @memberOf KJUR.asn1.tsp.TSPParser#
     * @function
     * @param {Array} pCMSSignedData JSON object of CMS SignedData parameter
     * @see KJUR.asn1.tsp.TimeStampToken
     * @see KJUR.asn1.cms.CMSParser#getCMSSignedData
     *
     * @description
     * This method modifies "econtent.content" of CMS SignedData parameter
     * to parsed TSTInfo.
     * <pre>
     *
     * @example
     * parser = new KJUR.asn1.tsp.TSPParser();
     * pCMSSignedData = { 
     *   ... // almost the same as CMS SignedData parameters
     *   econtent: {
     *     type: "tstinfo",
     *     content: { hex: "30..." }
     *   },
     *   ...
     * };
     * parser.setTSTInfo(pCMSSignedData);
     * pCMSSignedData &rarr; { 
     *   ... // almost the same as CMS SignedData parameters
     *   econtent: {
     *     type: "tstinfo",
     *     content: { // TSTInfo parameter
     *       policy: '1.2.3.4.5',
     *       messageImprint: {alg: 'sha256', hash: 'a1a2a3a4...'},
     *       serial: {int: 3},
     *       genTime: {str: '20131231235959.123Z'},
     *       accuracy: {millis: 500},
     *       ordering: true,
     *       nonce: {int: 3}
     *     }
     *   },
     *   ...
     * };
     */
    this.setTSTInfo = function(pCMSSignedData) {
	var pEContent = pCMSSignedData.econtent;
	if (pEContent.type == "tstinfo") {
	    var hContent = pEContent.content.hex;
	    var pTSTInfo = this.getTSTInfo(hContent);
	    //pTSTInfo.hex_ = hContent;
	    pEContent.content = pTSTInfo;
	}
    };

    /**
     * parse ASN.1 TSTInfo<br/>
     * @name getTSTInfo
     * @memberOf KJUR.asn1.tsp.TSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 TSTInfo
     * @return {Array} JSON object of TSTInfo parameter
     * @see KJUR.asn1.tsp.TSTInfo
     *
     * @description
     * This method parses ASN.1 TSTInfo defined in RFC 3161.
     * <pre>
     * TSTInfo ::= SEQUENCE  {
     *    version          INTEGER  { v1(1) },
     *    policy           TSAPolicyId,
     *    messageImprint   MessageImprint,
     *    serialNumber     INTEGER,
     *    genTime          GeneralizedTime,
     *    accuracy         Accuracy                 OPTIONAL,
     *    ordering         BOOLEAN             DEFAULT FALSE,
     *    nonce            INTEGER                  OPTIONAL,
     *    tsa              [0] GeneralName          OPTIONAL,
     *    extensions       [1] IMPLICIT Extensions  OPTIONAL }
     * </pre>
     *
     * @example
     * parser = new KJUR.asn1.tsp.TSPParser();
     * parser.getTSTInfo("30...") &rarr;
     * {
     *   policy: '1.2.3.4.5',
     *   messageImprint: {alg: 'sha256', hash: 'a1a2a3a4...'},
     *   serial: {'int': 3},
     *   genTime: {str: '20131231235959.123Z'},
     *   accuracy: {millis: 500},
     *   ordering: true,
     *   nonce: {int: 3}
     * }
     */
    this.getTSTInfo = function(h) {
	var pResult = {};
	var aIdx = _getChildIdx(h, 0);

	var hPolicy = _getV(h, aIdx[1]);
	pResult.policy = hextooid(hPolicy);

	var hMessageImprint = _getTLV(h, aIdx[2]);
	pResult.messageImprint = this.getMessageImprint(hMessageImprint);

	var hSerial = _getV(h, aIdx[3]);
	pResult.serial = {hex: hSerial};

	var hGenTime = _getV(h, aIdx[4]);
	pResult.genTime = {str: hextoutf8(hGenTime)};

	var offset = 0;

	if (aIdx.length > 5 && h.substr(aIdx[5], 2) == "30") {
	    var hAccuracy = _getTLV(h, aIdx[5]);
	    pResult.accuracy = this.getAccuracy(hAccuracy);
	    offset++;
	}

	if (aIdx.length > 5 + offset && 
	    h.substr(aIdx[5 + offset], 2) == "01") {
	    var hOrdering = _getV(h, aIdx[5 + offset]);
	    if (hOrdering == "ff") pResult.ordering = true;
	    offset++;
	}

	if (aIdx.length > 5 + offset &&
	    h.substr(aIdx[5 + offset], 2) == "02") {
	    var hNonce = _getV(h, aIdx[5 + offset]);
	    pResult.nonce = {hex: hNonce};
	    offset++;
	}

	if (aIdx.length > 5 + offset &&
	    h.substr(aIdx[5 + offset], 2) == "a0") {
	    var hGeneralNames = _getTLV(h, aIdx[5 + offset]);
	    hGeneralNames = "30" + hGeneralNames.substr(2);
	    pGeneralNames = _x509obj.getGeneralNames(hGeneralNames);
	    var pName = pGeneralNames[0].dn;
	    pResult.tsa = pName;
	    offset++;
	}

	if (aIdx.length > 5 + offset &&
	    h.substr(aIdx[5 + offset], 2) == "a1") {
	    var hExt = _getTLV(h, aIdx[5 + offset]);
	    hExt = "30" + hExt.substr(2);
	    var aExt = _x509obj.getExtParamArray(hExt);
	    pResult.ext = aExt;
	    offset++;
	}

	return pResult;
    };

    /**
     * parse ASN.1 Accuracy<br/>
     * @name getAccuracy
     * @memberOf KJUR.asn1.tsp.TSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 Accuracy
     * @return {Array} JSON object of Accuracy parameter
     * @see KJUR.asn1.tsp.Accuracy
     *
     * @description
     * This method parses ASN.1 Accuracy defined in RFC 3161.
     * <pre>
     * Accuracy ::= SEQUENCE {
     *    seconds        INTEGER              OPTIONAL,
     *    millis     [0] INTEGER  (1..999)    OPTIONAL,
     *    micros     [1] INTEGER  (1..999)    OPTIONAL  }
     * </pre>
     *
     * @example
     * parser = new KJUR.asn1.tsp.TSPParser();
     * parser.getAccuracy("30...") &rarr; {millis: 500}
     */
    this.getAccuracy = function(h) {
	var pResult = {};

	var aIdx = _getChildIdx(h, 0);

	for (var i = 0; i < aIdx.length; i++) {
	    var tag = h.substr(aIdx[i], 2);
	    var hV = _getV(h, aIdx[i]);
	    var iV = parseInt(hV, 16);

	    if (tag == "02") {
		pResult.seconds = iV;
	    } else if (tag == "80") {
		pResult.millis = iV;
	    } else if (tag == "81") {
		pResult.micros = iV;
	    }
	}

	return pResult;
    };

    /**
     * parse ASN.1 MessageImprint<br/>
     * @name getMessageImprint
     * @memberOf KJUR.asn1.tsp.TSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 MessageImprint
     * @return {Array} JSON object of MessageImprint parameter
     * @see KJUR.asn1.tsp.MessageImprint
     *
     * @description
     * This method parses ASN.1 MessageImprint defined in RFC 3161.
     *
     * @example
     * parser = new KJUR.asn1.tsp.TSPParser();
     * parser.getMessageImprint("30...") &rarr; 
     * { alg: "sha256", hash: "12ab..." }
     */
    this.getMessageImprint = function(h) {
	if (h.substr(0, 2) != "30")
            throw new Error("head of messageImprint hex shall be x30");

	var json = {};
	var idxList = _getChildIdx(h, 0);
	var hashAlgOidIdx = _getIdxbyList(h, 0, [0, 0]);
	var hashAlgHex = _getV(h, hashAlgOidIdx);
	var hashAlgOid = _ASN1HEX.hextooidstr(hashAlgHex);
	var hashAlgName = KJUR.asn1.x509.OID.oid2name(hashAlgOid);
	if (hashAlgName == '')
            throw new Error("hashAlg name undefined: " + hashAlgOid);
	var hashAlg = hashAlgName;
	var hashValueIdx = _getIdxbyList(h, 0, [1]);
	
	json.alg = hashAlg;
	json.hash = _getV(h, hashValueIdx); 

	return json;
    };

    /**
     * parse ASN.1 PKIStatusInfo<br/>
     * @name getPKIStatusInfo
     * @memberOf KJUR.asn1.tsp.TSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 PKIStatusInfo
     * @return {Array} JSON object of PKIStatusInfo parameter
     * @see KJUR.asn1.tsp.PKIStatusInfo
     *
     * @description
     * This method parses ASN.1 PKIStatusInfo defined in RFC 3161.
     *
     * @example
     * parser = new KJUR.asn1.tsp.TSPParser();
     * parser.getPKIStatusInfo("30...") &rarr; 
     * { status: "rejection",
     *   statusstr: ["unsupported algorithm"],
     *   failinfo: "badAlg" }
     */
    this.getPKIStatusInfo = function(h) {
	var pResult = {};
	var aIdx = _getChildIdx(h, 0);
	var offset = 0;

	try {
	    var hStatus = _getV(h, aIdx[0]);
	    var iStatus = parseInt(hStatus, 16);
	    pResult.status = _aSTATUSSTR[iStatus];
	} catch(ex) {};

	if (aIdx.length > 1 && h.substr(aIdx[1], 2) == "30") {
	    var hPKIFreeText = _getTLV(h, aIdx[1]);
	    pResult.statusstr = 
		this.getPKIFreeText(hPKIFreeText);
	    offset++;
	}

	if (aIdx.length > offset &&
	    h.substr(aIdx[1 + offset], 2) == "03") {
	    var hPKIFailureInfo = _getTLV(h, aIdx[1 + offset]);
	    pResult.failinfo = 
		this.getPKIFailureInfo(hPKIFailureInfo);
	}

	return pResult;
    };

    /**
     * parse ASN.1 PKIFreeText<br/>
     * @name getPKIFreeText
     * @memberOf KJUR.asn1.tsp.TSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 PKIFreeText
     * @return {Array} array of string
     * @since jsrsasign 10.1.3 asn1tsp 2.0.3
     * @see KJUR.asn1.tsp.PKIFreeText
     *
     * @description
     * This method parses ASN.1 PKIFreeText defined in RFC 3161.
     *
     * @example
     * parser = new KJUR.asn1.tsp.TSPParser();
     * parser.getPKIFreeText("300a0c036161610c03616161") &rarr; 
     * ["aaa", "aaa"]
     */
    this.getPKIFreeText = function(h) {
	var aResult = [];
	var aIdx = _getChildIdx(h, 0);
	for (var i = 0; i < aIdx.length; i++) {
	    aResult.push(_ASN1HEX.getString(h, aIdx[i]));
	}
	return aResult;
    };

    /**
     * parse ASN.1 PKIFailureInfo<br/>
     * @name getPKIFailureInfo
     * @memberOf KJUR.asn1.tsp.TSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 PKIFailureInfo
     * @return {Object} failureInfo string or number
     * @since jsrsasign 10.1.3 asn1tsp 2.0.3
     * @see KJUR.asn1.tsp.PKIFailureInfo
     *
     * @description
     * This method parses ASN.1 PKIFailureInfo defined in RFC 3161.
     *
     * @example
     * parser = new KJUR.asn1.tsp.TSPParser();
     * parser.getPKIFailureInfo("03020700") &rarr; "badAlg"
     * parser.getPKIFailureInfo("03020780") &rarr; 1
     * parser.getPKIFailureInfo("030203c8") &rarr; "systemFailure"
     */
    this.getPKIFailureInfo = function(h) {
	var n = _ASN1HEX.getInt(h, 0);
	if (_pFAILUREINFO[n] != undefined) {
	    return _pFAILUREINFO[n];
	} else {
	    return n;
	}
    };

    /**
     * parse hexadecimal string of TimeStampReq<br/>
     * @name getTimeStampReq
     * @memberOf KJUR.asn1.tsp.TSPParser#
     * @function
     * @param {String} h hexadecimal string of TimeStampReq
     * @return {Array} JSON object of parsed parameters
     * @since jsrsasign 10.5.18 asn1tsp 2.0.6
     * @see KJUR.asn1.tsp.TimeStampReq
     * @see KJUR.asn1.tsp.TSPUtil.parseTimeStampReq
     *
     * @description
     * This method parses a hexadecimal string of TimeStampReq
     * and returns parsed their fields:
     *
     * @example
     * var parser = new KJUR.asn1.tsp.TSPParser();
     * parser.getTimeStampReq("302602...") &rarr;
     * { messageImprint: {
     *       alg: 'sha256',          // MessageImprint hashAlg
     *       hash: 'a1a2a3a4...'},   // MessageImprint hashValue
     *   policy: '1.2.3.4.5',         // tsaPolicy (OPTION)
     *   nonce: '9abcf318...',        // nonce (OPTION)
     *   certreq: true }              // certReq (OPTION)
     */
    this.getTimeStampReq = function(h) {
	var json = {};
	json.certreq = false;

	var idxList = _getChildIdx(h, 0);

	if (idxList.length < 2)
            throw new Error("TimeStampReq must have at least 2 items");

        const vtag = h.substr(idxList[0], 2);
        if (vtag !== '02')
           throw new Error('invalid TimestampRequest');
        json.version = _getV(h, idxList[0]);
        if (json.version !== '01')
           throw Error('TimestampRequest version not supported');
	var miHex = _getTLV(h, idxList[1]);
	json.messageImprint = KJUR.asn1.tsp.TSPUtil.parseMessageImprint(miHex); 

	for (var i = 2; i < idxList.length; i++) {
            var idx = idxList[i];
            var tag = h.substr(idx, 2);
            if (tag == "06") { // case OID
		var policyHex = _getV(h, idx);
		json.policy = _ASN1HEX.hextooidstr(policyHex);
            }
            if (tag == "02") { // case INTEGER
		json.nonce = _getV(h, idx);
            }
            if (tag == "01") { // case BOOLEAN
		json.certreq = true;
            }
	}

	return json;
    };
};

/* asn1cades-2.0.2.js (c) 2014-2022 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * asn1cades.js - ASN.1 DER encoder classes for RFC 5126 CAdES long term signature
 *
 * Copyright (c) 2014-2022 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name asn1cades-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.5.16 asn1cades 2.0.2 (2022-Apr-08)
 * @since jsrsasign 4.7.0
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/** 
 * kjur's class library name space
 * // already documented in asn1-1.0.js
 * @name KJUR
 * @namespace kjur's class library name space
 */
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};

/**
 * kjur's ASN.1 class library name space
 * // already documented in asn1-1.0.js
 * @name KJUR.asn1
 * @namespace
 */
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};

/**
 * kjur's ASN.1 class for RFC 5126 CAdES long term signature
 * <p>
 * This name space provides 
 * <a href="https://tools.ietf.org/html/rfc5126">RFC 5126
 * CAdES(CMS Advanced Electronic Signature)</a> generator.
 *
 * <h4>SUPPORTED FORMATS</h4>
 * Following CAdES formats is supported by this library.
 * <ul>
 * <li>CAdES-BES - CAdES Basic Electronic Signature</li>
 * <li>CAdES-EPES - CAdES Explicit Policy-based Electronic Signature</li>
 * <li>CAdES-T - Electronic Signature with Time</li>
 * </ul>
 * </p>
 *
 * <h4>PROVIDED ATTRIBUTE CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.cades.SignaturePolicyIdentifier} - for CAdES-EPES
 *   <ul>
 *   <li>{@link KJUR.asn1.cades.SignaturePolicyId}</li>
 *   </ul>
 * </li>
 * <li>{@link KJUR.asn1.cades.SignatureTimeStamp} - for CAdES-T</li>
 * <li>{@link KJUR.asn1.cades.CompleteCertificateRefs} - for CAdES-C(for future use)
 *   <ul>
 *   <li>{@link KJUR.asn1.cades.OtherCertID}</li>
 *   <li>{@link KJUR.asn1.cades.OtherHash}</li>
 *   <li>{@link KJUR.asn1.cades.OtherHashAlgAndValue}</li>
 *   <li>{@link KJUR.asn1.cades.OtherHashValue}</li>
 *   </ul>
 * </li>
 * </ul>
 * NOTE: Currntly CAdES-C is not supported since parser can't
 * handle unsigned attribute.
 * 
 * <h4>OTHER CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.cades.CAdESUtil} - utilities for CAdES</li>
 * </ul>
 *
 * <h4>GENERATE CAdES-BES</h4>
 * To generate CAdES-BES, {@link KJUR.asn.cades} namespace 
 * classes are not required and already {@link KJUR.asn.cms} namespace 
 * provides attributes for CAdES-BES.
 * Create {@link KJUR.asn1.cms.SignedData} with following
 * mandatory attribute in CAdES-BES:
 * <ul>
 * <li>{@link KJUR.asn1.cms.ContentType}</li>
 * <li>{@link KJUR.asn1.cms.MessageDigest}</li>
 * <li>{@link KJUR.asn1.cms.SigningCertificate} or </li>
 * <li>{@link KJUR.asn1.cms.SigningCertificateV2}</li>
 * </ul>
 * CMSUtil.newSignedData method is very useful to generate CAdES-BES.
 * <pre>
 * sd = KJUR.asn1.cms.CMSUtil.newSignedData({
 *   content: {str: "aaa"},
 *   certs: [certPEM],
 *   signerInfos: [{
 *     hashAlg: 'sha256',
 *     sAttr: {SigningCertificateV2: {array: [certPEM]}},
 *     signerCert: certPEM,
 *     sigAlg: 'SHA256withRSA',
 *     signerPrvKey: pkcs8PrvKeyPEM
 *   }]
 * });
 * signedDataHex = sd.getContentInfoEncodedHex();
 * </pre>
 * NOTE: ContentType and MessageDigest signed attributes
 * are automatically added by default.
 *
 * <h4>GENERATE CAdES-BES with multiple signers</h4>
 * If you need signature by multiple signers, you can 
 * specify one or more items in 'signerInfos' property as below.
 * <pre>
 * sd = KJUR.asn1.cms.CMSUtil.newSignedData({
 *   content: {str: "aaa"},
 *   certs: [certPEM1, certPEM2],
 *   signerInfos: [{
 *     hashAlg: 'sha256',
 *     sAttr: {SigningCertificateV2: {array: [certPEM1]}},
 *     signerCert: certPEM1,
 *     sigAlg: 'SHA256withRSA',
 *     signerPrvKey: pkcs8PrvKeyPEM1
 *   },{
 *     hashAlg: 'sha1',
 *     sAttr: {SigningCertificateV2: {array: [certPEM2]}},
 *     signerCert: certPEM2,
 *     sigAlg: 'SHA1withRSA',
 *     signerPrvKey: pkcs8PrvKeyPEM2
 *   }]
 * });
 * signedDataHex = sd.getContentInfoEncodedHex();
 * </pre>
 *
 * <h4>GENERATE CAdES-EPES</h4>
 * When you need a CAdES-EPES signature,
 * you just need to add 'SignaturePolicyIdentifier'
 * attribute as below.
 * <pre>
 * sd = KJUR.asn1.cms.CMSUtil.newSignedData({
 *   content: {str: "aaa"},
 *   certs: [certPEM],
 *   signerInfos: [{
 *     hashAlg: 'sha256',
 *     sAttr: {
 *       SigningCertificateV2: {array: [certPEM]},
 *       SignaturePolicyIdentifier: {
 *         oid: '1.2.3.4.5',
 *         hash: {alg: 'sha1', hash: 'b1b2b3b4b...'}
 *       },
 *     },
 *     signerCert: certPEM,
 *     sigAlg: 'SHA256withRSA',
 *     signerPrvKey: pkcs8PrvKeyPEM
 *   }]
 * });
 * signedDataHex = sd.getContentInfoEncodedHex();
 * </pre>
 *
 * <h4>GENERATE CAdES-T</h4>
 * After a signed CAdES-BES or CAdES-EPES signature have been generated,
 * you can generate CAdES-T by adding SigningTimeStamp unsigned attribute.
 * <pre>
 * beshex = "30..."; // hex of CAdES-BES or EPES data 
 * info = KJUR.asn1.cades.CAdESUtil.parseSignedDataForAddingUnsigned(beshex);
 * // You can refer a hexadecimal string of signature value 
 * // in the first signerInfo in the CAdES-BES/EPES with a variable:
 * // 'info.si[0].sigval'. You need to get RFC 3161 TimeStampToken
 * // from a trusted time stamp authority. Otherwise you can also 
 * // get it by 'KJUR.asn1.tsp' module. We suppose that we could 
 * // get proper time stamp.
 * tsthex0 = "30..."; // hex of TimeStampToken for signerInfo[0] sigval
 * si0 = info.obj.signerInfoList[0];
 * si0.addUnsigned(new KJUR.asn1.cades.SignatureTimeStamp({tst: tsthex0});
 * esthex = info.obj.getContentInfoEncodedHex(); // CAdES-T
 * </pre>
 * </p>
 *
 * <h4>SAMPLE CODES</h4>
 * <ul>
 * <li><a href="../../tool_cades.html">demo program for CAdES-BES/EPES/T generation</a></li>
 * <li><a href="../../test/qunit-do-asn1cades.html">Unit test code for KJUR.asn1.cades package</a></li>
 * <li><a href="../../test/qunit-do-asn1tsp.html">Unit test code for KJUR.asn1.tsp package (See SimpleTSAAdaptor test)</a></li>
 * <li><a href="../../test/qunit-do-asn1cms.html">Unit test code for KJUR.asn1.cms package (See newSignedData test)</a></li>
 * </ul>
 * 
 * @name KJUR.asn1.cades
 * @namespace
 */
if (typeof KJUR.asn1.cades == "undefined" || !KJUR.asn1.cades) KJUR.asn1.cades = {};

/**
 * class for RFC 5126 CAdES SignaturePolicyIdentifier attribute
 * @name KJUR.asn1.cades.SignaturePolicyIdentifier
 * @class class for RFC 5126 CAdES SignaturePolicyIdentifier attribute
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.cms.Attribute
 * @since jsrsasign 4.7.0 asn1cades 1.0.0
 * @see KJUR.asn1.cms.AttributeList
 * @see KJUR.asn1.cms.CMSParser#setSignaturePolicyIdentifier
 * @see KJUR.asn1.cades.SignaturePolicyId
 * @see KJUR.asn1.cades.OtherHashAlgAndValue
 *
 * @description
 * This class provides ASN.1 encoder for
 * <a href="https://tools.ietf.org/html/rfc5126#section-5.8.1">
 * SignaturePolicyIdentifier defined in RFC 5126 CAdES section 5.8.1</a>.
 * <pre>
 * SignaturePolicyIdentifier ::= CHOICE {
 *    signaturePolicyId       SignaturePolicyId,
 *    signaturePolicyImplied  SignaturePolicyImplied } -- not used
 *
 * SignaturePolicyImplied ::= NULL
 * SignaturePolicyId ::= SEQUENCE {
 *    sigPolicyId           SigPolicyId,
 *    sigPolicyHash         SigPolicyHash,
 *    sigPolicyQualifiers   SEQUENCE SIZE (1..MAX) OF
 *                             SigPolicyQualifierInfo OPTIONAL }
 * SigPolicyId ::= OBJECT IDENTIFIER
 * SigPolicyHash ::= OtherHashAlgAndValue
 * </pre>
 *
 * @example
 * new KJUR.asn1.cades.SignaturePolicyIdentifier({
 *   attr: "signaturePolicyIdentifier",
 *   oid: '1.2.3.4.5',
 *   alg: 'sha1',
 *   hash: 'a1a2a3a4...'
 * })
 */
KJUR.asn1.cades.SignaturePolicyIdentifier = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_cades = _KJUR_asn1.cades,
	_SignaturePolicyId = _KJUR_asn1_cades.SignaturePolicyId;
	
    _KJUR_asn1_cades.SignaturePolicyIdentifier.superclass.constructor.call(this);

    this.typeOid = "1.2.840.113549.1.9.16.2.15";

    this.params = null;

    this.getValueArray = function() {
	return [new _SignaturePolicyId(this.params)];
    };

    this.setByParam = function(params) {
	this.params = params;
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cades.SignaturePolicyIdentifier,
            KJUR.asn1.cms.Attribute);

/**
 * RFC 5126 CAdES SignaturePolicyId ASN.1 structure class<br/>
 * @name KJUR.asn1.cades.SignaturePolicyId
 * @class RFC 5126 CAdES SignaturePolicyId ASN.1 structure class
 * @param {Array} params JSON object of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 10.0.0 asn1cades 2.0.0
 * @see KJUR.asn1.cades.SignaturePolicyIdentifier
 * @see KJUR.asn1.cades.OtherHashAlgAndValue
 *
 * @description
 * This class provides ASN.1 encoder for
 * <a href="https://tools.ietf.org/html/rfc5126#section-5.8.1">
 * SignaturePolicyId defined in RFC 5126 CAdES section 5.8.1</a>.
 * <pre>
 * SignaturePolicyId ::= SEQUENCE {
 *    sigPolicyId           SigPolicyId,
 *    sigPolicyHash         SigPolicyHash,
 *    sigPolicyQualifiers   SEQUENCE SIZE (1..MAX) OF
 *                             SigPolicyQualifierInfo OPTIONAL }
 * SigPolicyId ::= OBJECT IDENTIFIER
 * SigPolicyHash ::= OtherHashAlgAndValue
 * OtherHashAlgAndValue ::= SEQUENCE {
 *    hashAlgorithm   AlgorithmIdentifier,
 *    hashValue       OtherHashValue }
 * OtherHashValue ::= OCTET STRING
 * </pre>
 * Following properties can be apply to constructor arguments 
 * adding to {@link KJUR.asn1.cades.OtherHashAlgAndValue} constructor:
 * <ul>
 * <li>{String} oid - signature policy OID string or name (ex. 1.2.3.4)</li>
 * </ul>
 * 
 * @example
 * new KJUR.asn1.cades.SignaturePolicyId({
 *   oid: "1.2.3.4.5",
 *   alg: "sha256",
 *   hash: "1234abcd..."
 * });
 */
KJUR.asn1.cades.SignaturePolicyId = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_AlgorithmIdentifier = _KJUR_asn1_x509.AlgorithmIdentifier,
	_KJUR_asn1_cades = _KJUR_asn1.cades,
	_SignaturePolicyId = _KJUR_asn1_cades.SignaturePolicyId,
	_OtherHashAlgAndValue = _KJUR_asn1_cades.OtherHashAlgAndValue;

    _SignaturePolicyId.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	var a = [];
	a.push(new _DERObjectIdentifier(params.oid));
	a.push(new _OtherHashAlgAndValue(params));
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.setByParam = function(params) {
	this.params = params;
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cades.SignaturePolicyId, KJUR.asn1.ASN1Object);

/**
 * class for OtherHashAlgAndValue ASN.1 object<br/>
 * @name KJUR.asn1.cades.OtherHashAlgAndValue
 * @class class for OtherHashAlgAndValue ASN.1 object
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.7.0 asn1cades 1.0.0
 *
 * @description
 * This class provides ASN.1 encoder for
 * <a href="https://tools.ietf.org/html/rfc5126#section-5.8.1">
 * OtherHashAlgAndValue defined in RFC 5126 CAdES section 5.8.1</a>.
 * <pre>
 * OtherHashAlgAndValue ::= SEQUENCE {
 *    hashAlgorithm   AlgorithmIdentifier,
 *    hashValue       OtherHashValue }
 * OtherHashValue ::= OCTET STRING
 * </pre>
 * Following properties can be apply to constructor arguments:
 * <ul>
 * <li>{String} alg - hash algorithm name for "hashAlgorithm" field</li>
 * <li>{String} hash - hexadecimal string for "hashValue" field</li>
 * </ul>
 * 
 * @example
 * // specify by hash
 * new KJUR.asn1.cades.OtherHashAlgAndValue({
 *   alg: "sha256",
 *   hash: "12abcd..."
 * })
 *
 * // or specify by cert PEM or hex
 * new KJUR.asn1.cades.OtherHashAlgAndValue({
 *   alg: "sha256",
 *   cert: "-----BEGIN..."
 * })
 * new KJUR.asn1.cades.OtherHashAlgAndValue({
 *   alg: "sha256",
 *   cert: "3082..."
 * })
 */
KJUR.asn1.cades.OtherHashAlgAndValue = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_AlgorithmIdentifier = _KJUR_asn1_x509.AlgorithmIdentifier,
	_KJUR_asn1_cades = _KJUR_asn1.cades,
	_OtherHashAlgAndValue = _KJUR_asn1_cades.OtherHashAlgAndValue;

    _OtherHashAlgAndValue.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	if (params.alg == undefined)
	    throw new _Error("property 'alg' not specified");

	if (params.hash == undefined && params.cert == undefined)
	    throw new _Error("property 'hash' nor 'cert' not specified");

	var hHash = null;
	if (params.hash != undefined) {
	    hHash = params.hash;
	} else if (params.cert != undefined) {
	    if (typeof params.cert != "string")
		throw new _Error("cert not string");

	    var hCert = params.cert;
	    if (params.cert.indexOf("-----BEGIN") != -1) {
		hCert = pemtohex(params.cert);
	    }
	    hHash = KJUR.crypto.Util.hashHex(hCert, params.alg);
	}

	var a = [];
	a.push(new _AlgorithmIdentifier({name: params.alg}));
	a.push(new _DEROctetString({hex: hHash}));
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cades.OtherHashAlgAndValue, KJUR.asn1.ASN1Object);

/**
 * class for OtherHashValue ASN.1 object<br/>
 * @name KJUR.asn1.cades.OtherHashValue
 * @class class for OtherHashValue ASN.1 object
 * @param {Array} params JSON object of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 10.0.0 asn1cades 2.0.0
 *
 * This class provides ASN.1 encoder for
 * <a href="https://tools.ietf.org/html/rfc5126#section-5.8.1">
 * OtherHashAlgAndValue defined in RFC 5126 CAdES section 5.8.1</a>.
 * <pre>
 * OtherHashValue ::= OCTET STRING
 * </pre>
 *
 * @example
 * new KJUR.asn1.cades.OtherHashValue({hash: "12ab..."})
 * new KJUR.asn1.cades.OtherHashValue({cert: "-----BEGIN..."})
 * new KJUR.asn1.cades.OtherHashValue({cert: "3081..."})
 */
KJUR.asn1.cades.OtherHashValue = function(params) {
    KJUR.asn1.cades.OtherHashValue.superclass.constructor.call(this);

    var _Error = Error,
	_KJUR = KJUR,
	_isHex = _KJUR.lang.String.isHex,
	_KJUR_asn1 = _KJUR.asn1,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_hashHex = _KJUR.crypto.Util.hashHex;
    
    this.params = null;

    this.tohex = function() {
	var params = this.params;

	if (params.hash == undefined && params.cert == undefined) {
	    throw new _Error("hash or cert not specified");
	}

	var hHash = null;
	if (params.hash != undefined) {
	    hHash = params.hash;
	} else if (params.cert != undefined) {
	    if (typeof params.cert != "string") {
		throw new _Error("cert not string");
	    }
	    var hCert = params.cert;
	    if (params.cert.indexOf("-----BEGIN") != -1) {
		hCert = pemtohex(params.cert);
	    }
	    hHash = KJUR.crypto.Util.hashHex(hCert, "sha1");
	}
	return (new _DEROctetString({hex: hHash})).tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cades.OtherHashValue, KJUR.asn1.ASN1Object);

/**
 * class for RFC 5126 CAdES SignatureTimeStamp attribute<br/>
 * @name KJUR.asn1.cades.SignatureTimeStamp
 * @class class for RFC 5126 CAdES SignatureTimeStamp attribute
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.cms.Attribute
 * @since jsrsasign 4.7.0 asn1cades 1.0.0
 * @description
 * <pre>
 * id-aa-signatureTimeStampToken OBJECT IDENTIFIER ::=
 *    1.2.840.113549.1.9.16.2.14
 * SignatureTimeStampToken ::= TimeStampToken
 * </pre>
 *
 * @example
 * // by TimeStampToken hex
 * new KJUR.asn1.cades.SignatureTimeStamp({
 *   attr: "timeStampToken",
 *   tst: "3082..."})
 *
 * // by TimeStampToken or ASN1Object
 * new KJUR.asn1.cades.SignatureTimeStamp({
 *   attr: "timeStampToken",
 *   tst: new TimeStampToken(...)})
 *
 * // by TimeStampResponse hex
 * new KJUR.asn1.cades.SignatureTimeStamp({
 *   attr: "timeStampToken",
 *   res: "3082..."})
 *
 * // by TimeStampToken or ASN1Object
 * new KJUR.asn1.cades.SignatureTimeStamp({
 *   attr: "timeStampToken",
 *   res: new TimeStampResponse(...)})
 */
KJUR.asn1.cades.SignatureTimeStamp = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_isHex = _KJUR.lang.String.isHex,
	_KJUR_asn1 = _KJUR.asn1,
	_ASN1Object = _KJUR_asn1.ASN1Object,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_KJUR_asn1_cades = _KJUR_asn1.cades;

    _KJUR_asn1_cades.SignatureTimeStamp.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.16.2.14";
    this.params = null;

    this.getValueArray = function() {
	var params = this.params;

	if (params.tst != undefined) {
	    if (_isHex(params.tst)) {
		var dTST = new _ASN1Object();
		dTST.hTLV = params.tst;
		return [dTST];
	    } else if (params.tst instanceof _ASN1Object) {
		return [params.tst];
	    } else {
		throw new _Error("params.tst has wrong value");
	    }
	} else if (params.res != undefined) {
	    var hRes = params.res;
	    if (hRes instanceof _ASN1Object) {
		hRes = hRes.tohex();
	    }
	    if (typeof hRes != "string" || (! _isHex(hRes))) {
		throw new _Error("params.res has wrong value");
	    }
	    var hTST = ASN1HEX.getTLVbyList(hRes, 0, [1]);
	    var dTST = new _ASN1Object();
	    dTST.hTLV = params.tst;
	    return [dTST];
	}
    };

    if (params != null) this.setByParam(params);
};
extendClass(KJUR.asn1.cades.SignatureTimeStamp,
            KJUR.asn1.cms.Attribute);

/**
 * class for RFC 5126 CAdES CompleteCertificateRefs attribute<br/>
 * @name KJUR.asn1.cades.CompleteCertificateRefs
 * @class class for RFC 5126 CAdES CompleteCertificateRefs attribute
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.cms.Attribute
 * @since jsrsasign 4.7.0 asn1cades 1.0.0
 *
 * @description
 * <pre>
 * id-aa-ets-certificateRefs OBJECT IDENTIFIER = 
 *    1.2.840.113549.1.9.16.2.21
 * CompleteCertificateRefs ::=  SEQUENCE OF OtherCertID
 * OtherCertID ::= SEQUENCE {
 *    otherCertHash    OtherHash,
 *    issuerSerial     IssuerSerial OPTIONAL }
 * OtherHash ::= CHOICE {
 *    sha1Hash   OtherHashValue,  -- This contains a SHA-1 hash
 *    otherHash  OtherHashAlgAndValue}
 * OtherHashAlgAndValue ::= SEQUENCE {
 *    hashAlgorithm   AlgorithmIdentifier,
 *    hashValue       OtherHashValue }
 * OtherHashValue ::= OCTET STRING
 * </pre>
 *
 * @example
 * o = new KJUR.asn1.cades.CompleteCertificateRefs({
 *   array: [certPEM1,certPEM2],
 *   otherhash: true // OPTION
 * });
 */
KJUR.asn1.cades.CompleteCertificateRefs = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_cades = _KJUR_asn1.cades,
	_OtherCertID = _KJUR_asn1_cades.OtherCertID,
	_isHex = _KJUR.lang.String.isHex;

    _KJUR_asn1_cades.CompleteCertificateRefs.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.16.2.21";
    
    this.params = null;

    this.getValueArray = function() {
	var params = this.params;
	var a = [];

	for (var i = 0; i < params.array.length; i++) {
	    var pOtherCertID = params.array[i];

	    if (typeof pOtherCertID == "string") {
		if (pOtherCertID.indexOf("-----BEGIN") != -1) {
		    pOtherCertID = {cert: pOtherCertID};
		} else if (_isHex(pOtherCertID)) {
		    pOtherCertID = {hash: pOtherCertID};
		} else {
		    throw new _Error("unsupported value: " + pOtherCertID);
		}
	    }

	    if (params.alg != undefined && pOtherCertID.alg == undefined)
		pOtherCertID.alg = params.alg;

	    if (params.hasis != undefined && pOtherCertID.hasis == undefined)
		pOtherCertID.hasis = params.hasis;

	    var dOtherCertID = new _OtherCertID(pOtherCertID);
	    a.push(dOtherCertID);
	}

	var seq = new _DERSequence({array: a});
	return [seq];
    };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cades.CompleteCertificateRefs,
            KJUR.asn1.cms.Attribute);

/**
 * class for OtherCertID ASN.1 object
 * @name KJUR.asn1.cades.OtherCertID
 * @class class for OtherCertID ASN.1 object
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.7.0 asn1cades 1.0.0
 * @see KJUR.asn1.cms.IssuerSerial
 * @see KJUR.asn1.cms.ESSCertID
 * @see KJUR.asn1.cms.ESSCertIDv2
 *
 * @description
 * <pre>
 * OtherCertID ::= SEQUENCE {
 *    otherCertHash    OtherHash,
 *    issuerSerial     IssuerSerial OPTIONAL }
 * IssuerSerial ::= SEQUENCE {
 *    issuer GeneralNames,
 *    serialNumber CertificateSerialNumber }
 * OtherHash ::= CHOICE {
 *    sha1Hash   OtherHashValue,  -- This contains a SHA-1 hash
 *    otherHash  OtherHashAlgAndValue}
 * OtherHashValue ::= OCTET STRING
 * OtherHashAlgAndValue ::= SEQUENCE {
 *    hashAlgorithm   AlgorithmIdentifier,
 *    hashValue       OtherHashValue }
 * </pre>
 *
 * @example
 * new KJUR.asn1.cades.OtherCertID(certPEM)
 * new KJUR.asn1.cades.OtherCertID({cert:certPEM, hasis: false})
 */
KJUR.asn1.cades.OtherCertID = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_IssuerSerial = _KJUR_asn1_cms.IssuerSerial,
	_KJUR_asn1_cades = _KJUR_asn1.cades,
	_OtherHashValue = _KJUR_asn1_cades.OtherHashValue,
	_OtherHashAlgAndValue = _KJUR_asn1_cades.OtherHashAlgAndValue;

    _KJUR_asn1_cades.OtherCertID.superclass.constructor.call(this);

    this.params = params;

    this.tohex = function() {
	var params = this.params;

	if (typeof params == "string") {
	    if (params.indexOf("-----BEGIN") != -1) {
		params = {cert: params};
	    } else if (_isHex(params)) {
		params = {hash: params};
	    }
	}

	var a = [];

	var dOtherHash = null;
	if (params.alg != undefined) {
	    dOtherHash = new _OtherHashAlgAndValue(params);
	} else {
	    dOtherHash = new _OtherHashValue(params);
	}
	a.push(dOtherHash);

	if ((params.cert != undefined && params.hasis == true) ||
	    (params.issuer != undefined && params.serial != undefined)) {
	    var dIssuerSerial = new _IssuerSerial(params);
	    a.push(dIssuerSerial);
	}
	
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cades.OtherCertID, KJUR.asn1.ASN1Object);

/**
 * class for OtherHash ASN.1 object<br/>
 * @name KJUR.asn1.cades.OtherHash
 * @class class for OtherHash ASN.1 object
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.7.0 asn1cades 1.0.0
 * @link KJUR.asn1.cades.OtherHashAlgAndValue
 * @link KJUR.asn1.cades.OtherHashValue
 *
 * @description
 * <pre>
 * OtherHash ::= CHOICE {
 *    sha1Hash   OtherHashValue,  -- This contains a SHA-1 hash
 *    otherHash  OtherHashAlgAndValue}
 * OtherHashValue ::= OCTET STRING
 * </pre>
 *
 * @example
 * // OtherHashAlgAndValue with SHA256 by PEM or Hex Cert
 * o = new KJUR.asn1.cades.OtherHash({alg: 'sha256', cert: certPEMorHex});
 * // OtherHashAlgAndValue with SHA256 by hash value
 * o = new KJUR.asn1.cades.OtherHash({alg: 'sha256', hash: '1234'});
 * // OtherHashValue(sha1) by PEM or Hex Cert
 * o = new KJUR.asn1.cades.OtherHash({cert: certPEM});
 * // OtherHashValue(sha1) by PEM or Hex Cert
 * o = new KJUR.asn1.cades.OtherHash(certPEMStr);
 * // OtherHashValue(sha1) by hash value
 * o = new KJUR.asn1.cades.OtherHash("1234");
 */
KJUR.asn1.cades.OtherHash = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_KJUR_asn1_cades = _KJUR_asn1.cades,
	_OtherHashAlgAndValue = _KJUR_asn1_cades.OtherHashAlgAndValue,
	_OtherHashValue = _KJUR_asn1_cades.OtherHashValue,
	_hashHex = _KJUR.crypto.Util.hashHex,
	_isHex = _KJUR.lang.String.isHex;

    _KJUR_asn1_cades.OtherHash.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;

	if (typeof params == "string") {
	    if (params.indexOf("-----BEGIN") != -1) {
		params = {cert: params};
	    } else if (_isHex(params)) {
		params = {hash: params};
	    }
	}

	var dOtherHash = null;
	if (params.alg != undefined) {
	    dOtherHash = new _OtherHashAlgAndValue(params);
	} else {
	    dOtherHash = new _OtherHashValue(params);
	}
	return dOtherHash.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.cades.OtherHash, KJUR.asn1.ASN1Object);


// == BEGIN UTILITIES =====================================================

/**
 * CAdES utiliteis class
 * @name KJUR.asn1.cades.CAdESUtil
 * @class CAdES utilities class
 * @since jsrsasign 4.7.0 asn1cades 1.0.0
 */
KJUR.asn1.cades.CAdESUtil = new function() {
};

/**
 * parse CMS SignedData to add unsigned attributes
 * @name parseSignedDataForAddingUnsigned
 * @memberOf KJUR.asn1.cades.CAdESUtil
 * @function
 * @param {String} hex hexadecimal string of ContentInfo of CMS SignedData
 * @return {Object} associative array of parsed data
 * @see KJUR.asn1.cms.CMSParser#getCMSSignedData
 * @see KJUR.asn1.cms.SignedData
 *
 * @description
 * This method will parse a hexadecimal string of 
 * ContentInfo with CMS SignedData to add a attribute
 * to unsigned attributes field in a signerInfo field.
 *
 * @example
 * param = KJUR.asn1.cades.CAdESUtil.parseSignedDataForAddingUnsigned(beshex);
 * &rarr;
 * {
 *   version: 1,
 *   hashalgs: ["sha256"],
 *   econtent: ...,
 *   sinfos: [{
 *     version: 1
 *     id: ...
 *     hashalg: "sha256",
 *     sattrs: {array: [...]},
 *     sigalg: "SHA256withRSA",
 *     sighex: ...
 *   }]
 * }
 */
KJUR.asn1.cades.CAdESUtil.parseSignedDataForAddingUnsigned = function(hex) {
    var parser = new KJUR.asn1.cms.CMSParser();
    var param = parser.getCMSSignedData(hex);
    return param;
};

/**
 * parse SignerInfo to add unsigned attributes (DEPRECATED)
 * @name parseSignerInfoForAddingUnsigned
 * @memberOf KJUR.asn1.cades.CAdESUtil
 * @function
 * @param {String} hex hexadecimal string of SignerInfo
 * @return {Object} associative array of parsed data
 * @deprecated since jsrsasign 10.1.5 no more necessary becase parseSignedDataForAddingUnsigned don't call this
 *
 * @description
 * This method will parse a hexadecimal string of 
 * SignerInfo to add a attribute
 * to unsigned attributes field in a signerInfo field.
 * Parsed result will be an associative array which has
 * following properties:
 * <ul>
 * <li>version - hex TLV of version</li>
 * <li>si - hex TLV of SignerIdentifier</li>
 * <li>digalg - hex TLV of DigestAlgorithm</li>
 * <li>sattrs - hex TLV of SignedAttributes</li>
 * <li>sigalg - hex TLV of SignatureAlgorithm</li>
 * <li>sig - hex TLV of signature</li>
 * <li>sigval = hex V of signature</li>
 * <li>obj - parsed KJUR.asn1.cms.SignerInfo object</li>
 * </ul>
 * NOTE: Parsing of unsigned attributes will be provided in the
 * future version. That's way this version provides support
 * for CAdES-T and not for CAdES-C.
 */
KJUR.asn1.cades.CAdESUtil.parseSignerInfoForAddingUnsigned = function(hex, iSI, nth) {
    var _ASN1HEX = ASN1HEX,
	_getChildIdx = _ASN1HEX.getChildIdx,
	_getTLV = _ASN1HEX.getTLV,
	_getV = _ASN1HEX.getV,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_ASN1Object = _KJUR_asn1.ASN1Object,
	_KJUR_asn1_cms = _KJUR_asn1.cms,
	_AttributeList = _KJUR_asn1_cms.AttributeList,
	_SignerInfo = _KJUR_asn1_cms.SignerInfo;

    var r = {};
    var aSIChildIdx = _getChildIdx(hex, iSI);
    //alert(aSIChildIdx.join("="));

    if (aSIChildIdx.length != 6)
        throw "not supported items for SignerInfo (!=6)"; 

    // 1. SignerInfo.CMSVersion
    var iVersion = aSIChildIdx.shift();
    r.version = _getTLV(hex, iVersion);

    // 2. SignerIdentifier(IssuerAndSerialNumber)
    var iIdentifier = aSIChildIdx.shift();
    r.si = _getTLV(hex, iIdentifier);

    // 3. DigestAlgorithm
    var iDigestAlg = aSIChildIdx.shift();
    r.digalg = _getTLV(hex, iDigestAlg);

    // 4. SignedAttrs
    var iSignedAttrs = aSIChildIdx.shift();
    r.sattrs = _getTLV(hex, iSignedAttrs);

    // 5. SigAlg
    var iSigAlg = aSIChildIdx.shift();
    r.sigalg = _getTLV(hex, iSigAlg);

    // 6. Signature
    var iSig = aSIChildIdx.shift();
    r.sig = _getTLV(hex, iSig);
    r.sigval = _getV(hex, iSig);

    // 7. obj(SignerInfo)
    var tmp = null;
    r.obj = new _SignerInfo();

    tmp = new _ASN1Object();
    tmp.hTLV = r.version;
    r.obj.dCMSVersion = tmp;

    tmp = new _ASN1Object();
    tmp.hTLV = r.si;
    r.obj.dSignerIdentifier = tmp;

    tmp = new _ASN1Object();
    tmp.hTLV = r.digalg;
    r.obj.dDigestAlgorithm = tmp;

    tmp = new _ASN1Object();
    tmp.hTLV = r.sattrs;
    r.obj.dSignedAttrs = tmp;

    tmp = new _ASN1Object();
    tmp.hTLV = r.sigalg;
    r.obj.dSigAlg = tmp;

    tmp = new _ASN1Object();
    tmp.hTLV = r.sig;
    r.obj.dSig = tmp;

    r.obj.dUnsignedAttrs = new _AttributeList();

    return r;
};


/* asn1csr-2.0.7.js (c) 2015-2022 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * asn1csr.js - ASN.1 DER encoder classes for PKCS#10 CSR
 *
 * Copyright (c) 2015-2022 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name asn1csr-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.5.27 asn1csr 2.0.7 (2022-Aug-19)
 * @since jsrsasign 4.9.0
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * kjur's ASN.1 class for CSR/PKCS#10 name space
 * <p>
 * This name space is a sub name space for {@link KJUR.asn1}.
 * This name space contains classes for
 * <a href="https://tools.ietf.org/html/rfc2986">RFC 2986</a>
 * certificate signing request(CSR/PKCS#10) and its utilities
 * to be issued your certificate from certification authorities.
 * <h4>PROVIDING ASN.1 STRUCTURES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.csr.CertificationRequest}</li>
 * <li>{@link KJUR.asn1.csr.CertificationRequestInfo}</li>
 * </ul>
 * <h4>PROVIDING UTILITY CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.csr.CSRUtil}</li>
 * </ul>
 * </p>
 * @name KJUR.asn1.csr
 * @namespace
 */
if (typeof KJUR.asn1.csr == "undefined" || !KJUR.asn1.csr) KJUR.asn1.csr = {};

/**
 * ASN.1 CertificationRequest structure class
 * @name KJUR.asn1.csr.CertificationRequest
 * @class ASN.1 CertificationRequest structure class
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.9.0 asn1csr 1.0.0
 * @see KJUR.asn1.csr.CertificationRequestInfo
 * @description
 * This class provides CertificateRequestInfo ASN.1 structure
 * defined in 
 * <a href="https://tools.ietf.org/html/rfc2986#page-5">
 * RFC 2986 4.2</a>.
 * <pre>
 * CertificationRequest ::= SEQUENCE {
 *   certificationRequestInfo CertificationRequestInfo,
 *   signatureAlgorithm       AlgorithmIdentifier{{ SignatureAlgorithms }},
 *   signature                BIT STRING }
 * CertificationRequestInfo ::= SEQUENCE {
 *   version       INTEGER { v1(0) } (v1,...),
 *   subject       Name,
 *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
 *   attributes    [0] Attributes{{ CRIAttributes }} }
 * </pre>
 *
 * Argument "params" JSON object can have following keys:
 * <ul>
 * <li>{Array}subject - parameter to be passed to {@link KJUR.asn1.x509.X500Name}</li>
 * <li>{Object}sbjpubkey - PEM string or key object to be passed to {@link KEYUTIL.getKey}</li>
 * <li>{Array}extreq - array of certificate extension parameters</li>
 * <li>{String}sigalg - signature algorithm name (ex. SHA256withRSA)</li>
 * <li>{Object}sbjprvkey - PEM string or key object to be passed to {@link KEYUTIL.getKey} 
 * (OPTION)</li>
 * <li>{String}sighex - hexadecimal string of signature value. 
 * When this is not defined and
 * sbjprvkey is specified, sighex will be set automatically
 * during getEncodedHex() is called. (OPTION)</li>
 * </ul>
 *
 * <br/>
 * CAUTION: 
 * Argument "params" JSON value format have been changed without 
 * backward compatibility since jsrsasign 9.0.0 asn1csr 2.0.0.
 *
 * @example
 * // sign by private key
 * csr = new KJUR.asn1.csr.CertificationRequest({
 *   subject: {str:"/C=US/O=Test"},
 *   sbjpubkey: "-----BEGIN PUBLIC KEY...",
 *   extreq: [{extname:"subjectAltName",array:[{dns:"example.com"}]}]
 *   sigalg: "SHA256withRSA",
 *   sbjprvkey: "-----BEGIN PRIVATE KEY..."
 * });
 * pem = csr.getPEM(); // signed with sbjprvkey automatically
 *
 * // or specifying signature value
 * csr = new KJUR.asn1.csr.CertificationRequest({
 *   subject: {str:"/C=US/O=Test"},
 *   sbjpubkey: "-----BEGIN PUBLIC KEY...",
 *   extreq: [{extname:"subjectAltName",array:[{dns:"example.com"}]}]
 *   sigalg: "SHA256withRSA",
 *   sighex: "1234abcd..."
 * });
 * pem = csr.getPEM();
 */
KJUR.asn1.csr.CertificationRequest = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERBitString = _KJUR_asn1.DERBitString,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_csr = _KJUR_asn1.csr,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_CertificationRequestInfo = _KJUR_asn1_csr.CertificationRequestInfo;

    _KJUR_asn1_csr.CertificationRequest.superclass.constructor.call(this);

    /**
     * set parameter<br/>
     * @name setByParam
     * @memberOf KJUR.asn1.csr.CertificationRequest#
     * @function
     * @param params {Array} JSON object of CSR parameters
     * @since jsrsasign 9.0.0 asn1csr 2.0.0
     * @description
     * This method will set parameter to this object.
     * @example
     * csr = new KJUR.asn1.x509.CertificationRequest();
     * csr.setByParam({
     *   subject: {str: "/C=JP/O=Test"},
     *   ...
     * });
     */
    this.setByParam = function(params) {
	this.params = params;
    };

    /**
     * sign CertificationRequest and set signature value internally<br/>
     * @name sign
     * @memberOf KJUR.asn1.csr.CertificationRequest#
     * @function
     * @description
     * This method self-signs CertificateRequestInfo with a subject's
     * private key and set signature value internally.
     * <br/>
     * @example
     * csr = new KJUR.asn1.csr.CertificationRequest({
     *   subject: "/C=JP/O=Test",
     *   sbjpubkey: ...
     * });
     * csr.sign();
     */
    this.sign = function() {
	var hCSRI = 
	    (new _CertificationRequestInfo(this.params)).tohex();
	var sig = new KJUR.crypto.Signature({alg: this.params.sigalg});
	sig.init(this.params.sbjprvkey);
	sig.updateHex(hCSRI);
	var sighex = sig.sign();
	this.params.sighex = sighex;
    };

    /**
     * get PEM formatted certificate signing request (CSR/PKCS#10)<br/>
     * @name getPEM
     * @memberOf KJUR.asn1.csr.CertificationRequest#
     * @function
     * @return PEM formatted string of CSR/PKCS#10
     * @description
     * This method is to a get CSR PEM string
     * <br/>
     * @example
     * csr = new KJUR.asn1.csr.CertificationRequest({
     *   subject: "/C=JP/O=Test",
     *   sbjpubkey: ...
     * });
     * csr.getPEM() &rarr; "-----BEGIN CERTIFICATE REQUEST..."
     */
    this.getPEM = function() {
	return hextopem(this.tohex(), "CERTIFICATE REQUEST");
    };

    this.tohex = function() {
	var params = this.params;
	var csri = new KJUR.asn1.csr.CertificationRequestInfo(this.params);
	var algid = 
	    new KJUR.asn1.x509.AlgorithmIdentifier({name: params.sigalg});

	if (params.sighex == undefined && params.sbjprvkey != undefined) {
	    this.sign();
	}

	if (params.sighex == undefined) {
	    throw new Error("sighex or sbjprvkey parameter not defined");
	}

	var asn1Sig = new _DERBitString({hex: "00" + params.sighex});
	
	var seq = new _DERSequence({array: [csri, algid, asn1Sig]});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.csr.CertificationRequest, KJUR.asn1.ASN1Object);

/**
 * ASN.1 CertificationRequestInfo structure class
 * @name KJUR.asn1.csr.CertificationRequestInfo
 * @class ASN.1 CertificationRequestInfo structure class
 * @param {Array} params associative array of parameters (ex. {})
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 4.9.0 asn1csr 1.0.0
 * @see KJUR.asn1.csr.CertificationRequest
 * @see KJUR.asn1.x509.Extensions
 * @description
 * This class provides CertificateRequestInfo ASN.1 structure
 * defined in 
 * <a href="https://tools.ietf.org/html/rfc2986#page-5">
 * RFC 2986 4.1</a>.
 * <pre>
 * CertificationRequestInfo ::= SEQUENCE {
 *   version       INTEGER { v1(0) } (v1,...),
 *   subject       Name,
 *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
 *   attributes    [0] Attributes {{ CRIAttributes }} }
 * </pre>
 * <br/>
 * <br/>
 * NOTE1: 
 * Argument "params" JSON value format have been changed without 
 * backward compatibility since jsrsasign 9.0.0 asn1csr 2.0.0.<br/>
 * NOTE2:
 * From jsrsasign 10.5.27, "attrs" member in the constructor argument
 * object have been supported to support more Attributes type.
 * Currently following Attribute types are supported:
 * <ul>
 * <li>challengePassword</li>
 * <li>unstructuredName - member "names" will be array of 
 * DirectoryStrings. (ex. [{prnstr: "aaa"},{utf8str: "bbb"}]</li>
 * <li>extensionRequest - any {@link KJUR.asn1.x509.Extensions} 
 * constructor argument can be specified for "ext" member value.</li>
 * </ul>
 *
 * @example
 * csri = new KJUR.asn1.csr.CertificationRequestInfo({
 *   subject: {str: '/C=US/CN=b'},
 *   sbjpubkey: <<PUBLIC KEY PEM>>,
 *   extreq: [
 *     {extname:"subjectAltName", array:[{dns:"example.com"}]}
 *   ]});
 * csri.tohex() &rarr; "30..."
 *
 * // From jsrsasign 10.5.27, "attrs" supported
 * csri = new KJUR.asn1.csr.CertificationRequestInfo({
 *   subject: {str: '/C=US/CN=b'},
 *   sbjpubkey: <<PUBLIC KEY PEM>>,
 *   attrs: [
 *     {attr: "challengePassword", password: "secret"},
 *     {attr: "unstructuredName", names: [{utf8str:"aaa"},{ia5str:"bbb"}]},
 *     {attr: "extensionRequest", ext: [
 *       {extname: "basicConstraints", cA: true},
 *       {extname: "subjectKeyIdentifier", kid: "1a2b..."}
 *     ]}
 *   ]});
 * csri.tohex() &rarr; "30..."
 */
KJUR.asn1.csr.CertificationRequestInfo = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERBitString = _KJUR_asn1.DERBitString,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERUTF8String = _KJUR_asn1.DERUTF8String,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_newObject = _KJUR_asn1.ASN1Util.newObject,
	_KJUR_asn1_csr = _KJUR_asn1.csr,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_X500Name = _KJUR_asn1_x509.X500Name,
	_Extensions = _KJUR_asn1_x509.Extensions,
	_SubjectPublicKeyInfo = _KJUR_asn1_x509.SubjectPublicKeyInfo,
	_AttributeList = _KJUR_asn1_csr.AttributeList;
    
    _KJUR_asn1_csr.CertificationRequestInfo.superclass.constructor.call(this);

    this.params = null;

    this.setByParam = function(params) {
	if (params != undefined) this.params = params;
    };

    this.tohex = function() {
	var params = this.params;
	var a = [];
	a.push(new _DERInteger({'int': 0})); // version
	a.push(new _X500Name(params.subject));
	a.push(new _SubjectPublicKeyInfo(KEYUTIL.getKey(params.sbjpubkey)));
	if (params.attrs != undefined) {
	    var asn1Param = _conv(params.attrs);
	    var tagobj = _newObject({tag: {tage: "a0", obj: asn1Param}});
	    a.push(tagobj);
	} else if (params.extreq != undefined) {
	    var extseq = new _Extensions(params.extreq);
	    var tagobj = _newObject({
		tag: {
		    tage:'a0',
		    obj:{seq: [{oid: "1.2.840.113549.1.9.14"},
			       {set: [extseq]}]}
		}
	    });
	    a.push(tagobj);
	} else {
	    a.push(new _DERTaggedObject({tag:"a0",
					 explicit:false,
					 obj:new _DERUTF8String({str:''})}));
	}
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    /*
     * converter from attrs member value to newObject acceptable data
     */
    function _conv(aAttrParam) {
	var _Error = Error,
	    _Extensions = KJUR.asn1.x509.Extensions;
	var a = [];
	for (var i = 0; i < aAttrParam.length; i++) {
	    var pAttr = aAttrParam[i];
	    var attrName = pAttr.attr;
	    if (attrName == "extensionRequest") {
		var oExt = new _Extensions(pAttr.ext);
		var p = {seq: [{oid: "1.2.840.113549.1.9.14"},{set: [oExt]}]};
		a.push(p);
	    } else if (attrName == "unstructuredName") {
		var p = {seq: [{oid: "1.2.840.113549.1.9.2"},{set: pAttr.names}]};
		a.push(p);
	    } else if (attrName == "challengePassword") {
		var p = {seq: [{oid: "1.2.840.113549.1.9.7"},
			       {set: [{utf8str: pAttr.password}]}]};
		a.push(p);
	    } else {
		throw new _Error("unknown CSR attribute");
	    }
	}
	return {set: a};
    }

    if (params != undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.csr.CertificationRequestInfo, KJUR.asn1.ASN1Object);

KJUR.asn1.csr.AttributeList = function(aParam) {
    function _paramToASN1Param(aParam) {
    }
};
extendClass(KJUR.asn1.csr.AttributeList, KJUR.asn1.ASN1Object);


/**
 * Certification Request (CSR/PKCS#10) utilities class<br/>
 * @name KJUR.asn1.csr.CSRUtil
 * @class Certification Request (CSR/PKCS#10) utilities class
 * @description
 * This class provides utility static methods for CSR/PKCS#10.
 * Here is a list of methods:
 * <ul>
 * <li>{@link KJUR.asn1.csr.CSRUtil.newCSRPEM} (DEPRECATED)</li>
 * <li>{@link KJUR.asn1.csr.CSRUtil.getParam}</li>
 * </ul>
 * <br/>
 */
KJUR.asn1.csr.CSRUtil = new function() {
};

/**
 * generate a PEM format of CSR/PKCS#10 certificate signing request (DEPRECATED)<br/>
 * @name newCSRPEM
 * @memberOf KJUR.asn1.csr.CSRUtil
 * @function
 * @param {Array} param parameter to generate CSR
 * @since jsrsasign 4.9.0 asn1csr 1.0.0
 * @deprecated since jsrsasign 9.0.0 asn1csr 2.0.0. please use {@link KJUR.asn1.csr.CertificationRequest} constructor.
 * @description
 * This method can generate a CSR certificate signing.
 * 
 * @example
 * // 1) by key object
 * pem = KJUR.asn1.csr.CSRUtil.newCSRPEM({
 *   subject: {str: '/C=US/O=Test/CN=example.com'},
 *   sbjpubkey: pubKeyObj,
 *   sigalg: "SHA256withRSA",
 *   sbjprvkey: prvKeyObj,
 *   extreq: [{
 *     extname: "subjectAltName",
 *     array: [{dns:"example.com"}]
 *   }]
 * });
 *
 * // 2) by private/public key PEM 
 * pem = KJUR.asn1.csr.CSRUtil.newCSRPEM({
 *   subject: {str: '/C=US/O=Test/CN=example.com'},
 *   sbjpubkey: pubKeyPEM,
 *   sigalg: "SHA256withRSA",
 *   sbjprvkey: prvKeyPEM
 * });
 *
 * // 3) with generateKeypair
 * kp = KEYUTIL.generateKeypair("RSA", 2048);
 * pem = KJUR.asn1.csr.CSRUtil.newCSRPEM({
 *   subject: {str: '/C=US/O=Test/CN=example.com'},
 *   sbjpubkey: kp.pubKeyObj,
 *   sigalg: "SHA256withRSA",
 *   sbjprvkey: kp.prvKeyObj
 * });
 *
 * // 4) by private/public key PEM with extension
 * pem = KJUR.asn1.csr.CSRUtil.newCSRPEM({
 *   subject: {str: '/C=US/O=Test/CN=example.com'},
 *   ext: [
 *     {subjectAltName: {array: [{dns: 'example.net'}]}}
 *   ],
 *   sbjpubkey: pubKeyPEM,
 *   sigalg: "SHA256withRSA",
 *   sbjprvkey: prvKeyPEM
 * });
 */
KJUR.asn1.csr.CSRUtil.newCSRPEM = function(param) {
    var _KEYUTIL = KEYUTIL,
	_KJUR_asn1_csr = KJUR.asn1.csr;

    var csr = new _KJUR_asn1_csr.CertificationRequest(param);
    var pem = csr.getPEM();
    return pem;
};

/**
 * get field values from CSR/PKCS#10 PEM string<br/>
 * @name getParam
 * @memberOf KJUR.asn1.csr.CSRUtil
 * @function
 * @param {string} sPEM PEM string of CSR/PKCS#10
 * @param {boolean} flagTBS result object also concludes CertificationRequestInfo (OPTION, DEFAULT=false)
 * @returns {Array} JSON object with parsed parameters such as name or public key
 * @since jsrsasign 9.0.0 asn1csr 2.0.0
 * @see KJUR.asn1.csr.CertificationRequest
 * @see KJUR.asn1.csr.CertificationRequestInfo
 * @see KJUR.asn1.x509.X500Name
 * @see X509#getExtParamArray
 * @description
 * This method parses PEM CSR/PKCS#1 string and retrieves
 * fields such as subject name and public key. 
 * Following parameters are available in the
 * resulted JSON object.
 * <ul>
 * <li>{X500Name}subject - subject name parameters </li>
 * <li>{String}sbjpubkey - PEM string of subject public key</li>
 * <li>{Array}extreq - array of extensionRequest parameters</li>
 * <li>{String}sigalg - name of signature algorithm field</li>
 * <li>{String}sighex - hexadecimal string of signature value</li>
 * <li>{String}tbs - a hexadecimal string of CertificationRequestInfo as to be signed(OPTION)</li>
 * </ul>
 * Returned JSON object can be passed to 
 * {@link KJUR.asn1.csr.CertificationRequest} class constructor.
 * <br/>
 * CAUTION: 
 * Returned JSON value format have been changed without 
 * backward compatibility since jsrsasign 9.0.0 asn1csr 2.0.0.
 * <br/>
 * NOTE:
 * The "flagTBS" supported since jsrsasign 10.5.26.
 *
 * @example
 * KJUR.asn1.csr.CSRUtil.getParam("-----BEGIN CERTIFICATE REQUEST...") &rarr;
 * {
 *   subject: { array:[[{type:"C",value:"JP",ds:"prn"}],...],
 *              str: "/C=JP/O=Test"},
 *   sbjpubkey: "-----BEGIN PUBLIC KEY...",
 *   extreq: [{extname:"subjectAltName",array:[{dns:"example.com"}]}]
 *   sigalg: "SHA256withRSA",
 *   sighex: "1ab3df.."
 * }
 *
 * KJUR.asn1.csr.CSRUtil.getParam("-----BEGIN CERTIFICATE REQUEST...", true) &rarr;
 * result will also have a member "tbs" in the object.
 */
KJUR.asn1.csr.CSRUtil.getParam = function(sPEM, flagTBS) {
    var _ASN1HEX = ASN1HEX,
	_getV = _ASN1HEX.getV,
	_getIdxbyList = _ASN1HEX.getIdxbyList,
	_getTLVbyList = _ASN1HEX.getTLVbyList,
	_getTLVbyListEx = _ASN1HEX.getTLVbyListEx,
	_getVbyListEx = _ASN1HEX.getVbyListEx;

    /*
     * get a hexadecimal string of sequence of extension request attribute value
     * @param {String} h hexadecimal string of whole CSR
     * @return {String} hexadecimal string of SEQUENCE of extension request attribute value
     */
    var _getExtReqSeqHex = function(h) {
	var idx1 = _getIdxbyList(h, 0, [0, 3, 0, 0], "06"); // extreq attr OID idx
	if (_getV(h, idx1) != "2a864886f70d01090e") {
	    return null;
	}

	return _getTLVbyList(h, 0, [0, 3, 0, 1, 0], "30"); // ext seq idx
    };

    var result = {};

    if (sPEM.indexOf("-----BEGIN CERTIFICATE REQUEST") == -1)
	throw new Error("argument is not PEM file");

    var hex = pemtohex(sPEM, "CERTIFICATE REQUEST");

    if (flagTBS) {
	result.tbs = _getTLVbyList(hex, 0, [0]);
    }

    try {
	var hSubject = _getTLVbyListEx(hex, 0, [0, 1]);
	if (hSubject == "3000") {
	    result.subject = {};
	} else {
	    var x = new X509();
	    result.subject = x.getX500Name(hSubject);
	}
    } catch (ex) {};

    var hPubKey = _getTLVbyListEx(hex, 0, [0, 2]);
    var pubkeyobj = KEYUTIL.getKey(hPubKey, null, "pkcs8pub");
    result.sbjpubkey = KEYUTIL.getPEM(pubkeyobj, "PKCS8PUB");

    var hExtReqSeq = _getExtReqSeqHex(hex);
    var x = new X509();
    if (hExtReqSeq != null) {
	result.extreq = x.getExtParamArray(hExtReqSeq);
    }

    try {
	var hSigAlg = _getTLVbyListEx(hex, 0, [1], "30");
	var x = new X509();
	result.sigalg = x.getAlgorithmIdentifierName(hSigAlg);
    } catch (ex) {};

    try {
	var hSig = _getVbyListEx(hex, 0, [2]);
	result.sighex = hSig;
    } catch (ex) {};

    return result;
};

/**
 * verify self-signed CSR/PKCS#10 signature<br/>
 * @name verifySignature
 * @memberOf KJUR.asn1.csr.CSRUtil
 * @function
 * @param {object} csr PEM CSR string or parsed JSON object of CSR
 * @returns {boolean} true if self-signed signature is valid otherwise false
 * @since jsrsasign 10.5.26 asn1csr 2.0.6
 * @see KJUR.asn1.csr.CertificationRequest
 * @see KJUR.asn1.csr.CertificationRequestInfo
 * @see KJUR.asn1.csr.CSRUtil#getParam
 * @description
 * This method verifies self-signed signature of CSR/PKCS#10
 * with its public key which is concluded in the CSR.
 *
 * @example
 * KJUR.asn1.csr.CSRUtil.verifySignatrue("-----BEGIN CERTIFICATE REQUEST...") &rarr; true or false
 * 
 * p = KJUR.asn1.csr.CSRUtil.getParam("-----BEGIN CERTIFICATE REQUEST-----", true); // with tbs
 * KJUR.asn1.csr.CSRUtil.verifySignatrue(p) &rarr; true or false
 */
KJUR.asn1.csr.CSRUtil.verifySignature = function(csr) {
    try {
	var pCSR = null;
	if (typeof csr == "string" &&
	    csr.indexOf("-----BEGIN CERTIFICATE REQUEST") != -1) {
	    pCSR = KJUR.asn1.csr.CSRUtil.getParam(csr, true);
	} else if (typeof csr == "object" &&
		   csr.sbjpubkey != undefined &&
		   csr.sigalg != undefined &&
		   csr.sighex != undefined &&
		   csr.tbs != undefined) {
	    pCSR = csr;
	}
	if (pCSR == null) return false;

	// verify self-signed signature
	var sig = new KJUR.crypto.Signature({alg: pCSR.sigalg});
	sig.init(pCSR.sbjpubkey);
	sig.updateHex(pCSR.tbs);
	return sig.verify(pCSR.sighex);
    } catch(ex) {
	alert(ex);
	return false;
    }
};



/* asn1ocsp-1.1.8.js (c) 2016-2022 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * asn1ocsp.js - ASN.1 DER encoder classes for OCSP protocol
 *
 * Copyright (c) 2016-2021 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name asn1ocsp-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.5.20 asn1ocsp 1.1.8 (2022-Apr-25)
 * @since jsrsasign 6.1.0
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};

/**
 * ASN.1 classes for OCSP protocol<br/>
 * <p>
 * This name space provides 
 * <a href="https://tools.ietf.org/html/rfc6960">RFC 6960
 * Online Certificate Status Protocol (OCSP)</a> ASN.1 request and response generator.
 *
 * <h4>FEATURES</h4>
 * <ul>
 * <li>easily generate OCSP data by JSON object</li>
 * </ul>
 * 
 * <h4>OCSP Response Encoder Classes</h4>
 * <ul>
 * <li>{@link KJUR.asn1.ocsp.OCSPResponse}</li>
 * <li>{@link KJUR.asn1.ocsp.ResponseBytes}</li>
 * <li>{@link KJUR.asn1.ocsp.BasicOCSPResponse}</li>
 * <li>{@link KJUR.asn1.ocsp.ResponseData}</li>
 * <li>{@link KJUR.asn1.ocsp.ResponderID}</li>
 * <li>{@link KJUR.asn1.ocsp.SingleResponseList}</li>
 * <li>{@link KJUR.asn1.ocsp.SingleResponse}</li>
 * <li>{@link KJUR.asn1.ocsp.CertID}</li>
 * <li>{@link KJUR.asn1.ocsp.CertStatus}</li>
 * </ul>
 *
 * <h4>OCSP Request Encoder Classes</h4>
 * <ul>
 * <li>{@link KJUR.asn1.ocsp.OCSPRequest}</li>
 * <li>{@link KJUR.asn1.ocsp.TBSRequest}</li>
 * <li>{@link KJUR.asn1.ocsp.Request}</li>
 * <li>{@link KJUR.asn1.ocsp.CertID}</li>
 * </ul>
 *
 * <h4>OCSP Utility classes</h4>
 * <ul>
 * <li>{@link KJUR.asn1.ocsp.OCSPUtil} - simple request parser</li>
 * <li>{@link KJUR.asn1.ocsp.OCSPParser} - request parser</li>
 * </ul>
 * </p>
 * @name KJUR.asn1.ocsp
 * @namespace
 */
if (typeof KJUR.asn1.ocsp == "undefined" || !KJUR.asn1.ocsp) KJUR.asn1.ocsp = {};

KJUR.asn1.ocsp.DEFAULT_HASH = "sha1";

/**
 * OCSPResponse ASN.1 class encoder<br/>
 * @name KJUR.asn1.ocsp.OCSPResponse
 * @class OCSPResponse ASN.1 class encoder
 * @param {Array} params JSON object of constructor parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
 * @see KJUR.asn1.ocsp.ResponseBytes
 *
 * @description
 * OCSPResponse ASN.1 class is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
 * <pre>
 * OCSPResponse ::= SEQUENCE {
 *    responseStatus         OCSPResponseStatus,
 *    responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }
 * OCSPResponseStatus ::= ENUMERATED {
 *     successful            (0),  -- Response has valid confirmations
 *     malformedRequest      (1),  -- Illegal confirmation request
 *     internalError         (2),  -- Internal error in issuer
 *     tryLater              (3),  -- Try again later
 *                                 -- (4) is not used
 *     sigRequired           (5),  -- Must sign the request
 *     unauthorized          (6)   -- Request unauthorized
 * } 
 * </pre>
 * This constructor accepts all parameter of
 * {@link KJUR.asn1.ocsp.ResponseBytes} for "successful" response.
 * Further more following property is needed:
 * <ul>
 * <li>{Number or String}resstats - responseStatus value by
 * a number or name. (ex. 2, "internalError")</li>
 * </ul>
 *
 * @example
 * // default constructor for "successful"
 * o = new KJUR.asn1.ocsp.OCSPResponse({
 *   resstatus: "successful",
 *   <<ResponseBytes parameters>>
 * });
 * // constructor for error
 * new KJUR.asn1.ocsp.OCSPResponse({resstatus: 1})
 * new KJUR.asn1.ocsp.OCSPResponse({resstatus: "unauthorized"})
 */
KJUR.asn1.ocsp.OCSPResponse = function(params) {
    KJUR.asn1.ocsp.OCSPResponse.superclass.constructor.call(this);

    var _DEREnumerated = KJUR.asn1.DEREnumerated,
	_newObject = KJUR.asn1.ASN1Util.newObject,
	_ResponseBytes = KJUR.asn1.ocsp.ResponseBytes;

    var _aSTATUSNAME = ["successful", "malformedRequest", "internalError",
			"tryLater", "_not_used_", "sigRequired", "unauthorized"]; 

    this.params = null;

    this._getStatusCode = function() {
	var code = this.params.resstatus;
	if (typeof code == "number") return code;
	if (typeof code != "string") return -1;
	return _aSTATUSNAME.indexOf(code);
    };

    this.setByParam = function(params) {
	this.params = params;
    };

    this.tohex = function() {
	var params = this.params;

	var code = this._getStatusCode();
	if (code == -1) {
	    throw new Error("responseStatus not supported: " +
			    params.resstatus);
	}

	if (code != 0) {
	    return _newObject({seq: [{'enum': {'int': code}}]}).tohex();
	}
	
	var dResBytes = new _ResponseBytes(params);
	return _newObject({seq: [
	    {'enum': {'int': 0}},
	    {tag: {tag: "a0", explicit: true, obj: dResBytes}}
	]}).tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.ocsp.OCSPResponse, KJUR.asn1.ASN1Object);

/**
 * ResponseBytes ASN.1 class encoder<br/>
 * @name KJUR.asn1.ocsp.ResponseBytes
 * @class ResponseBytes ASN.1 class encoder
 * @param {Array} params JSON object of constructor parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
 * @see KJUR.asn1.ocsp.OCSPResponse
 * @see KJUR.asn1.ocsp.BasicOCSPResponse
 *
 * @description
 * OCSPResponse ASN.1 class is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
 * <pre>
 * ResponseBytes ::=       SEQUENCE {
 *     responseType   OBJECT IDENTIFIER,
 *     response       OCTET STRING }
 * id-pkix-ocsp           OBJECT IDENTIFIER ::= { id-ad-ocsp }
 * id-pkix-ocsp-basic     OBJECT IDENTIFIER ::= { id-pkix-ocsp 1 }
 * </pre>
 * This constructor accepts all parameter of
 * {@link KJUR.asn1.ocsp.BasicOCSPResponse}.
 * Further more following property is needed:
 * <ul>
 * <li>{String}restype - only "ocspBasic" can be available</li>
 * </ul>
 *
 * @example
 * o = new KJUR.asn1.ocsp.ResponseBytes({
 *   restype: "ocspBasic",
 *   // BasicOCSPResponse properties shall be specified
 * });
 */
KJUR.asn1.ocsp.ResponseBytes = function(params) {
    KJUR.asn1.ocsp.ResponseBytes.superclass.constructor.call(this);

    var _KJUR_asn1 = KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_BasicOCSPResponse = _KJUR_asn1.ocsp.BasicOCSPResponse;

    this.params = null;

    this.setByParam = function(params) {
	this.params = params;
    };

    this.tohex = function() {
	var params = this.params;

	if (params.restype != "ocspBasic") {
	    throw new Error("not supported responseType: " + params.restype);
	}

	var dBasic = new _BasicOCSPResponse(params);

	var a = [];
	a.push(new _DERObjectIdentifier({name: "ocspBasic"}));
	a.push(new _DEROctetString({hex: dBasic.tohex()}));

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.ocsp.ResponseBytes, KJUR.asn1.ASN1Object);

/**
 * BasicOCSPResponse ASN.1 class encoder<br/>
 * @name KJUR.asn1.ocsp.BasicOCSPResponse
 * @class BasicOCSPResponse ASN.1 class encoder
 * @param {Array} params JSON object of constructor parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
 * @see KJUR.asn1.ocsp.OCSPResponse
 * @see KJUR.asn1.ocsp.ResponseBytes
 * @see KJUR.asn1.ocsp.BasicOCSPResponse
 * @see KJUR.asn1.ocsp.ResponseData
 *
 * @description
 * OCSPResponse ASN.1 class is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
 * <pre>
 * BasicOCSPResponse       ::= SEQUENCE {
 *    tbsResponseData      ResponseData,
 *    signatureAlgorithm   AlgorithmIdentifier,
 *    signature            BIT STRING,
 *    certs            [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }
 * </pre>
 * This constructor accepts all parameter of
 * {@link KJUR.asn1.ocsp.ResponseData}.
 * Further more following properties are available:
 * <ul>
 * <li>{ASN1Object}tbsresp (OPTION) - {@link KJUR.asn1.ASN1Object} or its
 * sub class object for tbsReponseData,
 * genelally {@link KJUR.asn1.ocsp.ResponseData}.
 * When "tbsresp" not specified, tbsresp will be set by
 * other parameters internally.</li>
 * <li>{String}sigalg - signatureAlgrithm name (ex. "SHA256withRSA")</li>
 * <li>{Object}reskey (OPTION) - specifies OCSP response signing private key.
 * Parameter "reskey" or "sighex" shall be specified.
 * Following values can be specified:
 *   <ul>
 *   <li>PKCS#1/5 or PKCS#8 PEM string of private key</li>
 *   <li>RSAKey/DSA/ECDSA key object. {@link KEYUTIL.getKey} is useful
 *   to generate a key object.</li>
 *   </ul>
 * </li>
 * <li>{String}sighex (OPTION) - hexadecimal string of signature value
 * (i.e. ASN.1 value(V) of signatureValue BIT STRING without
 * unused bits)</li>
 * <li>{Array}certs (OPTION) - array of PEM or hexadecimal string of
 * certificate such as OCSP responder certificate</li>
 * </ul>
 *
 * @example
 * // response data will be signed by "reskey"
 * new KJUR.asn1.ocsp.BasicOCSPResponse({
 *   ...<<ResponseData properties...>>...
 *   sigalg: "SHA256withRSA",
 *   reskey: <<OCSP Responder private key PEM or object>>,
 *   certs: [<<PEMorHEXstringOfCert1>>,...] });
 *
 * // explicitly specify "signature" by "sighex"
 * new KJUR.asn1.ocsp.BasicOCSPResponse({
 *   ...<<ResponseData properties...>>...
 *   sigalg: "SHA256withRSA",
 *   sighex: "12abcd...",
 *   certs: [<<PEMorHEXstringOfCert1>>,...] });
 * 
 * // explicitly specify "tbsResponseData" and sign
 * new KJUR.asn1.ocsp.BasicOCSPResponse({
 * { tbsresp: <<subclass of ASN1Object>>,
 *   sigalg: "SHA256withRSA",
 *   reskey: <<OCSP Responder private key PEM or object>>,
 *   certs: [<<PEMorHEXstringOfCert1>>,...] }
 */
KJUR.asn1.ocsp.BasicOCSPResponse = function(params) {
    KJUR.asn1.ocsp.BasicOCSPResponse.superclass.constructor.call(this);

    var _Error = Error,
	_KJUR_asn1 = KJUR.asn1,
	_ASN1Object = _KJUR_asn1.ASN1Object,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_DERBitString = _KJUR_asn1.DERBitString,
	_Extensions = _KJUR_asn1.x509.Extensions,
	_AlgorithmIdentifier = _KJUR_asn1.x509.AlgorithmIdentifier,
	_KJUR_asn1_ocsp = _KJUR_asn1.ocsp,
	_ResponderID = _KJUR_asn1_ocsp.ResponderID;
	_SingleResponseList = _KJUR_asn1_ocsp.SingleResponseList,
	_ResponseData = _KJUR_asn1_ocsp.ResponseData;

    this.params = null;

    this.setByParam = function(params) {
	this.params = params;
    };

    this.sign = function() {
	var params = this.params;
	var hTBS = params.tbsresp.tohex();
	var sig = new KJUR.crypto.Signature({alg: params.sigalg});
	sig.init(params.reskey);
	sig.updateHex(hTBS);
	params.sighex = sig.sign();
    };

    this.tohex = function() {
	var params = this.params;

	if (params.tbsresp == undefined) {
	    params.tbsresp = new _ResponseData(params);
	}

	if (params.sighex == undefined && params.reskey != undefined) {
	    this.sign();
	}

	var a = [];
	a.push(params.tbsresp);
	a.push(new _AlgorithmIdentifier({name: params.sigalg}));
	a.push(new _DERBitString({hex: "00" + params.sighex}));

	if (params.certs != undefined &&
	    params.certs.length != undefined) {
	    var aCert = [];
	    for (var i = 0; i < params.certs.length; i++) {
		var sCert = params.certs[i];
		var hCert = null;
		if (ASN1HEX.isASN1HEX(sCert)) {
		    hCert = sCert;
		} else if (sCert.match(/-----BEGIN/)) {
		    hCert = pemtohex(sCert);
		} else {
		    throw new _Error("certs[" + i + "] not hex or PEM");
		}
		aCert.push(new _ASN1Object({tlv: hCert}));
	    }
	    var seqCert = new _DERSequence({array: aCert});
	    a.push(new _DERTaggedObject({tag:'a0',explicit:true,obj:seqCert}));
	}
	
	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.ocsp.BasicOCSPResponse, KJUR.asn1.ASN1Object);

/**
 * ResponseData ASN.1 class encoder<br/>
 * @name KJUR.asn1.ocsp.ResponseData
 * @class ResponseData ASN.1 class encoder
 * @param {Array} params JSON object of constructor parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
 * @see KJUR.asn1.ocsp.OCSPResponse
 * @see KJUR.asn1.ocsp.ResponseBytes
 * @see KJUR.asn1.ocsp.BasicOCSPResponse
 * @see KJUR.asn1.ocsp.ResponseData
 * @see KJUR.asn1.ocsp.SingleResponse
 * @see KJUR.asn1.x509.Extensions
 * @see KJUR.asn1.DERGeneralizedTime
 *
 * @description
 * ResponseData ASN.1 class is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
 * <pre>
 * ResponseData ::= SEQUENCE {
 *    version              [0] EXPLICIT Version DEFAULT v1,
 *    responderID              ResponderID,
 *    producedAt               GeneralizedTime,
 *    responses                SEQUENCE OF SingleResponse,
 *    responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
 * </pre>
 * Following properties are available:
 * <ul>
 * <li>{Array}respid - JSON object of {@link KJUR.asn1.ocsp.ResponseID} parameter
 * for "responderID"</li>
 * <li>{Object}prodat - string or JSON parameter of 
 * {@link KJUR.asn1.DERGeneralizedTime} (ex. "20200904235959Z")</li>
 * <li>{Array}responses - array of {@link KJUR.asn1.ocsp.SingleResponse}
 * parameters</li>
 * <li>{Array}ext (OPTION) - array of extension parameters
 * for "responseExtensions".</li>
 * </ul>
 *
 * @example
 * new KJUR.asn1.ocsp.ResponseData({
 *   respid: {key: "12ab..."},
 *   prodat: "20200903235959Z",
 *   array: [
 *     <<SingleResponse parameter1>>, ...
 *   ],
 *   ext: [{extname:"ocspNonce",hex:"12ab..."}]
 * });
 */
KJUR.asn1.ocsp.ResponseData = function(params) {
    KJUR.asn1.ocsp.ResponseData.superclass.constructor.call(this);

    var _Error = Error,
	_KJUR_asn1 = KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_Extensions = _KJUR_asn1.x509.Extensions,
	_KJUR_asn1_ocsp = _KJUR_asn1.ocsp,
	_ResponderID = _KJUR_asn1_ocsp.ResponderID;
	_SingleResponseList = _KJUR_asn1_ocsp.SingleResponseList;
    
    this.params = null;

    this.tohex = function() {
	var params = this.params;
	if (params.respid != undefined) new _Error("respid not specified");
	if (params.prodat != undefined) new _Error("prodat not specified");
	if (params.array != undefined) new _Error("array not specified");

	var a = [];
	a.push(new _ResponderID(params.respid));
	a.push(new _DERGeneralizedTime(params.prodat));
	a.push(new _SingleResponseList(params.array));

	if (params.ext != undefined) {
	    var dExt = new _Extensions(params.ext);
	    a.push(new _DERTaggedObject({tag:'a1', explicit:true, obj:dExt}));
	}

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.setByParam = function(params) {
	this.params = params;
    };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.ocsp.ResponseData, KJUR.asn1.ASN1Object);

/**
 * ResponderID ASN.1 class encoder<br/>
 * @name KJUR.asn1.ocsp.ResponderID
 * @class ResponderID ASN.1 class encoder
 * @param {Array} params JSON object of constructor parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
 * @see KJUR.asn1.ocsp.OCSPResponse
 * @see KJUR.asn1.ocsp.ResponseBytes
 * @see KJUR.asn1.ocsp.BasicOCSPResponse
 * @see KJUR.asn1.ocsp.ResponseData
 * @see X509#getSubject
 * @see X509#getExtSubjectKeyIdentifier
 *
 * @description
 * ResponderID ASN.1 class is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
 * <pre>
 * ResponderID ::= CHOICE {
 *    byName               [1] Name,
 *    byKey                [2] KeyHash }
 * KeyHash ::= OCTET STRING -- SHA-1 hash of responder's public key
 *                             (excluding the tag and length fields)
 * </pre>
 * Following properties are available:
 * <ul>
 * <li>{Array}name (OPTION) - JSON object of {@link KJUR.asn1.x509.X500Name} parameter,
 * PEM string of X.509 certificate or {@link X509} object for "byName",</li>
 * <li>{String}key (OPTION) - hexadecimal string of KeyHash value,
 * PEM string of X.509 certificate or {@link X509} object for "byKey"</li>
 * </ul>
 * <br/>
 * NOTE: From jsrsasign 10.5.20, "name" and "key" member values can be
 * specified by PEM string of X.509 certificate or {@link X509} object.
 * For "name", subject field of the certificate will be used and
 * for "key", subjectKeyIdentifier extension value of the certificate will be used
 * respectively.
 *
 * @example
 * new KJUR.asn1.ocsp.ResponderID({key: "12ab..."})
 * new KJUR.asn1.ocsp.ResponderID({name: {str: "/C=JP/O=Resp"}})
 * new KJUR.asn1.ocsp.ResponderID({name: {array: [[{type:"C",value:"JP",ds:"prn"}]...]}})
 * // by certificate
 * new KJUR.asn1.ocsp.ResponderID({key: "-----BEGIN CERTIFICATE..."})
 * new KJUR.asn1.ocsp.ResponderID({name: "-----BEGIN CERTIFICATE..."})
 * // by X509 object
 * new KJUR.asn1.ocsp.ResponderID({key: new X509(...)})
 * new KJUR.asn1.ocsp.ResponderID({name: new X509(...)})
 */
KJUR.asn1.ocsp.ResponderID = function(params) {
    KJUR.asn1.ocsp.ResponderID.superclass.constructor.call(this);
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_newObject = _KJUR_asn1.ASN1Util.newObject,
	_X500Name = _KJUR_asn1.x509.X500Name,
	_isHex = _KJUR.lang.String.isHex,
	_Error = Error;
    
    this.params = null;
    
    this.tohex = function() {
	var params = this.params;
	if (params.key != undefined) {
	    var hKey = null;
	    if (typeof params.key == "string") {
		if (_isHex(params.key)) hKey = params.key;
		if (params.key.match(/-----BEGIN CERTIFICATE/)) {
		    var x = new X509(params.key);
		    var extSKID = x.getExtSubjectKeyIdentifier();
		    if (extSKID != null) hKey = extSKID.kid.hex;
		}
	    } else if (params.key instanceof X509) {
		var extSKID = params.key.getExtSubjectKeyIdentifier();
		if (extSKID != null) hKey = extSKID.kid.hex;
	    }
	    if (hKey == null) throw new _Error("wrong key member value");
	    var dTag = _newObject({tag: {tag:"a2",
					 explicit:true,
					 obj:{octstr:{hex:hKey}}}});
	    return dTag.tohex();
	} else if (params.name != undefined) {
	    var pName = null;
	    if (typeof params.name == "string" &&
		params.name.match(/-----BEGIN CERTIFICATE/)) {
		var x = new X509(params.name);
		pName = x.getSubject();
	    } else if (params.name instanceof X509) {
		pName = params.name.getSubject();
	    } else if (typeof params.name == "object" &&
		       (params.name.array != undefined ||
			params.name.str != undefined)) {
		pName = params.name;
	    }
	    if (pName == null) throw new _Error("wrong name member value");
	    var dTag = _newObject({tag: {tag:"a1",
					 explicit:true,
					 obj:new _X500Name(pName)}});
	    return dTag.tohex();
	}
	throw new _Error("key or name not specified");
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.setByParam = function(params) {
	this.params = params;
    };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.ocsp.ResponderID, KJUR.asn1.ASN1Object);

/**
 * ASN.1 class encoder for SEQUENCE OF SingleResponse<br/>
 * @name KJUR.asn1.ocsp.SingleResponseList
 * @class ASN.1 class encoder for SEQUENCE OF SingleResponse
 * @param {Array} params array of JSON object for SingleResponse parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
 * @see KJUR.asn1.ocsp.OCSPResponse
 * @see KJUR.asn1.ocsp.ResponseBytes
 * @see KJUR.asn1.ocsp.BasicOCSPResponse
 * @see KJUR.asn1.ocsp.ResponseData
 * @see KJUR.asn1.ocsp.SingleResponse
 *
 * @description
 * ASN.1 class of SEQUENCE OF SingleResponse is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
 * <pre>
 * ResponseData ::= SEQUENCE {
 *    version              [0] EXPLICIT Version DEFAULT v1,
 *    responderID              ResponderID,
 *    producedAt               GeneralizedTime,
 *    responses                SEQUENCE OF SingleResponse,
 *    responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
 * SingleResponse ::= SEQUENCE {
 *    certID                       CertID,
 *    certStatus                   CertStatus,
 *    thisUpdate                   GeneralizedTime,
 *    nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
 *    singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
 * </pre>
 * Following properties are available:
 * <ul>
 * <li>{Array}name (OPTION) - JSON object of {@link KJUR.asn1.x509.X500Name} parameter
 * for "byName"</li>
 * <li>{String}key (OPTION) - hexadecimal string of KeyHash value</li>
 * </ul>
 *
 * @example
 * new KJUR.asn1.ocsp.SingleResponseList([{
 *   certid: {alg:"sha1",issname:"12ab",isskey:"12ab",sbjsn:"12ab"},
 *   status: {status: "good"},
 *   thisupdate: "20200903235959Z"
 * },{
 *   certid: {alg:"sha1",issname:"24ab",isskey:"24ab",sbjsn:"24ab"},
 *   status: {status: "good"},
 *   thisupdate: "20200904235959Z"
 * ])
 */
KJUR.asn1.ocsp.SingleResponseList = function(params) {
    KJUR.asn1.ocsp.SingleResponseList.superclass.constructor.call(this);

    var _KJUR_asn1 = KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_SingleResponse = _KJUR_asn1.ocsp.SingleResponse;

    this.params = null;
    
    this.tohex = function() {
	var params = this.params;

	if (typeof params != "object" || params.length == undefined) {
	    throw new Error("params not specified properly");
	}

	var a = [];
	for (var i = 0; i < params.length; i++) {
	    a.push(new _SingleResponse(params[i]));
	}

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.setByParam = function(params) {
	this.params = params;
    };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.ocsp.SingleResponseList, KJUR.asn1.ASN1Object);

/**
 * SingleResponse ASN.1 class encoder<br/>
 * @name KJUR.asn1.ocsp.SingleResponse
 * @class SingleResponse ASN.1 class encoder
 * @param {Array} params JSON object for SingleResponse parameter
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
 * @see KJUR.asn1.ocsp.OCSPResponse
 * @see KJUR.asn1.ocsp.ResponseBytes
 * @see KJUR.asn1.ocsp.BasicOCSPResponse
 * @see KJUR.asn1.ocsp.ResponseData
 * @see KJUR.asn1.ocsp.SingleResponse
 * @see KJUR.asn1.ocsp.CertID
 * @see KJUR.asn1.ocsp.CertStatus
 *
 * @description
 * ASN.1 class of SEQUENCE OF SingleResponse is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
 * <pre>
 * SingleResponse ::= SEQUENCE {
 *    certID                       CertID,
 *    certStatus                   CertStatus,
 *    thisUpdate                   GeneralizedTime,
 *    nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
 *    singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
 * </pre>
 * Following properties are available:
 * <ul>
 * <li>{Array}certid - JSON object of {@link KJUR.asn1.ocsp.CertID} parameter</li>
 * <li>{Array}status - JSON object of {@link KJUR.asn1.ocsp.CertStatus} parameter</li>
 * <li>{Object}thisupdate - {@link KJUR.asn1.DERGeneralizedTime} parameter
 * for "thisUpdate"</li>
 * <li>{Object}nextupdate (OPTION) - {@link KJUR.asn1.DERGeneralizedTime} parameter
 * for "nextUpdate"</li>
 * <li>{Array}ext (OPTION) - array of JSON object 
 * {@link KJUR.asn1.x509.Extension} sub class parameter for
 * "singleExtensions"</li>
 * </ul>
 *
 * @example
 * new KJUR.asn1.ocsp.SingleResponse({
 *   certid: {alg:"sha1",issname:"12ab",isskey:"12ab",sbjsn:"12ab"},
 *   status: {status: "good"},
 *   thisupdate: "20200903235959Z",
 *   nextupdate: "20200913235959Z",
 *   ext: [<<Extension parameters>>...]
 * })
 */
KJUR.asn1.ocsp.SingleResponse = function(params) {
    var _Error = Error,
	_KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime,
	_DERTaggedObject = _KJUR_asn1.DERTaggedObject,
	_KJUR_asn1_ocsp = _KJUR_asn1.ocsp,
	_CertID = _KJUR_asn1_ocsp.CertID,
	_CertStatus = _KJUR_asn1_ocsp.CertStatus,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_Extensions = _KJUR_asn1_x509.Extensions;

    _KJUR_asn1_ocsp.SingleResponse.superclass.constructor.call(this);

    this.params = null;
    
    this.tohex = function() {
	var params = this.params;
	var a = [];

	if (params.certid == undefined) throw new _Error("certid unspecified");
	if (params.status == undefined) throw new _Error("status unspecified");
	if (params.thisupdate == undefined) throw new _Error("thisupdate unspecified");

	a.push(new _CertID(params.certid));
	a.push(new _CertStatus(params.status));
	a.push(new _DERGeneralizedTime(params.thisupdate));

	if (params.nextupdate != undefined) {
	    var dTime = new _DERGeneralizedTime(params.nextupdate);
	    a.push(new _DERTaggedObject({tag:'a0', explicit:true, obj:dTime}));
	}

	if (params.ext != undefined) {
	    var dExt = new _Extensions(params.ext);
	    a.push(new _DERTaggedObject({tag:'a1', explicit:true, obj:dExt}));
	}

	var seq = new _DERSequence({array: a});
	return seq.tohex();
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.setByParam = function(params) {
	this.params = params;
    };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.ocsp.SingleResponse, KJUR.asn1.ASN1Object);

/**
 * ASN.1 CertID class for OCSP<br/>
 * @name KJUR.asn1.ocsp.CertID
 * @class ASN.1 CertID class for OCSP
 * @param {Array} params JSON object of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 6.1.0 asn1ocsp 1.0.0
 * @see KJUR.asn1.ocsp.SingleResponse
 * @see KJUR.asn1.x509.AlgorithmIdentifier
 *
 * @description
 * CertID ASN.1 class is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.1.1">RFC 6960 4.1.1</a>. 
 * <pre>
 * CertID ::= SEQUENCE {
 *   hashAlgorithm   AlgorithmIdentifier,
 *   issuerNameHash  OCTET STRING, -- Hash of issuer's DN
 *   issuerKeyHash   OCTET STRING, -- Hash of issuer's public key
 *   serialNumber    CertificateSerialNumber }
 * </pre>
 * Following properties are available in "params" of the constructor:
 * <ul>
 * <li>{String}alg (OPTION) - hash algorithm name. Default is "sha1" (ex, "sha1")</li>
 * <li>{String}issname (OPTION) - hexadecimal string of issuerNameHash</li>
 * <li>{String}isskey (OPTION) - hexadecimal string of issuerKeyHash</li>
 * <li>{String}sbjsn (OPTION) - hexadecimal string of serial number of subject certificate</li>
 * <li>{String}issuerCert (OPTION) - PEM string of issuer certificate.
 * Property "issname" and "isskey" will be set by "issuerCert".</li>
 * <li>{String}subjectCert (OPTION) - PEM string of issuer certificate.
 * Property "sbjsn" will be set by "subjectCert".</li>
 * </ul>
 * <br/>
 * NOTE: Properties "namehash", "keyhash" and "serial" are
 * changed to "issname", "isskey", and "sbjsn" respectively
 * since jsrsasign 9.1.6 asn1ocsp 1.1.0.
 *
 * @example
 * // constructor with explicit values (changed since jsrsasign 9.1.6)
 * new KJUR.asn1.ocsp.CertID({issname: "1a...", isskey: "ad...", sbjsn: "1234", alg: "sha256"});
 *
 * // constructor with certs (sha1 is used by default)
 * o = new KJUR.asn1.ocsp.CertID({issuerCert: "-----BEGIN...", subjectCert: "-----BEGIN..."});
 *
 * // constructor with certs and sha256
 * o = new KJUR.asn1.ocsp.CertID({issuerCert: "-----BEGIN...", subjectCert: "-----BEGIN...", alg: "sha256"});
 */
KJUR.asn1.ocsp.CertID = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DEROctetString = _KJUR_asn1.DEROctetString,
	_DERInteger = _KJUR_asn1.DERInteger,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_AlgorithmIdentifier = _KJUR_asn1_x509.AlgorithmIdentifier,
	_KJUR_asn1_ocsp = _KJUR_asn1.ocsp,
	_DEFAULT_HASH = _KJUR_asn1_ocsp.DEFAULT_HASH,
	_KJUR_crypto = _KJUR.crypto,
	_hashHex = _KJUR_crypto.Util.hashHex,
	_X509 = X509,
	_ASN1HEX = ASN1HEX,
	_getVbyList = _ASN1HEX.getVbyList;

    _KJUR_asn1_ocsp.CertID.superclass.constructor.call(this);

    this.DEFAULT_HASH = "sha1";
    this.params = null;

    /**
     * set CertID ASN.1 object by values.<br/>
     * @name setByValue
     * @memberOf KJUR.asn1.ocsp.CertID#
     * @function
     * @param {String} issuerNameHashHex hexadecimal string of hash value of issuer name
     * @param {String} issuerKeyHashHex hexadecimal string of hash value of issuer public key
     * @param {String} serialNumberHex hexadecimal string of certificate serial number to be verified
     * @param {String} algName hash algorithm name used for above arguments (ex. "sha1") DEFAULT: sha1
     * @since jsrsasign 6.1.0 asn1ocsp 1.0.0
     * @example
     * o = new KJUR.asn1.ocsp.CertID();
     * o.setByValue("1fac...", "fd3a...", "1234"); // sha1 is used by default
     * o.setByValue("1fac...", "fd3a...", "1234", "sha256");
     */
    this.setByValue = function(issuerNameHashHex, issuerKeyHashHex,
			       serialNumberHex, algName) {
	if (algName == undefined) algName = this.DEFAULT_HASH;
	this.params = {
	    alg: algName,
	    issname: issuerNameHashHex,
	    isskey: issuerKeyHashHex,
	    sbjsn: serialNumberHex
	};
    };

    /**
     * set CertID ASN.1 object by PEM certificates.<br/>
     * @name setByCert
     * @memberOf KJUR.asn1.ocsp.CertID#
     * @function
     * @param {String} issuerCert string of PEM issuer certificate
     * @param {String} subjectCert string of PEM subject certificate to be verified by OCSP
     * @param {String} algName hash algorithm name used for above arguments (ex. "sha1") DEFAULT: sha1
     * @since jsrsasign 6.1.0 asn1ocsp 1.0.0
     * @deprecated since jsrsasign 10.5.7 asn1ocsp 1.1.6. Please use setByParam instead.
     *
     * @example
     * o = new KJUR.asn1.ocsp.CertID();
     * o.setByCert("-----BEGIN...", "-----BEGIN..."); // sha1 is used by default
     * o.setByCert("-----BEGIN...", "-----BEGIN...", "sha256");
     */
    this.setByCert = function(issuerCert, subjectCert, algName) {
	if (algName == undefined) algName = this.DEFAULT_HASH;
	this.params = {
	    alg: algName,
	    issuerCert: issuerCert,
	    subjectCert: subjectCert,
	};
    };

    /**
     * calculate CertID parameter by certificates.<br/>
     * @name getParamByCerts
     * @memberOf KJUR.asn1.ocsp.CertID#
     * @function
     * @param {string} issuerCert string of PEM issuer certificate
     * @param {string} subjectCert string of PEM subject certificate to be verified by OCSP
     * @param {string} algName hash algorithm name used for above arguments (ex. "sha1") DEFAULT: sha1
     * @param {object} associative array with alg, issname, isskey and sbjsn members
     * @since jsrsasign 10.5.7 asn1ocsp 1.1.6
     *
     * @description
     * This method calculates issuer name hash, issuer key hash and subject serial
     * number then returns an associative array with alg, issname, isskey and sbjsn members.
     *
     * @example
     * o = new KJUR.asn1.ocsp.CertID();
     * o.getParamByCerts("-----BEGIN...", "-----BEGIN...", "sha256") &rarr;
     * {
     *   alg: "sha256",
     *   issname: "12abcd...",
     *   isskey: "23cdef...",
     *   sbjsn: "57b3..."
     * }
     */
    this.getParamByCerts = function(issCert, sbjCert, algName) {
	if (algName == undefined) algName = this.DEFAULT_HASH;
	var xISS = new _X509(issCert);
	var xSBJ = new _X509(sbjCert);
	var issname = _hashHex(xISS.getSubjectHex(), algName);
	var hSPKI = xISS.getPublicKeyHex();
	var isskey = _hashHex(_getVbyList(hSPKI, 0, [1], "03", true), algName);
	var sbjsn = xSBJ.getSerialNumberHex();
	var info = {
	    alg: algName,
	    issname: issname,
	    isskey: isskey,
	    sbjsn: sbjsn
	};
	return info;
    };

    this.tohex = function() {
	if (typeof this.params != "object") throw new Error("params not set");
	    
	var p = this.params;
	var issname, isskey, sbjsn, alg;

	if (p.alg == undefined) {
	    alg = this.DEFAULT_HASH;
	} else {
	    alg = p.alg;
	}

	if (p.issuerCert != undefined &&
	    p.subjectCert != undefined) {
	    var info = this.getParamByCerts(p.issuerCert, p.subjectCert, alg);
	    issname = info.issname;
	    isskey = info.isskey;
	    sbjsn = info.sbjsn;
	} else if (p.issname != undefined &&
		   p.isskey != undefined &&
		   p.sbjsn != undefined) {
	    issname = p.issname;
	    isskey = p.isskey;
	    sbjsn = p.sbjsn;
	} else {
	    throw new Error("required param members not defined");
	}

	var dAlg = new _AlgorithmIdentifier({name: alg});
	var dIssName = new _DEROctetString({hex: issname});
	var dIssKey = new _DEROctetString({hex: isskey});
	var dSbjSn = new _DERInteger({hex: sbjsn});
	var seq = new _DERSequence({array: [dAlg, dIssName, dIssKey, dSbjSn]});
        this.hTLV = seq.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.ocsp.CertID, KJUR.asn1.ASN1Object);

/**
 * CertStatus ASN.1 class encoder<br/>
 * @name KJUR.asn1.ocsp.CertStatus
 * @class CertStatus ASN.1 class encoder
 * @param {Array} params JSON object for CertStatus parameter
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
 * @see KJUR.asn1.ocsp.OCSPResponse
 * @see KJUR.asn1.ocsp.ResponseBytes
 * @see KJUR.asn1.ocsp.BasicOCSPResponse
 * @see KJUR.asn1.ocsp.ResponseData
 * @see KJUR.asn1.ocsp.SingleResponse
 * @see KJUR.asn1.ocsp.CertID
 * @see KJUR.asn1.ocsp.CertStatus
 *
 * @description
 * ASN.1 class of SEQUENCE OF SingleResponse is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
 * <pre>
 * CertStatus ::= CHOICE {
 *     good        [0]     IMPLICIT NULL,
 *     revoked     [1]     IMPLICIT RevokedInfo,
 *     unknown     [2]     IMPLICIT UnknownInfo }
 * RevokedInfo ::= SEQUENCE {
 *     revocationTime              GeneralizedTime,
 *     revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }
 * UnknownInfo ::= NULL
 * CRLReason ::= ENUMERATED {
 *      unspecified             (0),
 *      keyCompromise           (1),
 *      cACompromise            (2),
 *      affiliationChanged      (3),
 *      superseded              (4),
 *      cessationOfOperation    (5),
 *      certificateHold         (6),
 *           -- value 7 is not used
 *      removeFromCRL           (8),
 *      privilegeWithdrawn      (9),
 *      aACompromise           (10) }
 * </pre>
 * Following properties are available:
 * <ul>
 * <li>{String}status - "good", "revoked" or "unknown"</li>
 * <li>{String}time (OPTION) - revocationTime YYYYMMDDHHmmSSZ (ex. "20200904235959Z")</li>
 * <li>{Number}reason (OPTION) - revocationReason code number</li>
 * </ul>
 *
 * @example
 * new KJUR.asn1.ocsp.CertStatus({status: "good"})
 * new KJUR.asn1.ocsp.CertStatus({status: "revoked", time: "20200903235959Z"})
 * new KJUR.asn1.ocsp.CertStatus({status: "revoked", time: "20200903235959Z", reason: 3})
 * new KJUR.asn1.ocsp.CertStatus({status: "unknown"})
 */
KJUR.asn1.ocsp.CertStatus = function(params) {
    KJUR.asn1.ocsp.CertStatus.superclass.constructor.call(this);

    this.params = null;

    this.tohex = function() {
	var params = this.params;
	if (params.status == "good") return "8000";
	if (params.status == "unknown") return "8200";
	if (params.status == "revoked") {
	    var a = [{gentime: {str: params.time}}];
	    if (params.reason != undefined) {
		a.push({tag: {tag: 'a0', 
			      explicit: true,
			      obj: {'enum': {'int': params.reason}}}});
	    }
	    var tagParam = {tag: 'a1', explicit: false, obj: {seq: a}};
	    return KJUR.asn1.ASN1Util.newObject({tag: tagParam}).tohex();
	}
	throw new Error("bad status");
    };
    this.getEncodedHex = function() { return this.tohex(); };

    this.setByParam = function(params) {
	this.params = params;
    };

    if (params !== undefined) this.setByParam(params);
};
extendClass(KJUR.asn1.ocsp.CertStatus, KJUR.asn1.ASN1Object);

// ---- END OF Classes for OCSP response -----------------------------------

/**
 * ASN.1 Request class for OCSP<br/>
 * @name KJUR.asn1.ocsp.Request
 * @class ASN.1 Request class for OCSP
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 6.1.0 asn1ocsp 1.0.0
 * @description
 * Request ASN.1 class is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.1.1">RFC 6960 4.1.1</a>. 
 * singleRequestExtensions is not supported yet in this version such as nonce.
 * <pre>
 * Request ::= SEQUENCE {
 *   reqCert                  CertID,
 *   singleRequestExtensions  [0] EXPLICIT Extensions OPTIONAL }
 * </pre>
 * @example
 * // default constructor
 * o = new KJUR.asn1.ocsp.Request();
 * // constructor with certs (sha1 is used by default)
 * o = new KJUR.asn1.ocsp.Request({issuerCert: "-----BEGIN...", subjectCert: "-----BEGIN..."});
 * // constructor with certs and sha256
 * o = new KJUR.asn1.ocsp.Request({issuerCert: "-----BEGIN...", subjectCert: "-----BEGIN...", alg: "sha256"});
 * // constructor with values
 * o = new KJUR.asn1.ocsp.Request({namehash: "1a...", keyhash: "ad...", serial: "1234", alg: "sha256"});
 */
KJUR.asn1.ocsp.Request = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_ocsp = _KJUR_asn1.ocsp;
    
    _KJUR_asn1_ocsp.Request.superclass.constructor.call(this);
    this.dReqCert = null;
    this.dExt = null;
    
    this.tohex = function() {
	var a = [];

	// 1. reqCert
	if (this.dReqCert === null)
	    throw "reqCert not set";
	a.push(this.dReqCert);

	// 2. singleRequestExtensions (not supported yet)

	// 3. construct SEQUENCE
	var seq = new _DERSequence({array: a});
        this.hTLV = seq.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (typeof params !== "undefined") {
	var o = new _KJUR_asn1_ocsp.CertID(params);
	this.dReqCert = o;
    }
};
extendClass(KJUR.asn1.ocsp.Request, KJUR.asn1.ASN1Object);

/**
 * ASN.1 TBSRequest class for OCSP<br/>
 * @name KJUR.asn1.ocsp.TBSRequest
 * @class ASN.1 TBSRequest class for OCSP
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 6.1.0 asn1ocsp 1.0.0
 * @description
 * TBSRequest ASN.1 class is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.1.1">RFC 6960 4.1.1</a>. 
 * <pre>
 * TBSRequest ::= SEQUENCE {
 *   version            [0] EXPLICIT Version DEFAULT v1,
 *   requestorName      [1] EXPLICIT GeneralName OPTIONAL,
 *   requestList            SEQUENCE OF Request,
 *   requestExtensions  [2] EXPLICIT Extensions OPTIONAL }
 * </pre>
 * @example
 * // default constructor
 * o = new KJUR.asn1.ocsp.TBSRequest();
 * // constructor with requestList parameter
 * o = new KJUR.asn1.ocsp.TBSRequest({reqList:[
 *   {issuerCert: "-----BEGIN...", subjectCert: "-----BEGIN...", alg:},
 *   {issuerCert: "-----BEGIN...", subjectCert: "-----BEGIN...", alg: "sha256"}
 * ]});
 */
KJUR.asn1.ocsp.TBSRequest = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_ocsp = _KJUR_asn1.ocsp;

    _KJUR_asn1_ocsp.TBSRequest.superclass.constructor.call(this);
    this.version = 0;
    this.dRequestorName = null;
    this.dRequestList = [];
    this.dRequestExt = null;

    /**
     * set TBSRequest ASN.1 object by array of parameters.<br/>
     * @name setRequestListByParam
     * @memberOf KJUR.asn1.ocsp.TBSRequest#
     * @function
     * @param {Array} aParams array of parameters for Request class
     * @since jsrsasign 6.1.0 asn1ocsp 1.0.0
     * @example
     * o = new KJUR.asn1.ocsp.TBSRequest();
     * o.setRequestListByParam([
     *   {issuerCert: "-----BEGIN...", subjectCert: "-----BEGIN...", alg:},
     *   {issuerCert: "-----BEGIN...", subjectCert: "-----BEGIN...", alg: "sha256"}
     * ]);
     */
    this.setRequestListByParam = function(aParams) {
	var a = [];
	for (var i = 0; i < aParams.length; i++) {
	    var dReq = new _KJUR_asn1_ocsp.Request(aParams[0]);
	    a.push(dReq);
	}
	this.dRequestList = a;
    };

    this.tohex = function() {
	var a = [];

	// 1. version
	if (this.version !== 0)
	    throw "not supported version: " + this.version;

	// 2. requestorName
	if (this.dRequestorName !== null)
	    throw "requestorName not supported";

	// 3. requestList
	var seqRequestList = 
	    new _DERSequence({array: this.dRequestList});
	a.push(seqRequestList);

	// 4. requestExtensions
	if (this.dRequestExt !== null)
	    throw "requestExtensions not supported";

	// 5. construct SEQUENCE
	var seq = new _DERSequence({array: a});
        this.hTLV = seq.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
	if (params.reqList !== undefined)
	    this.setRequestListByParam(params.reqList);
    }
};
extendClass(KJUR.asn1.ocsp.TBSRequest, KJUR.asn1.ASN1Object);


/**
 * ASN.1 OCSPRequest class for OCSP<br/>
 * @name KJUR.asn1.ocsp.OCSPRequest
 * @class ASN.1 OCSPRequest class for OCSP
 * @param {Array} params associative array of parameters
 * @extends KJUR.asn1.ASN1Object
 * @since jsrsasign 6.1.0 asn1ocsp 1.0.0
 * @description
 * OCSPRequest ASN.1 class is defined in 
 * <a href="https://tools.ietf.org/html/rfc6960#section-4.1.1">RFC 6960 4.1.1</a>. 
 * A signed request is not supported yet in this version.
 * <pre>
 * OCSPRequest ::= SEQUENCE {
 *   tbsRequest             TBSRequest,
 *   optionalSignature  [0] EXPLICIT Signature OPTIONAL }
 * </pre>
 * @example
 * // default constructor
 * o = new KJUR.asn1.ocsp.OCSPRequest();
 * // constructor with requestList parameter
 * o = new KJUR.asn1.ocsp.OCSPRequest({reqList:[
 *   {issuerCert: "-----BEGIN...", subjectCert: "-----BEGIN...", alg:},
 *   {issuerCert: "-----BEGIN...", subjectCert: "-----BEGIN...", alg: "sha256"}
 * ]});
 */
KJUR.asn1.ocsp.OCSPRequest = function(params) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERSequence = _KJUR_asn1.DERSequence,
	_KJUR_asn1_ocsp = _KJUR_asn1.ocsp;

    _KJUR_asn1_ocsp.OCSPRequest.superclass.constructor.call(this);
    this.dTbsRequest = null;
    this.dOptionalSignature = null;

    this.tohex = function() {
	var a = [];

	// 1. tbsRequest
	if (this.dTbsRequest !== null) {
	    a.push(this.dTbsRequest);
	} else {
	    throw "tbsRequest not set";
	}

	// 2. optionalSignature
	if (this.dOptionalSignature !== null)
	    throw "optionalSignature not supported";

	// 3. construct SEQUENCE
	var seq = new _DERSequence({array: a});
        this.hTLV = seq.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() { return this.tohex(); };

    if (params !== undefined) {
	if (params.reqList !== undefined) {
	    var o = new _KJUR_asn1_ocsp.TBSRequest(params);
	    this.dTbsRequest = o;
	}
    }
};
extendClass(KJUR.asn1.ocsp.OCSPRequest, KJUR.asn1.ASN1Object);

/**
 * Utility class for OCSP<br/>
 * @name KJUR.asn1.ocsp.OCSPUtil
 * @class Utility class for OCSP
 * @since jsrsasign 6.1.0 asn1ocsp 1.0.0
 * @description
 * This class provides utility static methods for OCSP.
 * <ul>
 * <li>{@link KJUR.asn1.ocsp.OCSPUtil.getRequestHex} - generates hexadecimal string of OCSP request</li>
 * </ul>
 */
KJUR.asn1.ocsp.OCSPUtil = {};

/**
 * generates hexadecimal string of OCSP request<br/>
 * @name getRequestHex
 * @memberOf KJUR.asn1.ocsp.OCSPUtil
 * @function
 * @param {String} issuerCert string of PEM issuer certificate
 * @param {String} subjectCert string of PEM subject certificate to be verified by OCSP
 * @param {String} algName hash algorithm name used for above arguments (ex. "sha1") DEFAULT: sha1
 * @return {String} hexadecimal string of generated OCSP request
 * @since jsrsasign 6.1.0 asn1ocsp 1.0.0
 * @description
 * This static method generates hexadecimal string of OCSP request.
 * @example
 * // generate OCSP request using sha1 algorithnm by default.
 * hReq = KJUR.asn1.ocsp.OCSPUtil.getRequestHex("-----BEGIN...", "-----BEGIN...");
 */
KJUR.asn1.ocsp.OCSPUtil.getRequestHex = function(issuerCert, subjectCert, alg) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_KJUR_asn1_ocsp = _KJUR_asn1.ocsp;

    if (alg === undefined) alg = _KJUR_asn1_ocsp.DEFAULT_HASH;
    var param = {alg: alg, issuerCert: issuerCert, subjectCert: subjectCert};
    var o = new _KJUR_asn1_ocsp.OCSPRequest({reqList: [param]});
    return o.tohex();
};

/**
 * simple parser for OCSPResponse (DEPRECATED)<br/>
 * @name getOCSPResponseInfo
 * @memberOf KJUR.asn1.ocsp.OCSPUtil
 * @function
 * @param {String} h hexadecimal string of DER OCSPResponse
 * @return {Object} JSON object of parsed OCSPResponse
 * @since jsrsasign 6.1.0 asn1ocsp 1.0.1
 * @deprecated since jsrsasign 10.4.0 asn1ocsp 1.1.5 Please use OCSPParser.getOCSPRespnose
 *
 * @description
 * This static method parse a hexadecimal string of DER OCSPResponse and
 * returns JSON object of its parsed result.
 * Its result has following properties:
 * <ul>
 * <li>responseStatus - integer of responseStatus</li>
 * <li>certStatus - string of certStatus (ex. good, revoked or unknown)</li>
 * <li>thisUpdate - string of thisUpdate in Zulu(ex. 20151231235959Z)</li>
 * <li>nextUpdate - string of nextUpdate in Zulu(ex. 20151231235959Z)</li>
 * </ul>
 * NOTE: This method may not work preperly. Please use 
 * {@link KJUR.asn1.ocsp.OCSPParser#getOCSPResponse}.
 *
 * @example
 * info = KJUR.asn1.ocsp.OCSPUtil.getOCSPResponseInfo("3082...");
 */
KJUR.asn1.ocsp.OCSPUtil.getOCSPResponseInfo = function(h) {
    var _ASN1HEX = ASN1HEX,
	_getVbyList = _ASN1HEX.getVbyList,
	_getVbyListEx = _ASN1HEX.getVbyListEx,
	_getIdxbyList = _ASN1HEX.getIdxbyList,
	_getIdxbyListEx = _ASN1HEX.getIdxbyListEx,
	_getV = _ASN1HEX.getV;

    var result = {};
    try {
	var v = _getVbyListEx(h, 0, [0], "0a");
	result.responseStatus = parseInt(v, 16);
    } catch(ex) {};
    if (result.responseStatus !== 0) return result;

    try {
	// certStatus
	var idxCertStatus = _getIdxbyList(h, 0, [1,0,1,0,0,2,0,1]);
	if (h.substr(idxCertStatus, 2) === "80") {
	    result.certStatus = "good";
	} else if (h.substr(idxCertStatus, 2) === "a1") {
	    result.certStatus = "revoked";
	    result.revocationTime = 
		hextoutf8(_getVbyList(h, idxCertStatus, [0]));
	} else if (h.substr(idxCertStatus, 2) === "82") {
	    result.certStatus = "unknown";
	}
    } catch (ex) {};

    // thisUpdate
    try {
	var idxThisUpdate = _getIdxbyList(h, 0, [1,0,1,0,0,2,0,2]);
	result.thisUpdate = hextoutf8(_getV(h, idxThisUpdate));
    } catch (ex) {};

    // nextUpdate
    try {
	var idxEncapNextUpdate = _getIdxbyList(h, 0, [1,0,1,0,0,2,0,3]);
	if (h.substr(idxEncapNextUpdate, 2) === "a0") {
	    result.nextUpdate = 
		hextoutf8(_getVbyList(h, idxEncapNextUpdate, [0]));
	}
    } catch (ex) {};

    return result;
};

/**
 * OCSP request and response parser<br/>
 * @name KJUR.asn1.ocsp.OCSPParser
 * @class OCSP request and response parser
 * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
 *
 * @description
 * This class provides ASN.1 parser for
 * OCSP related ASN.1 data. <br/>
 * NOTE: OCSPResponse parser supported from jsrsasign 10.4.0.
 * <br/>
 * This parser supports following OCSP ASN.1 classes:
 * <ul>
 * <li>OCSP REQUEST
 * <ul>
 * <li>OCSPRequest - {@link KJUR.asn1.ocsp.OCSPParser#getOCSPRequest}</li>
 * <li>TBSRequest - {@link KJUR.asn1.ocsp.OCSPParser#getTBSRequest}</li>
 * <li>SEQUENCE OF Request - {@link KJUR.asn1.ocsp.OCSPParser#getRequestList}</li>
 * <li>Request - {@link KJUR.asn1.ocsp.OCSPParser#getRequest}</li>
 * </ul>
 * </li>
 * <li>OCSP RESPONSE
 * <ul>
 * <li>OCSPResponse - {@link KJUR.asn1.ocsp.OCSPParser#getOCSPResponse}</li>
 * <li>ResponseBytes - {@link KJUR.asn1.ocsp.OCSPParser#getResponseBytes}</li>
 * <li>BasicOCSPResponse - {@link KJUR.asn1.ocsp.OCSPParser#getBasicOCSPResponse}</li>
 * <li>ResponseData - {@link KJUR.asn1.ocsp.OCSPParser#getResponseData}</li>
 * <li>ResponderID - {@link KJUR.asn1.ocsp.OCSPParser#getResponderID}</li>
 * <li>SEQUENCE OF SingleResponse - {@link KJUR.asn1.ocsp.OCSPParser#getSingleResponseList}</li>
 * <li>SingleResponse - {@link KJUR.asn1.ocsp.OCSPParser#getSingleResponse}</li>
 * <li>CertStatus - {@link KJUR.asn1.ocsp.OCSPParser#getCertStatus}</li>
 * </ul>
 * </li>
 * <li>common
 * <ul>
 * <li>CertID - {@link KJUR.asn1.ocsp.OCSPParser#getCertID}</li>
 * </ul>
 * </li>
 * </ul>
 */
KJUR.asn1.ocsp.OCSPParser = function() {
    var _Error = Error,
	_X509 = X509,
	_x509obj = new _X509(),
	_ASN1HEX = ASN1HEX,
	_getV = _ASN1HEX.getV,
	_getTLV = _ASN1HEX.getTLV,
	_getIdxbyList = _ASN1HEX.getIdxbyList,
	_getVbyList = _ASN1HEX.getVbyList,
	_getTLVbyList = _ASN1HEX.getTLVbyList,
	_getVbyListEx = _ASN1HEX.getVbyListEx,
	_getTLVbyListEx = _ASN1HEX.getTLVbyListEx,
	_getChildIdx = _ASN1HEX.getChildIdx;

    /**
     * parse ASN.1 OCSPRequest<br/>
     * @name getOCSPRequest
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 OCSPRequest
     * @return {Array} array of JSON object of OCSPRequest parameter
     * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
     *
     * @description
     * This method will parse a hexadecimal string of 
     * OCSPRequest ASN.1 class is defined in 
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.1.1">RFC 6960 4.1.1</a>. 
     * <pre>
     * OCSPRequest ::= SEQUENCE {
     *   tbsRequest              TBSRequest,
     *   optionalSignature  [0]  EXPLICIT Signature OPTIONAL }
     * TBSRequest  ::=  SEQUENCE {
     *   version            [0]  EXPLICIT Version DEFAULT v1,
     *   requestorName      [1]  EXPLICIT GeneralName OPTIONAL,
     *   requestList             SEQUENCE OF Request,
     *   requestExtensions  [2]  EXPLICIT Extensions OPTIONAL }
     * Signature       ::=     SEQUENCE {
     *   signatureAlgorithm      AlgorithmIdentifier,
     *   signature               BIT STRING,
     *   certs              [0] EXPLICIT SEQUENCE OF Certificate
     *                          OPTIONAL}
     * </pre>
     * Currently Signature in OCSPRequest is not supported.
     * <br/>
     * 
     * @see KJUR.asn1.ocsp.OCSPParser#getTBSRequest
     * @see KJUR.asn1.ocsp.OCSPRequest
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getOCSPRequest("30...") &rarr;
     * { array: [{
     *    "alg": "sha1",
     *    "issname": "105fa67a80089db5279f35ce830b43889ea3c70d",
     *    "isskey": "0f80611c823161d52f28e78d4638b42ce1c6d9e2",
     *    "sbjsn": "0fef62075d715dc5e1d8bd03775c9686" }]}
     */
    this.getOCSPRequest = function(h) {
	var a = _getChildIdx(h, 0);

	if (a.length != 1 && a.length != 2) {
	    throw new _Error("wrong number elements: " + a.length);
	}

	var result = this.getTBSRequest(_getTLV(h, a[0]));
	return result;
    };

    /**
     * parse ASN.1 TBSRequest of OCSP<br/>
     * @name getTBSRequest
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 TBSRequest of OCSP
     * @return {Array} array of JSON object of TBSRequest parameter
     * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
     *
     * @description
     * This method will parse
     * TBSRequest ASN.1 class is defined in 
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.1.1">RFC 6960 4.1.1</a>. 
     * <pre>
     * TBSRequest  ::=  SEQUENCE {
     *   version            [0]  EXPLICIT Version DEFAULT v1,
     *   requestorName      [1]  EXPLICIT GeneralName OPTIONAL,
     *   requestList             SEQUENCE OF Request,
     *   requestExtensions  [2]  EXPLICIT Extensions OPTIONAL }
     * </pre>
     *
     * @see KJUR.asn1.ocsp.OCSPParser#getOCSPRequest
     * @see KJUR.asn1.ocsp.OCSPParser#getRequestList
     * @see KJUR.asn1.ocsp.TBSRequest
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getTBSRequest("30...") &rarr;
     * {array: [{
     *   "alg": "sha1",
     *   "issname": "105fa67a80089db5279f35ce830b43889ea3c70d",
     *   "isskey": "0f80611c823161d52f28e78d4638b42ce1c6d9e2",
     *   "sbjsn": "0fef62075d715dc5e1d8bd03775c9686" }]}
     */
    this.getTBSRequest = function(h) {
	var result = {};
	var hReqList = _getTLVbyListEx(h, 0, [0], "30");
	result.array = this.getRequestList(hReqList);
	var hExt = _getTLVbyListEx(h, 0, ["[2]", 0], "30");
	if (hExt != null) {
	    result.ext = _x509obj.getExtParamArray(hExt);
	}

	return result;
    };

    /**
     * parse ASN.1 SEQUENCE OF Request in OCSP<br/>
     * @name getRequestList
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 SEQUENCE OF Request in OCSP
     * @return {Array} array of JSON object of Request parameter
     * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
     *
     * @description
     * This method will parse a hexadecimal string of
     * SEQUENCE OF Request ASN.1 class is defined in 
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.1.1">RFC 6960 4.1.1</a>. 
     * <br/>
     * NOTE: singleRequestExtensions is not supported yet in this version such as nonce.
     * <pre>
     * TBSRequest  ::=  SEQUENCE {
     *   version            [0]  EXPLICIT Version DEFAULT v1,
     *   requestorName      [1]  EXPLICIT GeneralName OPTIONAL,
     *   requestList             SEQUENCE OF Request,
     *   requestExtensions  [2]  EXPLICIT Extensions OPTIONAL }
     * Request ::= SEQUENCE {
     *   reqCert                  CertID,
     *   singleRequestExtensions  [0] EXPLICIT Extensions OPTIONAL }      
     * </pre>
     *
     * @see KJUR.asn1.ocsp.OCSPParser#getTBSRequest
     * @see KJUR.asn1.ocsp.OCSPParser#getRequest
     * @see KJUR.asn1.ocsp.RequestList
     * @see KJUR.asn1.ocsp.Request
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getRequestList("30...") &rarr;
     * [{ alg: "sha1"
     *   issname: "...hex...",
     *   isskey: "...hex...",
     *   sbjsn: "...hex...",
     *   ext: [<<singleRequestExtension parameters>>...] }]
     */
    this.getRequestList = function(h) {
	var result = [];
	var a = _getChildIdx(h, 0);
	for (var i = 0; i < a.length; i++) {
	    var h = _getTLV(h, a[i]);
	    result.push(this.getRequest(h));
	}
	return result;
    };

    /**
     * parse ASN.1 Request of OCSP<br/>
     * @name getRequest
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of ASN.1 Request of OCSP
     * @return JSON object of Request parameter
     * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
     *
     * @description
     * This method will parse a hexadecimal string of
     * Request ASN.1 class is defined in 
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.1.1">RFC 6960 4.1.1</a>. 
     * <pre>
     * Request ::= SEQUENCE {
     *   reqCert                  CertID,
     *   singleRequestExtensions  [0] EXPLICIT Extensions OPTIONAL }      
     * </pre>
     *
     * @see KJUR.asn1.ocsp.OCSPParser#getTBSRequest
     * @see KJUR.asn1.ocsp.OCSPParser#getRequestList
     * @see KJUR.asn1.ocsp.OCSPParser#getCertID
     * @see KJUR.asn1.ocsp.RequestList
     * @see KJUR.asn1.ocsp.Request
     * @see KJUR.asn1.ocsp.CertID
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getRequest("30...") &rarr;
     * { alg: "sha1"
     *   issname: "...hex...",
     *   isskey: "...hex...",
     *   sbjsn: "...hex...",
     *   ext: [<<singleRequestExtension parameters>>...] }
     */
    this.getRequest = function(h) {
	var a = _getChildIdx(h, 0);
	if (a.length != 1 && a.length != 2) {
	    throw new _Error("wrong number elements: " + a.length);
	}
	
	var params = this.getCertID(_getTLV(h, a[0]));

	if (a.length == 2) {
	    var idxExt = _getIdxbyList(h, 0, [1, 0]);
	    params.ext = _x509obj.getExtParamArray(_getTLV(h, idxExt));
	}

	return params;
    };

    /**
     * parse ASN.1 CertID of OCSP<br/>
     * @name getCertID
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of CertID
     * @return JSON object of CertID parameter
     * @since jsrsasign 9.1.6 asn1ocsp 1.1.0
     *
     * @description
     * This method will parse a hexadecimal string of
     * CertID ASN.1 class is defined in 
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.1.1">RFC 6960 4.1.1</a>. 
     * <pre>
     * CertID ::= SEQUENCE {
     *   hashAlgorithm   AlgorithmIdentifier,
     *   issuerNameHash  OCTET STRING, -- Hash of issuer's DN
     *   issuerKeyHash   OCTET STRING, -- Hash of issuer's public key
     *   serialNumber    CertificateSerialNumber }
     * </pre>
     *
     * @see KJUR.asn1.ocsp.OCSPParser#getRequest
     * @see KJUR.asn1.ocsp.OCSPParser#getSingleResponse
     * @see KJUR.asn1.ocsp.CertID
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getCertID("30...") &rarr;
     * { alg: "sha1"
     *   issname: "...hex...",
     *   isskey: "...hex...",
     *   sbjsn: "...hex..." }
     */
    this.getCertID = function(h) {
	var a = _getChildIdx(h, 0);
	if (a.length != 4) {
	    throw new _Error("wrong number elements: " + a.length);
	}
	
	var x = new _X509();
	var result = {};
	result.alg = x.getAlgorithmIdentifierName(_getTLV(h, a[0]));
	result.issname = _getV(h, a[1]);
	result.isskey = _getV(h, a[2]);
	result.sbjsn = _getV(h, a[3]);
	
	return result;
    };

    /**
     * parse ASN.1 OCSPResponse of OCSP<br/>
     * @name getOCSPResponse
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of OCSPResponse
     * @return JSON object of OCSResponse parameter
     * @since jsrsasign 10.4.0 asn1ocsp 1.1.5
     *
     * @description
     * This method will parse a hexadecimal string of
     * ASN.1 OCSPResponse defined in
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
     * <pre>
     * OCSPResponse ::= SEQUENCE {
     *    responseStatus         OCSPResponseStatus,
     *    responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }
     * OCSPResponseStatus ::= ENUMERATED {
     *     successful            (0),  -- Response has valid confirmations
     *     malformedRequest      (1),  -- Illegal confirmation request
     *     internalError         (2),  -- Internal error in issuer
     *     tryLater              (3),  -- Try again later
     *                                 -- (4) is not used
     *     sigRequired           (5),  -- Must sign the request
     *     unauthorized          (6)   -- Request unauthorized }
     * </pre>
     *
     * @see KJUR.asn1.ocsp.OCSPParser#getResponseBytes
     * @see KJUR.asn1.ocsp.OCSPResponse
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getOCSPResponse("30..") &rarr;
     * { resstatus: 0,
     *   restype: "ocspBasic",
     *   respid: {key: "12ab"},
     *   prodat: "20200903235959Z",
     *   array: [{
     *     certid: {alg:"sha1",issname:"12ab",isskey:"12ab",sbjsn:"12ab"},
     *     status: {status: "good"},
     *     thisupdate: "20200903235959Z" }],
     *   ext: [{extname: "ocspNonce", hex: "1234abcd"}],
     *   alg: "SHA256withRSA",
     *   sighex: "12ab",
     *   certs: ["3082...", "3082..."] }
     */
    this.getOCSPResponse = function(h) {
	var a = _getChildIdx(h, 0);
	var result;

	var hStatusV = _getV(h, a[0]);
	var iStatusV = parseInt(hStatusV);
	
	if (a.length == 1) return {resstatus: iStatusV};

	var hResponseBytes = _getTLVbyList(h, 0, [1, 0]);
	result = this.getResponseBytes(hResponseBytes);
	result.resstatus = iStatusV;
	
	return result;
    };

    /**
     * parse ASN.1 ResponseBytes of OCSP<br/>
     * @name getResponseBytes
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of ResponseBytes
     * @return JSON object of ResponseBytes parameter
     * @since jsrsasign 10.4.0 asn1ocsp 1.1.5
     *
     * @description
     * This method will parse a hexadecimal string of
     * ASN.1 ResponseBytes defined in
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
     * <pre>
     * ResponseBytes ::=       SEQUENCE {
     *     responseType   OBJECT IDENTIFIER,
     *     response       OCTET STRING }
     * id-pkix-ocsp           OBJECT IDENTIFIER ::= { id-ad-ocsp }
     * id-pkix-ocsp-basic     OBJECT IDENTIFIER ::= { id-pkix-ocsp 1 }
     *
     * BasicOCSPResponse       ::= SEQUENCE {
     *    tbsResponseData      ResponseData,
     *    signatureAlgorithm   AlgorithmIdentifier,
     *    signature            BIT STRING,
     *    certs            [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }
     * </pre>
     *
     * @see KJUR.asn1.ocsp.OCSPParser#getOCSPResponse
     * @see KJUR.asn1.ocsp.OCSPParser#getBasicOCSPResponse
     * @see KJUR.asn1.ocsp.ResponseBytes
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getResponseBytes("30..") &rarr;
     * { restype: "ocspBasic",
     *   ...<<BasicOCSPResponse properties...>>...
     */
    this.getResponseBytes = function(h) {
	var a = _getChildIdx(h, 0);
	var result;

	var hBasicOCSPResponse = _getTLVbyList(h, 0, [1, 0]);
	result = this.getBasicOCSPResponse(hBasicOCSPResponse);

	var hResTypeV = _getV(h, a[0]);
	result.restype = KJUR.asn1.x509.OID.oid2name(hextooid(hResTypeV));
	
	return result;
    };

    /**
     * parse ASN.1 BasicOCSPResponse of OCSP<br/>
     * @name getBasicOCSPResponse
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of BasicOCSPResponse
     * @return JSON object of BasicOCSPResponse parameter
     * @since jsrsasign 10.4.0 asn1ocsp 1.1.5
     *
     * @description
     * This method will parse a hexadecimal string of
     * BasicOCSPResponse defined in 
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
     * <pre>
     * BasicOCSPResponse       ::= SEQUENCE {
     *    tbsResponseData      ResponseData,
     *    signatureAlgorithm   AlgorithmIdentifier,
     *    signature            BIT STRING,
     *    certs            [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }
     * </pre>
     *
     * @see KJUR.asn1.ocsp.OCSPParser#getResponseBytes
     * @see KJUR.asn1.ocsp.OCSPParser#getResponseData
     * @see KJUR.asn1.ocsp.BasicOCSPResponse
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getBasicOCSPResponse("30..") &rarr;
     * { ...<<ResponseData properties...>>...
     *   sigalg: "SHA256withRSA",
     *   sighex: "12abcd...",
     *   certs: [<<PEMorHEXstringOfCert1>>,...] });
     */
    this.getBasicOCSPResponse = function(h) {
	var a = _getChildIdx(h, 0);
	var result;

	result = this.getResponseData(_getTLV(h, a[0]));

	var x = new X509();
	result.alg = x.getAlgorithmIdentifierName(_getTLV(h, a[1]));

	var hSigHex = _getV(h, a[2]);
	result.sighex = hSigHex.substr(2);
	
	var hExt = _getVbyListEx(h, 0, ["[0]"]);
	if (hExt != null) {
	    var aCertIdx = _getChildIdx(hExt, 0);
	    var aCert = [];
	    for (var i = 0; i < aCertIdx.length; i++) {
		var hCert = _getTLV(hExt, aCertIdx[i]);
		aCert.push(hCert);
	    }
	    result.certs = aCert;
	}

	return result;
    };

    /**
     * parse ASN.1 ResponseData of OCSP<br/>
     * @name getResponseData
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of ResponseData
     * @return JSON object of ResponseData parameter
     * @since jsrsasign 10.4.0 asn1ocsp 1.1.5
     *
     * @description
     * This method will parse a hexadecimal string of
     * ASN.1 ResponseData defined in
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
     * <pre>
     * ResponseData ::= SEQUENCE {
     *    version              [0] EXPLICIT Version DEFAULT v1,
     *    responderID              ResponderID,
     *    producedAt               GeneralizedTime,
     *    responses                SEQUENCE OF SingleResponse,
     *    responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
     * </pre>
     *
     * @see KJUR.asn1.ocsp.OCSPParser#getBasicOCSPResponse
     * @see KJUR.asn1.ocsp.OCSPParser#getSingleResponse
     * @see KJUR.asn1.ocsp.ResponseData
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getResponseData("30..") &rarr;
     * { respid: {key: "12ab..."},
     *   prodat: "20200903235959Z",
     *   array: [<<SingleResponse parameter1>>, ...],
     *   ext: [
     *     {extname:"ocspNonce",hex:"12ab..."}]}
     */
    this.getResponseData = function(h) {
	var a = _getChildIdx(h, 0);
	var alen = a.length;
	var result = {};
	var idx = 0;

	// skip to relax interoperability even though explicit DEFAULT
	if (h.substr(a[0], 2) == "a0") idx++;

	result.respid = this.getResponderID(_getTLV(h, a[idx++]));
	
	var hProdAtV = _getV(h, a[idx++]);
	result.prodat = hextoutf8(hProdAtV);
	
	result.array = this.getSingleResponseList(_getTLV(h, a[idx++]));

	if (h.substr(a[alen - 1], 2) == "a1") {
	    var hExt =  _getTLVbyList(h, a[alen - 1], [0]);
	    var x = new X509();
	    result.ext = x.getExtParamArray(hExt);
	}

	return result;
    };

    /**
     * parse ASN.1 ResponderID of OCSP<br/>
     * @name getResponderID
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of ResponderID
     * @return JSON object of ResponderID parameter
     * @since jsrsasign 10.4.0 asn1ocsp 1.1.5
     * @see KJUR.asn1.ocsp.ResponderID
     *
     * @description
     * <pre>
     * ResponderID ::= CHOICE {
     *    byName               [1] Name,
     *    byKey                [2] KeyHash }
     * KeyHash ::= OCTET STRING -- SHA-1 hash of responder's public key
     *                             (excluding the tag and length fields)
     * </pre>
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getResponderID("a1..") &rarr; {name: {array: [[{type:"C",value:"JP",ds:"prn"}]...]}}
     * o.getResponderID("a2..") &rarr; {key: "12ab..."}
     */
    this.getResponderID = function(h) {
	var result = {};

	if (h.substr(0, 2) == "a2") {
	    var hKeyV = _getVbyList(h, 0, [0]);
	    result.key = hKeyV;
	}
	if (h.substr(0, 2) == "a1") {
	    var hName = _getTLVbyList(h, 0, [0]);
	    var x = new X509();
	    result.name = x.getX500Name(hName);
	}
	
	return result;
    };

    /**
     * parse ASN.1 SEQUENCE OF SingleResponse of OCSP<br/>
     * @name getSingleResponseList
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of SEQUENCE OF SingleResponse
     * @return array of SingleResponse parameter JSON object
     * @since jsrsasign 10.4.0 asn1ocsp 1.1.5
     *
     * @description
     * This method will parse a hexadecimal string of
     * ASN.1 class of SEQUENCE OF SingleResponse is defined in 
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
     * <pre>
     * ResponseData ::= SEQUENCE {
     *    version              [0] EXPLICIT Version DEFAULT v1,
     *    responderID              ResponderID,
     *    producedAt               GeneralizedTime,
     *    responses                SEQUENCE OF SingleResponse,
     *    responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
     * SingleResponse ::= SEQUENCE {
     *    certID                       CertID,
     *    certStatus                   CertStatus,
     *    thisUpdate                   GeneralizedTime,
     *    nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
     *    singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
     * </pre>
     *
     * @see KJUR.asn1.ocsp.OCSPParse#getResponseData
     * @see KJUR.asn1.ocsp.OCSPParse#getSingleResponse
     * @see KJUR.asn1.ocsp.OCSPParse#getCertID
     * @see KJUR.asn1.ocsp.SingleResponseList
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getSingleResponseList("30..") &rarr;
     * [{ certid: {alg:"sha1",issname:"12ab",isskey:"12ab",sbjsn:"12ab"},
     *    status: {status: "good"},
     *    thisupdate: "20200903235959Z",
     *    nextupdate: "20200913235959Z",
     *    ext: [<<Extension parameters>>...] }]
     */
    this.getSingleResponseList = function(h) {
	var a = _getChildIdx(h, 0);
	var result = [];

	for (var i = 0; i < a.length; i++) {
	    var p = this.getSingleResponse(_getTLV(h, a[i]));
	    result.push(p);
	}
	return result;
    };

    /**
     * parse ASN.1 SingleResponse of OCSP<br/>
     * @name getSingleResponse
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of SingleResponse
     * @return JSON object of SingleResponse parameter
     * @since jsrsasign 10.4.0 asn1ocsp 1.1.5
     *
     * @description
     * This method will parse a hexadecimal string of
     * ASN.1 class of SingleResponse is defined in 
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.1">RFC 6960 4.2.1</a>. 
     * <pre>
     * SingleResponse ::= SEQUENCE {
     *    certID                       CertID,
     *    certStatus                   CertStatus,
     *    thisUpdate                   GeneralizedTime,
     *    nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
     *    singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
     * </pre>
     *
     * @see KJUR.asn1.ocsp.OCSPParse#getSingleResponseList
     * @see KJUR.asn1.ocsp.OCSPParse#getCertID
     * @see KJUR.asn1.ocsp.SingleResponse
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getSingleResponse("30..") &rarr;
     * { certid: {alg:"sha1",issname:"12ab",isskey:"12ab",sbjsn:"12ab"},
     *   status: {status: "good"},
     *   thisupdate: "20200903235959Z",
     *   nextupdate: "20200913235959Z",
     *   ext: [<<Extension parameters>>...] }
     */
    this.getSingleResponse = function(h) {
	var a = _getChildIdx(h, 0);
	var result = {};

	// 1. CertID
	var pCertID = this.getCertID(_getTLV(h, a[0]));
	result.certid = pCertID;

	// 2. CertStatus
	var pCertStatus = this.getCertStatus(_getTLV(h, a[1]));
	result.status = pCertStatus;

	// 3. ThisUpdate(GeneralizedTime)
	if (h.substr(a[2], 2) == "18") {
	    var hThisUpdateV = _getV(h, a[2]);
	    result.thisupdate = hextoutf8(hThisUpdateV);
	}
	
	// 4. OPTIONAL(nextUpdate, singleExtensions)
	for (var i = 3; i < a.length; i++) {
	    if (h.substr(a[i], 2) == "a0") { // nextUpdate
		var hNextUpdateV = _getVbyList(h, a[i], [0], "18");
		result.nextupdate = hextoutf8(hNextUpdateV);
	    }
	    if (h.substr(a[i], 2) == "a1") { // singleExtensions
		var x = new X509();
		var hExt = _getTLVbyList(h, 0, [i, 0]);
		result.ext = x.getExtParamArray(hExt);
	    }
	}

	return result;
    };

    /**
     * parse ASN.1 CertStatus of OCSP<br/>
     * @name getCertStatus
     * @memberOf KJUR.asn1.ocsp.OCSPParser#
     * @function
     * @param {String} h hexadecimal string of CertStatus
     * @return JSON object of CertStatus parameter
     * @since jsrsasign 10.4.0 asn1ocsp 1.1.5
     * @see KJUR.asn1.ocsp.CertStatus
     *
     * @description
     * <pre>
     * CertStatus ::= CHOICE {
     *     good        [0]     IMPLICIT NULL,
     *     revoked     [1]     IMPLICIT RevokedInfo,
     *     unknown     [2]     IMPLICIT UnknownInfo }
     * RevokedInfo ::= SEQUENCE {
     *     revocationTime              GeneralizedTime,
     *     revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }
     * UnknownInfo ::= NULL
     * </pre>
     * NOTE: Currently revocationReason not supported.
     *
     * @example
     * o = new KJUR.asn1.ocsp.OCSPParser();
     * o.getCertStatus("8000") &rarr; {status: "good"}
     * o.getCertStatus("8200") &rarr; {status: "unknown"}
     * o.getCertStatus("a1..") &rarr; {status: "revoked", time: "2021...Z"}
     */
    this.getCertStatus = function(h) {
	var result = {};
	if (h == "8000") return {status: "good"};
	if (h == "8200") return {status: "unknown"};
	if (h.substr(0, 2) == "a1") {
	    result.status = "revoked";
	    var hTime = _getVbyList(h, 0, [0]);
	    var sTime = hextoutf8(hTime);
	    result.time = sTime;
	}
	return result;
    };
};


/* base64x-1.1.33 (c) 2012-2023 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * base64x.js - Base64url and supplementary functions for Tom Wu's base64.js library
 *
 * Copyright (c) 2012-2023 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name base64x-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.8.4 base64x 1.1.33 (2023-Apr-26)
 * @since jsrsasign 2.1
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

var KJUR;
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.lang == "undefined" || !KJUR.lang) KJUR.lang = {};

/**
 * String and its utility class <br/>
 * This class provides some static utility methods for string.
 * @class String and its utility class
 * @author Kenji Urushima
 * @version 1.0 (2016-Aug-05)
 * @since base64x 1.1.7 jsrsasign 5.0.13
 * @description
 * <br/>
 * This class provides static methods for string utility.
 * <dl>
 * <dt><b>STRING TYPE CHECKERS</b>
 * <dd>
 * <ul>
 * <li>{@link KJUR.lang.String.isInteger} - check whether argument is an integer</li>
 * <li>{@link KJUR.lang.String.isHex} - check whether argument is a hexadecimal string</li>
 * <li>{@link KJUR.lang.String.isBase64} - check whether argument is a Base64 encoded string</li>
 * <li>{@link KJUR.lang.String.isBase64URL} - check whether argument is a Base64URL encoded string</li>
 * <li>{@link KJUR.lang.String.isIntegerArray} - check whether argument is an array of integers</li>
 * <li>{@link KJUR.lang.String.isPrintable} - check whether argument is PrintableString accepted characters</li>
 * <li>{@link KJUR.lang.String.isIA5} - check whether argument is IA5String accepted characters</li>
 * <li>{@link KJUR.lang.String.isMail} - check whether argument is RFC 822 e-mail address format</li>
 * </ul>
 * </dl>
 */
KJUR.lang.String = function() {};

/**
 * Base64URL and supplementary functions for Tom Wu's base64.js library.<br/>
 * This class is just provide information about global functions
 * defined in 'base64x.js'. The 'base64x.js' script file provides
 * global functions for converting following data each other.
 * <ul>
 * <li>(ASCII) String</li>
 * <li>UTF8 String including CJK, Latin and other characters</li>
 * <li>byte array</li>
 * <li>hexadecimal encoded String</li>
 * <li>Full URIComponent encoded String (such like "%69%94")</li>
 * <li>Base64 encoded String</li>
 * <li>Base64URL encoded String</li>
 * </ul>
 * All functions in 'base64x.js' are defined in {@link _global_} and not
 * in this class.
 * 
 * @class Base64URL and supplementary functions for Tom Wu's base64.js library
 * @author Kenji Urushima
 * @version 1.1 (07 May 2012)
 * @requires base64.js
 * @see <a href="https://kjur.github.io/jsjws/">'jwjws'(JWS JavaScript Library) home page https://kjur.github.io/jsjws/</a>
 * @see <a href="https://kjur.github.io/jsrsasigns/">'jwrsasign'(RSA Sign JavaScript Library) home page https://kjur.github.io/jsrsasign/</a>
 */
function Base64x() {
}

// ==== string / byte array ================================
/**
 * convert a string to an array of character codes
 * @name stoBA
 * @function
 * @param {String} s
 * @return {Array of Numbers} 
 */
function stoBA(s) {
    var a = new Array();
    for (var i = 0; i < s.length; i++) {
	a[i] = s.charCodeAt(i);
    }
    return a;
}

/**
 * convert an array of character codes to a string
 * @name BAtos
 * @function
 * @param {Array of Numbers} a array of character codes
 * @return {String} s
 */
function BAtos(a) {
    var s = "";
    for (var i = 0; i < a.length; i++) {
	s = s + String.fromCharCode(a[i]);
    }
    return s;
}

// ==== byte array / hex ================================
/**
 * convert an array of bytes(Number) to hexadecimal string.<br/>
 * @name BAtohex
 * @function
 * @param {Array of Numbers} a array of bytes
 * @return {String} hexadecimal string
 */
function BAtohex(a) {
    var s = "";
    for (var i = 0; i < a.length; i++) {
	var hex1 = a[i].toString(16);
	if (hex1.length == 1) hex1 = "0" + hex1;
	s = s + hex1;
    }
    return s;
}

// ==== string / hex ================================
/**
 * convert a ASCII string to a hexadecimal string of ASCII codes.<br/>
 * NOTE: This can't be used for non ASCII characters.
 * @name stohex
 * @function
 * @param {s} s ASCII string
 * @return {String} hexadecimal string
 */
function stohex(s) {
    return BAtohex(stoBA(s));
}

// ==== string / base64 ================================
/**
 * convert a ASCII string to a Base64 encoded string.<br/>
 * NOTE: This can't be used for non ASCII characters.
 * @name stob64
 * @function
 * @param {s} s ASCII string
 * @return {String} Base64 encoded string
 */
function stob64(s) {
    return hex2b64(stohex(s));
}

// ==== string / base64url ================================
/**
 * convert a ASCII string to a Base64URL encoded string.<br/>
 * NOTE: This can't be used for non ASCII characters.
 * @name stob64u
 * @function
 * @param {s} s ASCII string
 * @return {String} Base64URL encoded string
 */
function stob64u(s) {
    return b64tob64u(hex2b64(stohex(s)));
}

/**
 * convert a Base64URL encoded string to a ASCII string.<br/>
 * NOTE: This can't be used for Base64URL encoded non ASCII characters.
 * @name b64utos
 * @function
 * @param {s} s Base64URL encoded string
 * @return {String} ASCII string
 */
function b64utos(s) {
    return BAtos(b64toBA(b64utob64(s)));
}

// ==== base64 / base64url ================================
/**
 * convert a Base64 encoded string to a Base64URL encoded string.<br/>
 * @name b64tob64u
 * @function
 * @param {String} s Base64 encoded string
 * @return {String} Base64URL encoded string
 * @example
 * b64tob64u("ab+c3f/==") &rarr; "ab-c3f_"
 */
function b64tob64u(s) {
    s = s.replace(/\=/g, "");
    s = s.replace(/\+/g, "-");
    s = s.replace(/\//g, "_");
    return s;
}

/**
 * convert a Base64URL encoded string to a Base64 encoded string.<br/>
 * @name b64utob64
 * @function
 * @param {String} s Base64URL encoded string
 * @return {String} Base64 encoded string
 * @example
 * b64utob64("ab-c3f_") &rarr; "ab+c3f/=="
 */
function b64utob64(s) {
    if (s.length % 4 == 2) s = s + "==";
    else if (s.length % 4 == 3) s = s + "=";
    s = s.replace(/-/g, "+");
    s = s.replace(/_/g, "/");
    return s;
}

// ==== hex / base64url ================================
/**
 * convert a hexadecimal string to a Base64URL encoded string.<br/>
 * @name hextob64u
 * @function
 * @param {String} s hexadecimal string
 * @return {String} Base64URL encoded string
 * @description
 * convert a hexadecimal string to a Base64URL encoded string.
 * NOTE: If leading "0" is omitted and odd number length for
 * hexadecimal leading "0" is automatically added.
 */
function hextob64u(s) {
    if (s.length % 2 == 1) s = "0" + s;
    return b64tob64u(hex2b64(s));
}

/**
 * convert a Base64URL encoded string to a hexadecimal string.<br/>
 * @name b64utohex
 * @function
 * @param {String} s Base64URL encoded string
 * @return {String} hexadecimal string
 */
function b64utohex(s) {
    return b64tohex(b64utob64(s));
}

// ==== utf8 / base64url ================================

/**
 * convert a UTF-8 encoded string including CJK or Latin to a Base64URL encoded string.<br/>
 * @name utf8tob64u
 * @function
 * @param {String} s UTF-8 encoded string
 * @return {String} Base64URL encoded string
 * @since 1.1
 * @example
 * utf8tob64u("") &rarr; "44GC"
 * utf8tob64u("aaa") &rarr; "YWFh"
 */

/**
 * convert a Base64URL encoded string to a UTF-8 encoded string including CJK or Latin.<br/>
 * @name b64utoutf8
 * @function
 * @param {String} s Base64URL encoded string
 * @return {String} UTF-8 encoded string
 * @since 1.1
 * @example
 * b64utoutf8("44GC") &rarr; ""
 * b64utoutf8("YWFh") &rarr; "aaa"
 */

var utf8tob64u, b64utoutf8;

if (typeof Buffer === 'function') {
  utf8tob64u = function (s) {
    return b64tob64u(Buffer.from(s, 'utf8').toString('base64'));
  };

  b64utoutf8 = function (s) {
    return Buffer.from(b64utob64(s), 'base64').toString('utf8');
  };
} else {
  utf8tob64u = function (s) {
    return hextob64u(uricmptohex(encodeURIComponentAll(s)));
  };

  b64utoutf8 = function (s) {
    return decodeURIComponent(hextouricmp(b64utohex(s)));
  };
}

// ==== utf8 / base64url ================================
/**
 * convert a UTF-8 encoded string including CJK or Latin to a Base64 encoded string.<br/>
 * @name utf8tob64
 * @function
 * @param {String} s UTF-8 encoded string
 * @return {String} Base64 encoded string
 * @since 1.1.1
 */
function utf8tob64(s) {
  return hex2b64(uricmptohex(encodeURIComponentAll(s)));
}

/**
 * convert a Base64 encoded string to a UTF-8 encoded string including CJK or Latin.<br/>
 * @name b64toutf8
 * @function
 * @param {String} s Base64 encoded string
 * @return {String} UTF-8 encoded string
 * @since 1.1.1
 */
function b64toutf8(s) {
  return decodeURIComponent(hextouricmp(b64tohex(s)));
}

// ==== utf8 / hex ================================
/**
 * convert a UTF-8 encoded string including CJK or Latin to a hexadecimal encoded string.<br/>
 * @name utf8tohex
 * @function
 * @param {String} s UTF-8 encoded string
 * @return {String} hexadecimal encoded string
 * @since 1.1.1
 */
function utf8tohex(s) {
  return uricmptohex(encodeURIComponentAll(s)).toLowerCase();
}

/**
 * convert a hexadecimal encoded string to a UTF-8 encoded string including CJK or Latin.<br/>
 * Note that when input is improper hexadecimal string as UTF-8 string, this function returns
 * 'null'.
 * @name hextoutf8
 * @function
 * @param {String} s hexadecimal encoded string
 * @return {String} UTF-8 encoded string or null
 * @since 1.1.1
 */
function hextoutf8(s) {
  try {
    return decodeURIComponent(hextouricmp(s));
  } catch(ex) {
    return null;
  }
}

// ==== iso8859-1 latin1 / utf8 ===================
/**
 * convert a hexadecimal ISO 8859-1 latin string to UTF-8 string<br/>
 * @name iso88591hextoutf8
 * @function
 * @param {String} h hexadecimal ISO 8859-1 latin string
 * @return {String} UTF-8 string
 * @since jsrsasign 10.5.12 base64x 1.1.25
 * @see utf8toiso88591hex
 *
 * @example
 * iso88591hextoutf8("41a9fa") &rarr; "A"
 */
function iso88591hextoutf8(h) {
    return hextoutf8(iso88591hextoutf8hex(h));
}

/**
 * convert UTF-8 string to a hexadecimal ISO 8859-1 latin string<br/>
 * @name utf8toiso88591hex
 * @function
 * @param {String} s hexadecimal ISO 8859-1 latin string
 * @return {String} UTF-8 string
 * @since jsrsasign 10.5.12 base64x 1.1.25
 * @see iso88591hextoutf8
 *
 * @example
 * utf8toiso88591hex("A") &rarr; "41a9fa"
 */
function utf8toiso88591hex(s) {
    return utf8hextoiso88591hex(utf8tohex(s));
}

/**
 * convert a hexadecimal ISO 8859-1 latin string to UTF-8 hexadecimal string<br/>
 * @name iso88591hextoutf8hex
 * @function
 * @param {String} h hexadecimal ISO 8859-1 latin string
 * @return {String} UTF-8 hexadecimal string
 * @since jsrsasign 10.5.12 base64x 1.1.25
 * @see iso88591hextoutf8
 * @see utf8hextoiso88591hex
 *
 * @example
 * iso88591hextoutf8hex("41a9fa") &rarr; "41c2a9c3ba"
 */
function iso88591hextoutf8hex(h) {
    var a = h.match(/.{1,2}/g);
    var a2 = [];
    for (var i = 0; i < a.length; i++) {
	var di = parseInt(a[i], 16);
	if (0xa1 <= di && di <= 0xbf) {
	    a2.push("c2");
	    a2.push(a[i]);
	} else if (0xc0 <= di && di <= 0xff) {
	    a2.push("c3");
	    a2.push((di - 64).toString(16));
	} else {
	    a2.push(a[i]);
	}
    }
    return a2.join('');
}

/**
 * convert UTF-8 string to a hexadecimal ISO 8859-1 latin string<br/>
 * @name utf8hextoiso88591hex
 * @function
 * @param {String} h hexadecimal UTF-8 string
 * @return {String} hexadecimal ISO 8859-1 latin string
 * @since jsrsasign 10.5.12 base64x 1.1.25
 * @see iso88591hextoutf8hex
 * @see utf8toiso88591hex
 *
 * @example
 * utf8hextoiso88591hex("41c2a9c3ba") &rarr; "41a9fa"
 */
function utf8hextoiso88591hex(h) {
    var a = h.match(/.{1,2}/g);
    var a2 = [];
    for (var i = 0; i < a.length; i++) {
	if (a[i] == 'c2') {
	    i++;
	    a2.push(a[i]);
	} else if (a[i] == 'c3') {
	    i++;
	    var ci = a[i];
	    var di = parseInt(a[i], 16) + 64;
	    a2.push(di.toString(16));
	} else {
	    a2.push(a[i]);
	}
    }
    return a2.join('');
}

// ==== rstr / hex ================================
/**
 * convert a hexadecimal encoded string to raw string including non printable characters.<br/>
 * @name hextorstr
 * @function
 * @param {String} s hexadecimal encoded string
 * @return {String} raw string
 * @since 1.1.2
 * @example
 * hextorstr("610061") &rarr; "a\x00a"
 */
function hextorstr(sHex) {
    var s = "";
    for (var i = 0; i < sHex.length - 1; i += 2) {
        s += String.fromCharCode(parseInt(sHex.substr(i, 2), 16));
    }
    return s;
}

/**
 * convert a raw string including non printable characters to hexadecimal encoded string.<br/>
 * @name rstrtohex
 * @function
 * @param {String} s raw string
 * @return {String} hexadecimal encoded string
 * @since 1.1.2
 * @example
 * rstrtohex("a\x00a") &rarr; "610061"
 */
function rstrtohex(s) {
    var result = "";
    for (var i = 0; i < s.length; i++) {
        result += ("0" + s.charCodeAt(i).toString(16)).slice(-2);
    }
    return result;
}

// ==== hex / b64nl =======================================

/**
 * convert a hexadecimal string to Base64 encoded string<br/>
 * @name hextob64
 * @function
 * @param {String} s hexadecimal string
 * @return {String} resulted Base64 encoded string
 * @since base64x 1.1.3
 * @description
 * This function converts from a hexadecimal string to Base64 encoded
 * string without new lines.
 * @example
 * hextob64("616161") &rarr; "YWFh"
 */
function hextob64(s) {
    return hex2b64(s);
}

/**
 * convert a hexadecimal string to Base64 encoded string with new lines<br/>
 * @name hextob64nl
 * @function
 * @param {String} s hexadecimal string
 * @return {String} resulted Base64 encoded string with new lines
 * @since base64x 1.1.3
 * @description
 * This function converts from a hexadecimal string to Base64 encoded
 * string with new lines for each 64 characters. This is useful for
 * PEM encoded file.
 * @example
 * hextob64nl("123456789012345678901234567890123456789012345678901234567890")
 * &rarr;
 * MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4 // new line
 * OTAxMjM0NTY3ODkwCg==
 */
function hextob64nl(s) {
    return foldnl(hextob64(s), 64);
}

/**
 * wrap string with new lines to fit in specified width<br/>
 * @name foldnl
 * @function
 * @param {string} s string
 * @param {number} n width
 * @return {string} wrapped string with new lines
 * @since jsrsasign 10.7.0 base64x 1.1.31
 * @description
 * This function wrap a string with new lines to fit in specified width.
 * @example
 * foldnl("1234567890", 6)
 * &rarr;
 * 123456
 * 7890
 */
function foldnl(s, n) {
    s = s.replace(new RegExp('(.{' + n + '})', 'g'), "$1\r\n");
    s = s.replace(/\s+$/, '');
    return s;
}

/**
 * convert a Base64 encoded string with new lines to a hexadecimal string<br/>
 * @name b64nltohex
 * @function
 * @param {String} s Base64 encoded string with new lines
 * @return {String} hexadecimal string
 * @since base64x 1.1.3
 * @description
 * This function converts from a Base64 encoded
 * string with new lines to a hexadecimal string.
 * This is useful to handle PEM encoded file.
 * This function removes any non-Base64 characters (i.e. not 0-9,A-Z,a-z,\,+,=)
 * including new line.
 * @example
 * hextob64nl(
 * "MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4\r\n" +
 * "OTAxMjM0NTY3ODkwCg==\r\n")
 * &rarr;
 * "123456789012345678901234567890123456789012345678901234567890"
 */
function b64nltohex(s) {
    var b64 = s.replace(/[^0-9A-Za-z\/+=]*/g, '');
    var hex = b64tohex(b64);
    return hex;
} 

// ==== b64 / pem =========================================
/**
 * get PEM string from Base64 string
 * @name b64topem
 * @function
 * @param {string} b64 Base64 string of PEM body
 * @param {string} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')
 * @return {string} PEM formatted string of input data
 * @since jsrasign 10.7.0 base64x 1.1.31
 * @description
 * This function converts a Base64 string to a PEM string with
 * a specified header. Its line break will be CRLF("\r\n").
 * @example
 * b64topem('YWFh', 'RSA PRIVATE KEY') &rarr;
 * -----BEGIN PRIVATE KEY-----
 * YWFh
 * -----END PRIVATE KEY-----
 */
function b64topem(b64, pemHeader) {
    return "-----BEGIN " + pemHeader + "-----\r\n" + 
	foldnl(b64, 64) +
        "\r\n-----END " + pemHeader + "-----\r\n";
}



// ==== hex / pem =========================================

/**
 * get PEM string from hexadecimal data and header string
 * @name hextopem
 * @function
 * @param {String} dataHex hexadecimal string of PEM body
 * @param {String} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')
 * @return {String} PEM formatted string of input data
 * @since jsrasign 7.2.1 base64x 1.1.12
 * @description
 * This function converts a hexadecimal string to a PEM string with
 * a specified header. Its line break will be CRLF("\r\n").
 * @example
 * hextopem('616161', 'RSA PRIVATE KEY') &rarr;
 * -----BEGIN PRIVATE KEY-----
 * YWFh
 * -----END PRIVATE KEY-----
 */
function hextopem(dataHex, pemHeader) {
    return "-----BEGIN " + pemHeader + "-----\r\n" + 
	foldnl(hextob64(dataHex), 64) +
        "\r\n-----END " + pemHeader + "-----\r\n";
}

/**
 * get hexacedimal string from PEM format data<br/>
 * @name pemtohex
 * @function
 * @param {String} s PEM formatted string
 * @param {String} sHead PEM header string without BEGIN/END(OPTION)
 * @return {String} hexadecimal string data of PEM contents
 * @since jsrsasign 7.2.1 base64x 1.1.12
 *
 * @description
 * This static method gets a hexacedimal string of contents 
 * from PEM format data. You can explicitly specify PEM header 
 * by sHead argument. 
 * Any space characters such as white space or new line
 * will be omitted.<br/>
 * NOTE: Now {@link KEYUTIL.getHexFromPEM} and {@link X509.pemToHex}
 * have been deprecated since jsrsasign 7.2.1. <br/>
 * Please use this method instead.
 * NOTE2: From jsrsasign 8.0.14 this can process multi
 * "BEGIN...END" section such as "EC PRIVATE KEY" with "EC PARAMETERS".<br/>
 *
 * @example
 * pemtohex("-----BEGIN PUBLIC KEY...") &rarr; "3082..."
 * pemtohex("-----BEGIN CERTIFICATE...", "CERTIFICATE") &rarr; "3082..."
 * pemtohex(" \r\n-----BEGIN DSA PRIVATE KEY...") &rarr; "3082..."
 * pemtohex("-----BEGIN EC PARAMETERS...----BEGIN EC PRIVATE KEY...." &rarr; "3082..."
 */
function pemtohex(s, sHead) {
    if (s.indexOf("-----BEGIN ") == -1)
        throw new Error("can't find PEM header");

    if (sHead !== undefined) {
        s = s.replace(new RegExp('^[^]*-----BEGIN ' + sHead + '-----'), '');
        s = s.replace(new RegExp('-----END ' + sHead + '-----[^]*$'), '');
    } else {
        s = s.replace(/^[^]*-----BEGIN [^-]+-----/, '');
        s = s.replace(/-----END [^-]+-----[^]*$/, '');
    }
    return b64nltohex(s);
}

/**
 * get Base64 string from PEM format data<br/>
 * @name pemtob64
 * @function
 * @param {string} s PEM formatted string
 * @return {string} Base64 string or null
 * @since jsrsasign 10.7.0 base64x 1.1.31
 *
 * @description
 * This static method gets a Base64 string of contents 
 * from PEM format data.
 * When s is not PEM data, it returns null.
 *
 * @example
 * pemtohex("-----BEGIN CERTIFICATE...", "CERTIFICATE") &rarr; "MIIBvTCC..."
 */
function pemtob64(s) {
    if (s.indexOf("-----BEGIN ") == -1 ||
        s.indexOf("-----END ") == -1 ) return null;
    s = s.replace(/^[\s\S]*?-----BEGIN [^-]+-----/m, '');
    s = s.replace(/-----END [\s\S]+$/m, '');
    s = s.replace(/\s+/g, '');
    return (s.match(/^[0-9a-zA-Z+/=]+$/)) ? s : null;
}

// ==== hex / ArrayBuffer =================================

/**
 * convert a hexadecimal string to an ArrayBuffer<br/>
 * @name hextoArrayBuffer
 * @function
 * @param {String} hex hexadecimal string
 * @return {ArrayBuffer} ArrayBuffer
 * @since jsrsasign 6.1.4 base64x 1.1.8
 * @description
 * This function converts from a hexadecimal string to an ArrayBuffer.
 * @example
 * hextoArrayBuffer("fffa01") &rarr; ArrayBuffer of [255, 250, 1]
 */
function hextoArrayBuffer(hex) {
    if (hex.length % 2 != 0) throw "input is not even length";
    if (hex.match(/^[0-9A-Fa-f]+$/) == null) throw "input is not hexadecimal";

    var buffer = new ArrayBuffer(hex.length / 2);
    var view = new DataView(buffer);

    for (var i = 0; i < hex.length / 2; i++) {
	view.setUint8(i, parseInt(hex.substr(i * 2, 2), 16));
    }

    return buffer;
}

// ==== ArrayBuffer / hex =================================

/**
 * convert an ArrayBuffer to a hexadecimal string<br/>
 * @name ArrayBuffertohex
 * @function
 * @param {ArrayBuffer} buffer ArrayBuffer
 * @return {String} hexadecimal string
 * @since jsrsasign 6.1.4 base64x 1.1.8
 * @description
 * This function converts from an ArrayBuffer to a hexadecimal string.
 * @example
 * var buffer = new ArrayBuffer(3);
 * var view = new DataView(buffer);
 * view.setUint8(0, 0xfa);
 * view.setUint8(1, 0xfb);
 * view.setUint8(2, 0x01);
 * ArrayBuffertohex(buffer) &rarr; "fafb01"
 */
function ArrayBuffertohex(buffer) {
    var hex = "";
    var view = new DataView(buffer);

    for (var i = 0; i < buffer.byteLength; i++) {
	hex += ("00" + view.getUint8(i).toString(16)).slice(-2);
    }

    return hex;
}

// ==== zulu / int =================================
/**
 * GeneralizedTime or UTCTime string to milliseconds from Unix origin<br>
 * @name zulutomsec
 * @function
 * @param {String} s GeneralizedTime or UTCTime string (ex. 20170412235959.384Z)
 * @return {Number} milliseconds from Unix origin time (i.e. Jan 1, 1970 0:00:00 UTC)
 * @since jsrsasign 7.1.3 base64x 1.1.9
 * @description
 * This function converts from GeneralizedTime string (i.e. YYYYMMDDHHmmSSZ) or
 * UTCTime string (i.e. YYMMDDHHmmSSZ) to milliseconds from Unix origin time
 * (i.e. Jan 1 1970 0:00:00 UTC). 
 * Argument string may have fraction of seconds and
 * its length is one or more digits such as "20170410235959.1234567Z".
 * As for UTCTime, if year "YY" is equal or less than 49 then it is 20YY.
 * If year "YY" is equal or greater than 50 then it is 19YY.
 * @example
 * zulutomsec(  "071231235959Z")       &rarr; 1199145599000 #Mon, 31 Dec 2007 23:59:59 GMT
 * zulutomsec(  "071231235959.1Z")     &rarr; 1199145599100 #Mon, 31 Dec 2007 23:59:59 GMT
 * zulutomsec(  "071231235959.12345Z") &rarr; 1199145599123 #Mon, 31 Dec 2007 23:59:59 GMT
 * zulutomsec("20071231235959Z")       &rarr; 1199145599000 #Mon, 31 Dec 2007 23:59:59 GMT
 * zulutomsec(  "931231235959Z")       &rarr; -410227201000 #Mon, 31 Dec 1956 23:59:59 GMT
 */
function zulutomsec(s) {
    var year, month, day, hour, min, sec, msec, d;
    var sYear, sFrac, sMsec, matchResult;

    s = timetogen(s);
    matchResult = s.match(/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/);

    if (matchResult) {
	year = parseInt(matchResult[1]);
	month = parseInt(matchResult[2]) - 1;
	day = parseInt(matchResult[3]);
	hour = parseInt(matchResult[4]);
	min = parseInt(matchResult[5]);
	sec = parseInt(matchResult[6]);
	msec = 0;

	sFrac = matchResult[7];
	if (sFrac !== "") {
	    sMsec = (sFrac.substr(1) + "00").substr(0, 3); // .12 -> 012
	    msec = parseInt(sMsec);
	}
	return Date.UTC(year, month, day, hour, min, sec, msec);
    }
    throw new Error("unsupported zulu format: " + s);
}

/**
 * Unix origin milliseconds GeneralizedTime string<br>
 * @name msectozulu
 * @function
 * @param {number} n milliseconds from Unix origin time (i.e. Jan 1, 1970 0:00:00 UTC)
 * @return {string} GeneralizedTime string (ex. 20170412235959.384Z)
 * @since jsrsasign 10.8.0 base64x 1.1.31
 *
 * @description
 * This function converts from milliseconds of Unix origin time (ex. 1199145599000
 * for 31 Dec 2007 23:59:59 GMT) to GeneralizedTime string (i.e. YYYYMMDDHHmmSSZ).
 * The result string may have a fraction of second.
 *
 * @example
 * msectozulu(1199145599000) &rarr; "20071231235959Z"       #Mon, 31 Dec 2007 23:59:59     GMT
 * msectozulu(1199145599100) &rarr; "20071231235959.1Z"     #Mon, 31 Dec 2007 23:59:59.1   GMT
 * msectozulu(1199145599123) &rarr; "20071231235959.123Z"   #Mon, 31 Dec 2007 23:59:59.123 GMT
 */
function msectozulu(n) {
    var d = new Date(n),
        year = ("0000" + d.getUTCFullYear()).slice(-4),
        mon =  ("00" + (d.getUTCMonth() + 1)).slice(-2),
        day =  ("00" + d.getUTCDate()).slice(-2),
        hour = ("00" + d.getUTCHours()).slice(-2),
        min =  ("00" + d.getUTCMinutes()).slice(-2),
        sec =  ("00" + d.getUTCSeconds()).slice(-2),
	msec = ("000" + d.getUTCMilliseconds()).slice(-3);
    msec = msec.replace(/0+$/, '');
    msec = (msec != '') ? '.' + msec : msec;
    return year + mon + day + hour + min + sec + msec + "Z";
}

/**
 * GeneralizedTime or UTCTime string to seconds from Unix origin<br>
 * @name zulutosec
 * @function
 * @param {String} s GeneralizedTime or UTCTime string (ex. 20170412235959.384Z)
 * @return {Number} seconds from Unix origin time (i.e. Jan 1, 1970 0:00:00 UTC)
 * @since jsrsasign 7.1.3 base64x 1.1.9
 * @description
 * This function converts from GeneralizedTime string (i.e. YYYYMMDDHHmmSSZ) or
 * UTCTime string (i.e. YYMMDDHHmmSSZ) to seconds from Unix origin time
 * (i.e. Jan 1 1970 0:00:00 UTC). Argument string may have fraction of seconds 
 * however result value will be omitted.
 * As for UTCTime, if year "YY" is equal or less than 49 then it is 20YY.
 * If year "YY" is equal or greater than 50 then it is 19YY.
 * @example
 * zulutosec(  "071231235959Z")       &rarr; 1199145599 #Mon, 31 Dec 2007 23:59:59 GMT
 * zulutosec(  "071231235959.1Z")     &rarr; 1199145599 #Mon, 31 Dec 2007 23:59:59 GMT
 * zulutosec("20071231235959Z")       &rarr; 1199145599 #Mon, 31 Dec 2007 23:59:59 GMT
 */
function zulutosec(s) {
    return Math.round(zulutomsec(s) / 1000.0);
}

// ==== zulu / Date =================================

/**
 * GeneralizedTime or UTCTime string to Date object<br>
 * @name zulutodate
 * @function
 * @param {String} s GeneralizedTime or UTCTime string (ex. 20170412235959.384Z)
 * @return {Date} Date object for specified time
 * @since jsrsasign 7.1.3 base64x 1.1.9
 * @description
 * This function converts from GeneralizedTime string (i.e. YYYYMMDDHHmmSSZ) or
 * UTCTime string (i.e. YYMMDDHHmmSSZ) to Date object.
 * Argument string may have fraction of seconds and
 * its length is one or more digits such as "20170410235959.1234567Z".
 * As for UTCTime, if year "YY" is equal or less than 49 then it is 20YY.
 * If year "YY" is equal or greater than 50 then it is 19YY.
 * @example
 * zulutodate(  "071231235959Z").toUTCString()   &rarr; "Mon, 31 Dec 2007 23:59:59 GMT"
 * zulutodate(  "071231235959.1Z").toUTCString() &rarr; "Mon, 31 Dec 2007 23:59:59 GMT"
 * zulutodate("20071231235959Z").toUTCString()   &rarr; "Mon, 31 Dec 2007 23:59:59 GMT"
 * zulutodate(  "071231235959.34").getMilliseconds() &rarr; 340
 */
function zulutodate(s) {
    return new Date(zulutomsec(s));
}

/**
 * Date object to zulu time string<br>
 * @name datetozulu
 * @function
 * @param {Date} d Date object for specified time
 * @param {Boolean} flagUTCTime if this is true year will be YY otherwise YYYY
 * @param {Boolean} flagMilli if this is true result concludes milliseconds
 * @return {String} GeneralizedTime or UTCTime string (ex. 20170412235959.384Z)
 * @since jsrsasign 7.2.0 base64x 1.1.11
 * @description
 * This function converts from Date object to GeneralizedTime string (i.e. YYYYMMDDHHmmSSZ) or
 * UTCTime string (i.e. YYMMDDHHmmSSZ).
 * As for UTCTime, if year "YY" is equal or less than 49 then it is 20YY.
 * If year "YY" is equal or greater than 50 then it is 19YY.
 * If flagMilli is true its result concludes milliseconds such like
 * "20170520235959.42Z". 
 * @example
 * d = new Date(Date.UTC(2017,4,20,23,59,59,670));
 * datetozulu(d) &rarr; "20170520235959Z"
 * datetozulu(d, true) &rarr; "170520235959Z"
 * datetozulu(d, false, true) &rarr; "20170520235959.67Z"
 */
function datetozulu(d, flagUTCTime, flagMilli) {
    var s;
    var year = d.getUTCFullYear();
    if (flagUTCTime) {
	if (year < 1950 || 2049 < year) 
	    throw "not proper year for UTCTime: " + year;
	s = ("" + year).slice(-2);
    } else {
	s = ("000" + year).slice(-4);
    }
    s += ("0" + (d.getUTCMonth() + 1)).slice(-2);
    s += ("0" + d.getUTCDate()).slice(-2);
    s += ("0" + d.getUTCHours()).slice(-2);
    s += ("0" + d.getUTCMinutes()).slice(-2);
    s += ("0" + d.getUTCSeconds()).slice(-2);
    if (flagMilli) {
	var milli = d.getUTCMilliseconds();
	if (milli !== 0) {
	    milli = ("00" + milli).slice(-3);
	    milli = milli.replace(/0+$/g, "");
	    s += "." + milli;
	}
    }
    s += "Z";
    return s;
}

/**
 * GeneralizedTime or UTCTime string to GeneralizedTime<br>
 * @name timetogen
 * @function
 * @param {string} s GeneralizedTime or UTCTime string (ex. 20170412235959.384Z)
 * @return {string} GeneralizedTime
 * @since jsrsasign 10.7.0 base64x 1.1.31
 * @description
 * This function converts UTCTime string (i.e. YYMMDDHHmmSSZ ) to 
 * GeneralizedTime (YYYYMMDDHHmmSSZ) when the argument 's' is UTCTime. 
 * Argument string may have fraction of seconds and
 * its length is one or more digits such as "170410235959.1234567Z".
 * As for UTCTime, if year "YY" is equal or less than 49 then it is 20YY.
 * If year "YY" is equal or greater than 50 then it is 19YY.
 * @example
 * timetogen(  "071231235959Z") &rarr; "20071231235959Z"
 * timetogen(  "971231235959Z") &rarr; "19971231235959Z"
 * timetogen("20071231235959Z") &rarr; "20071231235959Z"
 * timetogen(  "971231235959.123Z") &rarr; "19971231235959.123Z"
 */
function timetogen(s) {
    if (s.match(/^[0-9]{12}Z$/) || s.match(/^[0-9]{12}[.][0-9]*Z$/)) {
	return (s.match(/^[0-4]/)) ? "20" + s : "19" + s;
    }
    return s;
}

// ==== URIComponent / hex ================================
/**
 * convert a URLComponent string such like "%67%68" to a hexadecimal string.<br/>
 * @name uricmptohex
 * @function
 * @param {String} s URIComponent string such like "%67%68"
 * @return {String} hexadecimal string
 * @since 1.1
 */
function uricmptohex(s) {
  return s.replace(/%/g, "");
}

/**
 * convert a hexadecimal string to a URLComponent string such like "%67%68".<br/>
 * @name hextouricmp
 * @function
 * @param {String} s hexadecimal string
 * @return {String} URIComponent string such like "%67%68"
 * @since 1.1
 */
function hextouricmp(s) {
  return s.replace(/(..)/g, "%$1");
}

// ==== hex / ipv6 =================================

/**
 * convert any IPv6 address to a 16 byte hexadecimal string
 * @function
 * @param s string of IPv6 address
 * @return {String} 16 byte hexadecimal string of IPv6 address
 * @description
 * This function converts any IPv6 address representation string
 * to a 16 byte hexadecimal string of address.
 * @example
 * 
 */
function ipv6tohex(s) {
  var msgMalformedAddress = "malformed IPv6 address";
  if (! s.match(/^[0-9A-Fa-f:]+$/))
    throw msgMalformedAddress;

  // 1. downcase
  s = s.toLowerCase();

  // 2. expand ::
  var num_colon = s.split(':').length - 1;
  if (num_colon < 2) throw msgMalformedAddress;
  var colon_replacer = ':'.repeat(7 - num_colon + 2);
  s = s.replace('::', colon_replacer);

  // 3. fill zero
  var a = s.split(':');
  if (a.length != 8) throw msgMalformedAddress;
  for (var i = 0; i < 8; i++) {
    a[i] = ("0000" + a[i]).slice(-4);
  }
  return a.join('');
}

/**
 * convert a 16 byte hexadecimal string to RFC 5952 canonicalized IPv6 address<br/>
 * @name hextoipv6
 * @function
 * @param {String} s hexadecimal string of 16 byte IPv6 address
 * @return {String} IPv6 address string canonicalized by RFC 5952
 * @since jsrsasign 8.0.10 base64x 1.1.13
 * @description
 * This function converts a 16 byte hexadecimal string to 
 * <a href="https://tools.ietf.org/html/rfc5952">RFC 5952</a>
 * canonicalized IPv6 address string.
 * @example
 * hextoipv6("871020010db8000000000000000000000004") &rarr "2001:db8::4"
 * hextoipv6("871020010db8000000000000000000") &rarr raise exception
 * hextoipv6("xyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyz") &rarr raise exception
 */
function hextoipv6(s) {
    if (! s.match(/^[0-9A-Fa-f]{32}$/))
	throw new Error("malformed IPv6 address: " + s);

    // 1. downcase
    s = s.toLowerCase();

    // 2. split 4 > ["0123", "00a4", "0000", ..., "ffff"]
    var a = s.match(/.{1,4}/g);

    // 3. trim leading 0 for items and join > "123:a4:0:...:ffff"
    a = a.map(function(s){return s.replace(/^0+/, '')});
    a = a.map(function(s){return s == '' ? '0' : s});
    s = ':' + a.join(':') + ':';

    // 4. find shrinkable candidates :0:0:..:0:
    var aZero = s.match(/:(0:){2,}/g);

    // 5. no shrinkable
    if (aZero == null) return s.slice(1, -1);

    // 6. fix max length zero(:0:...:0:)
    var sMaxZero = aZero.sort().slice(-1)[0];

    // 7. replace shrinked
    s = s.replace(sMaxZero.substr(0, sMaxZero.length - 1), ':');

    // 8. trim leading ':' if not '::'
    if (s.substr(0, 2) != '::') s = s.substr(1);

    // 9. trim tail ':' if not '::'
    if (s.substr(-2, 2) != '::') s = s.substr(0, s.length - 1);

    return s;
}

// ==== hex / ip =================================

/**
 * convert a hexadecimal string to IP addresss<br/>
 * @name hextoip
 * @function
 * @param {String} s hexadecimal string of IP address
 * @return {String} IP address string
 * @since jsrsasign 8.0.10 base64x 1.1.13
 * @see hextoipv6
 * @see iptohex
 *
 * @description
 * This function converts a hexadecimal string of IPv4 or 
 * IPv6 address to IPv4 or IPv6 address string.
 * If byte length is not 4 nor 16, this returns a
 * hexadecimal string without conversion.
 * <br/>
 * NOTE: From jsrsasign 10.5.17, CIDR subnet mask notation also supported.
 *
 * @example
 * hextoip("c0a80101") &rarr; "192.168.1.1"
 * hextoip("871020010db8000000000000000000000004") &rarr "2001:db8::4"
 * hextoip("c0a80100ffffff00") &rarr; "192.168.1.0/24"
 * hextoip("c0a801010203") &rarr; "c0a801010203" // wrong 6 bytes
 * hextoip("zzz")) &rarr; raise exception because of not hexadecimal
 */
function hextoip(s) {
    var malformedErr = new Error("malformed hex value");
    if (! s.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/))
	throw malformedErr;
    if (s.length == 8) { // ipv4
	var ip;
	try {
	    ip = parseInt(s.substr(0, 2), 16) + "." +
 		 parseInt(s.substr(2, 2), 16) + "." +
		 parseInt(s.substr(4, 2), 16) + "." +
		 parseInt(s.substr(6, 2), 16);
	    return ip;
	} catch (ex) {
	    throw malformedErr;
	}
  } else if (s.length == 16) {
      try {
	  return hextoip(s.substr(0, 8)) + "/" + ipprefixlen(s.substr(8));
      } catch (ex) {
	  throw malformedErr;
      }
  } else if (s.length == 32) {
      return hextoipv6(s);
  } else if (s.length == 64) {
      try {
	  return hextoipv6(s.substr(0, 32)) + "/" + ipprefixlen(s.substr(32));
      } catch (ex) {
	  throw malformedErr;
      }
      return 
  } else {
    return s;
  }
}

/*
 * convert subnet mask hex to ip address prefix length<br/>
 * @name ipprefixlen
 * @param {string} hMask hexadecimal string of ipv4/6 subnet mask (ex. "ffffff00" for v4 class C)
 * @return {nummber} ip address prefix length (ex. 24 for IPv4 class C)
 */
function ipprefixlen(hMask) {
    var malformedErr = new Error("malformed mask");
    var bMask;
    try {
	bMask = new BigInteger(hMask, 16).toString(2);
    } catch(ex) {
	throw malformedErr;
    }
    if (! bMask.match(/^1*0*$/)) throw malformedErr;
    return bMask.replace(/0+$/, '').length;
}

/**
 * convert IPv4/v6 addresss to a hexadecimal string<br/>
 * @name iptohex
 * @function
 * @param {String} s IPv4/v6 address string
 * @return {String} hexadecimal string of IP address
 * @since jsrsasign 8.0.12 base64x 1.1.14
 * @see hextoip
 * @see ipv6tohex
 *
 * @description
 * This function converts IPv4 or IPv6 address string to
 * a hexadecimal string of IPv4 or IPv6 address.
 * <br/>
 * NOTE: From jsrsasign 10.5.17, CIDR net mask notation also supported.
 *
 * @example
 * iptohex("192.168.1.1") &rarr; "c0a80101"
 * iptohex("2001:db8::4") &rarr; "871020010db8000000000000000000000004"
 * iptohex("192.168.1.1/24") &rarr; "c0a80101ffffff00"
 * iptohex("2001:db8::/120") &rarr; "871020010db8000000000000000000000000ffffffffffffffffffffffffffffffffff00"
 * iptohex("zzz")) &rarr; raise exception
 */
function iptohex(s) {
    var malformedErr = new Error("malformed IP address");
    s = s.toLowerCase(s);

    if (! s.match(/^[0-9a-f.:/]+$/) ) throw malformedErr;

    if (s.match(/^[0-9.]+$/)) {
	var a = s.split(".");
	if (a.length !== 4) throw malformedErr;
	var hex = "";
	try {
	    for (var i = 0; i < 4; i++) {
		var d = parseInt(a[i]);
		hex += ("0" + d.toString(16)).slice(-2);
	    }
	    return hex;
	} catch(ex) {
	    throw malformedErr;
	}
    } else if (s.match(/^[0-9.]+\/[0-9]+$/)) {
	var aItem = s.split("/");
	return iptohex(aItem[0]) + ipnetmask(parseInt(aItem[1]), 32);
    } else if (s.match(/^[0-9a-f:]+$/) && s.indexOf(":") !== -1) {
	return ipv6tohex(s);
    } else if (s.match(/^[0-9a-f:]+\/[0-9]+$/) && s.indexOf(":") !== -1) {
	var aItem = s.split("/");
	return ipv6tohex(aItem[0]) + ipnetmask(parseInt(aItem[1]), 128);
    } else {
	throw malformedErr;
    }
}

/*
 * convert ip prefix length to net mask octets<br/>
 * @param {number} prefixlen ip prefix length value (ex. 24 for IPv4 class C)
 * @param {number} len ip address length (ex. 32 for IPv4 and 128 for IPv6)
 * @return {string} hexadecimal string of net mask octets
 * @example
 * ipnetmask(24, 32) &rarr; "ffffff00" 
 * ipnetmask(120, 128) &rarr; "ffffffffffffffffffffffffffffff00"
 */
function ipnetmask(prefixlen, len) {
    if (len == 32 && prefixlen == 0) return "00000000"; // v4
    if (len == 128 && prefixlen == 0) return "00000000000000000000000000000000"; // v6
    var b = Array(prefixlen + 1).join("1") + Array(len - prefixlen + 1).join("0");
    return new BigInteger(b, 2).toString(16);
}

// ==== ucs2hex / utf8 ==============================

/**
 * convert UCS-2 hexadecimal stirng to UTF-8 string<br/>
 * @name ucs2hextoutf8
 * @function
 * @param {String} s hexadecimal string of UCS-2 string (ex. "0066")
 * @return {String} UTF-8 string
 * @since jsrsasign 10.1.13 base64x 1.1.20
 * @description
 * This function converts hexadecimal value of UCS-2 string to 
 * UTF-8 string.
 * @example
 * ucs2hextoutf8("006600fc0072") &rarr "fr"
 */
/*
See: http://nomenclator.la.coocan.jp/unicode/ucs_utf.htm
UCS-2 to UTF-8
UCS-2 code point | UCS-2 bytes       | UTF-8 bytes
U+0000 .. U+007F | 00000000-0xxxxxxx | 0xxxxxxx (1 byte)
U+0080 .. U+07FF | 00000xxx-xxyyyyyy | 110xxxxx 10yyyyyy (2 byte)
U+0800 .. U+FFFF | xxxxyyyy-yyzzzzzz | 1110xxxx 10yyyyyy 10zzzzzz (3 byte)
 */
function ucs2hextoutf8(s) {
    function _conv(s) {
	var i1 = parseInt(s.substr(0, 2), 16);
	var i2 = parseInt(s.substr(2), 16);
	if (i1 == 0 & i2 < 0x80) { // 1 byte
	    return String.fromCharCode(i2);
	}
	if (i1 < 8) { // 2 bytes
	    var u1 = 0xc0 | ((i1 & 0x07) << 3) | ((i2 & 0xc0) >> 6);
	    var u2 = 0x80 | (i2 & 0x3f);
	    return hextoutf8(u1.toString(16) + u2.toString(16));
	}
	// 3 bytes
	var u1 = 0xe0 | ((i1 & 0xf0) >> 4);
	var u2 = 0x80 | ((i1 & 0x0f) << 2) | ((i2 & 0xc0) >> 6);
	var u3 = 0x80 | (i2 & 0x3f);
	return hextoutf8(u1.toString(16) + u2.toString(16) + u3.toString(16));
    }
    var a = s.match(/.{4}/g);
    var a2 = a.map(_conv);
    return a2.join("");
}

// ==== URIComponent ================================
/**
 * convert UTFa hexadecimal string to a URLComponent string such like "%67%68".<br/>
 * Note that these "<code>0-9A-Za-z!'()*-._~</code>" characters will not
 * converted to "%xx" format by builtin 'encodeURIComponent()' function.
 * However this 'encodeURIComponentAll()' function will convert 
 * all of characters into "%xx" format.
 * @name encodeURIComponentAll
 * @function
 * @param {String} s hexadecimal string
 * @return {String} URIComponent string such like "%67%68"
 * @since 1.1
 */
function encodeURIComponentAll(u8) {
  var s = encodeURIComponent(u8);
  var s2 = "";
  for (var i = 0; i < s.length; i++) {
    if (s[i] == "%") {
      s2 = s2 + s.substr(i, 3);
      i = i + 2;
    } else {
      s2 = s2 + "%" + stohex(s[i]);
    }
  }
  return s2;
}

// ==== new lines ================================
/**
 * convert all DOS new line("\r\n") to UNIX new line("\n") in 
 * a String "s".
 * @name newline_toUnix
 * @function
 * @param {String} s string 
 * @return {String} converted string
 */
function newline_toUnix(s) {
    s = s.replace(/\r\n/mg, "\n");
    return s;
}

/**
 * convert all UNIX new line("\r\n") to DOS new line("\n") in 
 * a String "s".
 * @name newline_toDos
 * @function
 * @param {String} s string 
 * @return {String} converted string
 */
function newline_toDos(s) {
    s = s.replace(/\r\n/mg, "\n");
    s = s.replace(/\n/mg, "\r\n");
    return s;
}

// ==== string type checker ===================

/**
 * check whether a string is an integer string or not<br/>
 * @name isInteger
 * @memberOf KJUR.lang.String
 * @function
 * @static
 * @param {String} s input string
 * @return {Boolean} true if a string "s" is an integer string otherwise false
 * @since base64x 1.1.7 jsrsasign 5.0.13
 * @example
 * KJUR.lang.String.isInteger("12345") &rarr; true
 * KJUR.lang.String.isInteger("123ab") &rarr; false
 */
KJUR.lang.String.isInteger = function(s) {
    if (s.match(/^[0-9]+$/)) {
	return true;
    } else if (s.match(/^-[0-9]+$/)) {
	return true;
    } else {
	return false;
    }
};

/**
 * check whether a string is an hexadecimal string or not (DEPRECATED)<br/>
 * @name isHex
 * @memberOf KJUR.lang.String
 * @function
 * @static
 * @param {String} s input string
 * @return {Boolean} true if a string "s" is an hexadecimal string otherwise false
 * @since base64x 1.1.7 jsrsasign 5.0.13
 * @deprecated from 10.0.6. please use {@link ishex}
 * @see ishex
 * @example
 * KJUR.lang.String.isHex("1234") &rarr; true
 * KJUR.lang.String.isHex("12ab") &rarr; true
 * KJUR.lang.String.isHex("12AB") &rarr; true
 * KJUR.lang.String.isHex("12ZY") &rarr; false
 * KJUR.lang.String.isHex("121") &rarr; false -- odd length
 */
KJUR.lang.String.isHex = function(s) {
    return ishex(s);
};

/**
 * check whether a string is an hexadecimal string or not<br/>
 * @name ishex
 * @function
 * @static
 * @param {String} s input string
 * @return {Boolean} true if a string "s" is an hexadecimal string otherwise false
 * @since base64x 1.1.7 jsrsasign 5.0.13
 * @example
 * ishex("1234") &rarr; true
 * ishex("12ab") &rarr; true
 * ishex("12AB") &rarr; true
 * ishex("12ZY") &rarr; false
 * ishex("121") &rarr; false -- odd length
 */
function ishex(s) {
    if (s.length % 2 == 0 &&
	(s.match(/^[0-9a-f]+$/) || s.match(/^[0-9A-F]+$/))) {
	return true;
    } else {
	return false;
    }
};

/**
 * check whether a string is a base64 encoded string or not<br/>
 * Input string can conclude new lines or space characters.
 * @name isBase64
 * @memberOf KJUR.lang.String
 * @function
 * @static
 * @param {String} s input string
 * @return {Boolean} true if a string "s" is a base64 encoded string otherwise false
 * @since base64x 1.1.7 jsrsasign 5.0.13
 * @example
 * KJUR.lang.String.isBase64("YWE=") &rarr; true
 * KJUR.lang.String.isBase64("YW_=") &rarr; false
 * KJUR.lang.String.isBase64("YWE") &rarr; false -- length shall be multiples of 4
 */
KJUR.lang.String.isBase64 = function(s) {
    s = s.replace(/\s+/g, "");
    if (s.match(/^[0-9A-Za-z+\/]+={0,3}$/) && s.length % 4 == 0) {
	return true;
    } else {
	return false;
    }
};

/**
 * check whether a string is a base64url encoded string or not<br/>
 * Input string can conclude new lines or space characters.
 * @name isBase64URL
 * @memberOf KJUR.lang.String
 * @function
 * @static
 * @param {String} s input string
 * @return {Boolean} true if a string "s" is a base64url encoded string otherwise false
 * @since base64x 1.1.7 jsrsasign 5.0.13
 * @example
 * KJUR.lang.String.isBase64URL("YWE") &rarr; true
 * KJUR.lang.String.isBase64URL("YW-") &rarr; true
 * KJUR.lang.String.isBase64URL("YW+") &rarr; false
 */
KJUR.lang.String.isBase64URL = function(s) {
    if (s.match(/[+/=]/)) return false;
    s = b64utob64(s);
    return KJUR.lang.String.isBase64(s);
};


/**
 * check whether a string is a base64url encoded string and dot or not<br/>
 * Input string can conclude new lines or space characters.
 * @name isBase64URLDot
 * @function
 * @static
 * @param {String} s input string
 * @return {Boolean} true if a string "s" is a base64url encoded string and dot otherwise false
 * @since base64x 1.1.30 jsrsasign 10.5.25
 * @example
 * isBase64URLDot("YWE") &rarr; true
 * isBase64URLDot("YWE.YWE.YWE") &rarr; true
 * isBase64URLDot("YW-") &rarr; true
 * isBase64URLDot("YW+") &rarr; false
 */
function isBase64URLDot(s) {
    if (s.match(/^[0-9A-Za-z-_.]+$/)) return true;
    return false;
}

/**
 * check whether a string is a string of integer array or not<br/>
 * Input string can conclude new lines or space characters.
 * @name isIntegerArray
 * @memberOf KJUR.lang.String
 * @function
 * @static
 * @param {String} s input string
 * @return {Boolean} true if a string "s" is a string of integer array otherwise false
 * @since base64x 1.1.7 jsrsasign 5.0.13
 * @example
 * KJUR.lang.String.isIntegerArray("[1,2,3]") &rarr; true
 * KJUR.lang.String.isIntegerArray("  [1, 2, 3  ] ") &rarr; true
 * KJUR.lang.String.isIntegerArray("[a,2]") &rarr; false
 */
KJUR.lang.String.isIntegerArray = function(s) {
    s = s.replace(/\s+/g, "");
    if (s.match(/^\[[0-9,]+\]$/)) {
	return true;
    } else {
	return false;
    }
};

/**
 * check whether a string consists of PrintableString characters<br/>
 * @name isPrintable
 * @memberOf KJUR.lang.String
 * @function
 * @static
 * @param {String} s input string
 * @return {Boolean} true if a string "s" consists of PrintableString characters
 * @since jsrsasign 9.0.0 base64x 1.1.16
 * A PrintableString consists of following characters
 * <pre>
 * 0-9A-Za-z '()+,-./:=?
 * </pre>
 * This method returns false when other characters than above.
 * Otherwise it returns true.
 * @example
 * KJUR.lang.String.isPrintable("abc") &rarr; true
 * KJUR.lang.String.isPrintable("abc@") &rarr; false
 * KJUR.lang.String.isPrintable("") &rarr; false
 */
KJUR.lang.String.isPrintable = function(s) {
    if (s.match(/^[0-9A-Za-z '()+,-./:=?]*$/) !== null) return true;
    return false;
};

/**
 * check whether a string consists of IAString characters<br/>
 * @name isIA5
 * @memberOf KJUR.lang.String
 * @function
 * @static
 * @param {String} s input string
 * @return {Boolean} true if a string "s" consists of IA5String characters
 * @since jsrsasign 9.0.0 base64x 1.1.16
 * A IA5String consists of following characters
 * <pre>
 * %x00-21/%x23-7F (i.e. ASCII characters excludes double quote(%x22)
 * </pre>
 * This method returns false when other characters than above.
 * Otherwise it returns true.
 * @example
 * KJUR.lang.String.isIA5("abc") &rarr; true
 * KJUR.lang.String.isIA5('"abc"') &rarr; false
 * KJUR.lang.String.isIA5("") &rarr; false
 */
KJUR.lang.String.isIA5 = function(s) {
    if (s.match(/^[\x20-\x21\x23-\x7f]*$/) !== null) return true;
    return false;
};

/**
 * check whether a string is RFC 822 mail address<br/>
 * @name isMail
 * @memberOf KJUR.lang.String
 * @function
 * @static
 * @param {String} s input string
 * @return {Boolean} true if a string "s" RFC 822 mail address
 * @since jsrsasign 9.0.0 base64x 1.1.16
 * This static method will check string s is RFC 822 compliant mail address.
 * @example
 * KJUR.lang.String.isMail("abc") &rarr; false
 * KJUR.lang.String.isMail("abc@example") &rarr; false
 * KJUR.lang.String.isMail("abc@example.com") &rarr; true
 */
KJUR.lang.String.isMail = function(s) {
    if (s.match(/^[A-Za-z0-9]{1}[A-Za-z0-9_.-]*@{1}[A-Za-z0-9_.-]{1,}\.[A-Za-z0-9]{1,}$/) !== null) return true;
    return false;
};

// ==== others ================================

/**
 * canonicalize hexadecimal string of positive integer<br/>
 * @name hextoposhex
 * @function
 * @param {String} s hexadecimal string 
 * @return {String} canonicalized hexadecimal string of positive integer
 * @since base64x 1.1.10 jsrsasign 7.1.4
 * @description
 * This method canonicalize a hexadecimal string of positive integer
 * for two's complement representation.
 * Canonicalized hexadecimal string of positive integer will be:
 * <ul>
 * <li>Its length is always even.</li>
 * <li>If odd length it will be padded with leading zero.<li>
 * <li>If it is even length and its first character is "8" or greater,
 * it will be padded with "00" to make it positive integer.</li>
 * </ul>
 * @example
 * hextoposhex("abcd") &rarr; "00abcd"
 * hextoposhex("1234") &rarr; "1234"
 * hextoposhex("12345") &rarr; "012345"
 */
function hextoposhex(s) {
    if (s.length % 2 == 1) return "0" + s;
    if (s.substr(0, 1) > "7") return "00" + s;
    return s;
}

/**
 * convert string of integer array to hexadecimal string.<br/>
 * @name intarystrtohex
 * @function
 * @param {String} s string of integer array
 * @return {String} hexadecimal string
 * @since base64x 1.1.6 jsrsasign 5.0.2
 * @throws "malformed integer array string: *" for wrong input
 * @description
 * This function converts a string of JavaScript integer array to
 * a hexadecimal string. Each integer value shall be in a range 
 * from 0 to 255 otherwise it raise exception. Input string can
 * have extra space or newline string so that they will be ignored.
 * 
 * @example
 * intarystrtohex(" [123, 34, 101, 34, 58] ")
 * &rarr; 7b2265223a (i.e. '{"e":' as string)
 */
function intarystrtohex(s) {
  s = s.replace(/^\s*\[\s*/, '');
  s = s.replace(/\s*\]\s*$/, '');
  s = s.replace(/\s*/g, '');
  try {
    var hex = s.split(/,/).map(function(element, index, array) {
      var i = parseInt(element);
      if (i < 0 || 255 < i) throw "integer not in range 0-255";
      var hI = ("00" + i.toString(16)).slice(-2);
      return hI;
    }).join('');
    return hex;
  } catch(ex) {
    throw "malformed integer array string: " + ex;
  }
}

/**
 * find index of string where two string differs
 * @name strdiffidx
 * @function
 * @param {String} s1 string to compare
 * @param {String} s2 string to compare
 * @return {Number} string index of where character differs. Return -1 if same.
 * @since jsrsasign 4.9.0 base64x 1.1.5
 * @example
 * strdiffidx("abcdefg", "abcd4fg") -> 4
 * strdiffidx("abcdefg", "abcdefg") -> -1
 * strdiffidx("abcdefg", "abcdef") -> 6
 * strdiffidx("abcdefgh", "abcdef") -> 6
 */
var strdiffidx = function(s1, s2) {
    var n = s1.length;
    if (s1.length > s2.length) n = s2.length;
    for (var i = 0; i < n; i++) {
	if (s1.charCodeAt(i) != s2.charCodeAt(i)) return i;
    }
    if (s1.length != s2.length) return n;
    return -1; // same
};

// ==== hex / oid =================================

/**
 * get hexadecimal value of object identifier from dot noted oid value
 * @name oidtohex
 * @function
 * @param {String} oidString dot noted string of object identifier
 * @return {String} hexadecimal value of object identifier
 * @since jsrsasign 10.1.0 base64x 1.1.18
 * @see hextooid
 * @see ASN1HEX.hextooidstr
 * @see KJUR.asn1.ASN1Util.oidIntToHex
 * @description
 * This static method converts from object identifier value string.
 * to hexadecimal string representation of it.
 * {@link hextooid} is a reverse function of this.
 * @example
 * oidtohex("2.5.4.6") &rarr; "550406"
 */
function oidtohex(oidString) {
    var itox = function(i) {
        var h = i.toString(16);
        if (h.length == 1) h = '0' + h;
        return h;
    };

    var roidtox = function(roid) {
        var h = '';
        var bi = parseInt(roid, 10);
        var b = bi.toString(2);

        var padLen = 7 - b.length % 7;
        if (padLen == 7) padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++) bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7) b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };
    
    try {
	if (! oidString.match(/^[0-9.]+$/)) return null;
    
	var h = '';
	var a = oidString.split('.');
	var i0 = parseInt(a[0], 10) * 40 + parseInt(a[1], 10);
	h += itox(i0);
	a.splice(0, 2);
	for (var i = 0; i < a.length; i++) {
            h += roidtox(a[i]);
	}
	return h;
    } catch(ex) {
	return null;
    }
};

/**
 * get oid string from hexadecimal value of object identifier<br/>
 * @name hextooid
 * @function
 * @param {String} h hexadecimal value of object identifier
 * @return {String} dot noted string of object identifier (ex. "1.2.3.4")
 * @since jsrsasign 10.1.0 base64x 1.1.18
 * @see oidtohex
 * @see ASN1HEX.hextooidstr
 * @see KJUR.asn1.ASN1Util.oidIntToHex
 * @description
 * This static method converts from hexadecimal object identifier value 
 * to dot noted OID value (ex. "1.2.3.4").
 * {@link oidtohex} is a reverse function of this.
 * @example
 * hextooid("550406") &rarr; "2.5.4.6"
 */
function hextooid(h) {
    if (! ishex(h)) return null;
    try {
	var a = [];

	// a[0], a[1]
	var hex0 = h.substr(0, 2);
	var i0 = parseInt(hex0, 16);
	a[0] = new String(Math.floor(i0 / 40));
	a[1] = new String(i0 % 40);

	// a[2]..a[n]
	var hex1 = h.substr(2);
	var b = [];
	for (var i = 0; i < hex1.length / 2; i++) {
	    b.push(parseInt(hex1.substr(i * 2, 2), 16));
	}
	var c = [];
	var cbin = "";
	for (var i = 0; i < b.length; i++) {
            if (b[i] & 0x80) {
		cbin = cbin + strpad((b[i] & 0x7f).toString(2), 7);
            } else {
		cbin = cbin + strpad((b[i] & 0x7f).toString(2), 7);
		c.push(new String(parseInt(cbin, 2)));
		cbin = "";
            }
	}

	var s = a.join(".");
	if (c.length > 0) s = s + "." + c.join(".");
	return s;
    } catch(ex) {
	return null;
    }
};

/**
 * string padding<br/>
 * @name strpad
 * @function
 * @param {String} s input string
 * @param {Number} len output string length
 * @param {String} padchar padding character (default is "0")
 * @return {String} padded string
 * @since jsrsasign 10.1.0 base64x 1.1.18
 * @example
 * strpad("1234", 10, "0") &rarr; "0000001234"
 * strpad("1234", 10, " ") &rarr; "      1234"
 * strpad("1234", 10)      &rarr; "0000001234"
 */
var strpad = function(s, len, padchar) {
    if (padchar == undefined) padchar = "0";
    if (s.length >= len) return s;
    return new Array(len - s.length + 1).join(padchar) + s;
};

// ==== bitstr hex / int =================================

/**
 * convert from hexadecimal string of ASN.1 BitString value with unused bit to integer value<br/>
 * @name bitstrtoint
 * @function
 * @param {String} h hexadecimal string of ASN.1 BitString value with unused bit
 * @return {Number} positive integer value of the BitString
 * @since jsrsasign 10.1.3 base64x 1.1.19
 * @see inttobitstr
 * @see KJUR.asn1.DERBitString
 * @see ASN1HEX.getInt
 * 
 * @description
 * This function converts from hexadecimal string of ASN.1 BitString
 * value with unused bit to its integer value. <br/>
 * When an improper hexadecimal string of BitString value
 * is applied, this returns -1.
 * 
 * @example
 * // "03c8" &rarr; 0xc8 unusedbit=03 &rarr; 11001000b unusedbit=03 &rarr; 11001b &rarr; 25
 * bitstrtoint("03c8") &rarr; 25
 * // "02fff8" &rarr; 0xfff8 unusedbit=02 &rarr; 1111111111111000b unusedbit=02
 * //   11111111111110b &rarr; 16382
 * bitstrtoint("02fff8") &rarr; 16382
 * bitstrtoint("05a0") &rarr; 5 (=101b)
 * bitstrtoint("ff00") &rarr; -1 // for improper BitString value
 * bitstrtoint("05a0").toString(2) &rarr; "101"
 * bitstrtoint("07a080").toString(2) &rarr; "101000001"
 */
function bitstrtoint(h) {
    if (h.length % 2 != 0) return -1; 
    h = h.toLowerCase();
    if (h.match(/^[0-9a-f]+$/) == null) return -1;
    try {
	var hUnusedbit = h.substr(0, 2);
	if (hUnusedbit == "00")
	    return parseInt(h.substr(2), 16);
	var iUnusedbit = parseInt(hUnusedbit, 16);
	if (iUnusedbit > 7) return -1;
	var hValue = h.substr(2);
	var bValue = parseInt(hValue, 16).toString(2);
	if (bValue == "0") bValue = "00000000";
	bValue = bValue.slice(0, 0 - iUnusedbit);
	var iValue = parseInt(bValue, 2);
	if (iValue == NaN) return -1;
	return iValue;
    } catch(ex) {
	return -1;
    }
};

/**
 * convert from integer value to hexadecimal string of ASN.1 BitString value with unused bit<br/>
 * @name inttobitstr
 * @function
 * @param {Number} n integer value of ASN.1 BitString
 * @return {String} hexadecimal string of ASN.1 BitString value with unused bit
 * @since jsrsasign 10.1.3 base64x 1.1.19
 * @see bitstrtoint
 * @see KJUR.asn1.DERBitString
 * @see ASN1HEX.getInt
 * 
 * @description
 * This function converts from an integer value to 
 * hexadecimal string of ASN.1 BitString value
 * with unused bit. <br/>
 * When "n" is not non-negative number, this returns null
 * 
 * @example
 * // 25 &rarr; 11001b &rarr; 11001000b unusedbit=03 &rarr; 0xc8 unusedbit=03 &rarr; "03c8"
 * inttobitstr(25) &rarr; "03c8"
 * inttobitstr(-3) &rarr; null
 * inttobitstr("abc") &rarr; null
 * inttobitstr(parseInt("11001", 2)) &rarr; "03c8"
 * inttobitstr(parseInt("101", 2)) &rarr; "05a0"
 * inttobitstr(parseInt("101000001", 2)) &rarr; "07a080"
 */
function inttobitstr(n) {
    if (typeof n != "number") return null;
    if (n < 0) return null;
    var bValue = Number(n).toString(2);
    var iUnusedbit = 8 - bValue.length % 8;
    if (iUnusedbit == 8) iUnusedbit = 0;
    bValue = bValue + strpad("", iUnusedbit, "0");
    var hValue = parseInt(bValue, 2).toString(16);
    if (hValue.length % 2 == 1) hValue = "0" + hValue;
    var hUnusedbit = "0" + iUnusedbit;
    return hUnusedbit + hValue;
};

// ==== bitstr hex / binary string =======================

/**
 * convert from hexadecimal string of ASN.1 BitString value with unused bit to binary string<br/>
 * @name bitstrtobinstr
 * @function
 * @param {string} h hexadecimal string of ASN.1 BitString value with unused bit
 * @return {string} binary string
 * @since jsrsasign 10.5.4 base64x 1.1.21
 * @see binstrtobitstr
 * @see inttobitstr
 * 
 * @description
 * This function converts from hexadecimal string of ASN.1 BitString
 * value with unused bit to its integer value. <br/>
 * When an improper hexadecimal string of BitString value
 * is applied, this returns null.
 * 
 * @example
 * bitstrtobinstr("05a0") &rarr; "101"
 * bitstrtobinstr("0520") &rarr; "001"
 * bitstrtobinstr("07a080") &rarr; "101000001"
 * bitstrtobinstr(502) &rarr; null // non ASN.1 BitString value
 * bitstrtobinstr("ff00") &rarr; null // for improper BitString value
 */
function bitstrtobinstr(h) {
    if (typeof h != "string") return null;
    if (h.length % 2 != 0) return null;
    if (! h.match(/^[0-9a-f]+$/)) return null;
    try {
	var unusedBits = parseInt(h.substr(0, 2), 16);
	if (unusedBits < 0 || 7 < unusedBits) return null

	var value = h.substr(2);
	var bin = "";
	for (var i = 0; i < value.length; i += 2) {
	    var hi = value.substr(i, 2);
	    var bi = parseInt(hi, 16).toString(2);
	    bi = ("0000000" + bi).slice(-8);
	    bin += bi;
	}
	return  bin.substr(0, bin.length - unusedBits);
    } catch(ex) {
	return null;
    }
}

/**
 * convert from binary string to hexadecimal string of ASN.1 BitString value with unused bit<br/>
 * @name binstrtobitstr
 * @function
 * @param {string} s binary string (ex. "101")
 * @return {string} hexadecimal string of ASN.1 BitString value with unused bit
 * @since jsrsasign 10.5.4 base64x 1.1.21
 * @see bitstrtobinstr
 * @see inttobitstr
 * @see KJUR.asn1.DERBitString
 * 
 * @description
 * This function converts from an binary string (ex. "101") to 
 * hexadecimal string of ASN.1 BitString value
 * with unused bit (ex. "05a0"). <br/>
 * When "s" is not binary string, this returns null.
 * 
 * @example
 * binstrtobitstr("101") &rarr; "05a0"
 * binstrtobitstr("001") &rarr; "0520"
 * binstrtobitstr("11001") &rarr; "03c8"
 * binstrtobitstr("101000001") &rarr; "07a080"
 * binstrtobitstr(101) &rarr; null // not number
 * binstrtobitstr("xyz") &rarr; null // not binary string
 */
function binstrtobitstr(s) {
    if (typeof s != "string") return null;
    if (s.match(/^[01]+$/) == null) return null;
    try {
	var n = parseInt(s, 2);
	return inttobitstr(n);
    } catch(ex) {
	return null;
    }
}

// =======================================================
/**
 * convert array of names to bit string<br/>
 * @name namearraytobinstr
 * @function
 * @param {array} namearray array of name string
 * @param {object} namedb associative array of name and value
 * @return {string} binary string (ex. "110001")
 * @since jsrsasign 10.5.21 base64x 1.1.27
 * @see KJUR.asn1.x509.KeyUsage
 * @see KJUR.asn1.tsp.PKIFailureInfo
 * 
 * @description
 * This function converts from an array of names to
 * a binary string. DB value bit will be set.
 * Note that ordering of namearray items
 * will be ignored.
 *
 * @example
 * db = { a: 0, b: 3, c: 8, d: 9, e: 17, f: 19 };
 * namearraytobinstr(['a', 'c', 'd'], db) &rarr: '1000000011'
 * namearraytobinstr(['c', 'b'], db) &rarr: '000100001'
 */
function namearraytobinstr (namearray, namedb) {
    var d = 0;
    for (var i = 0; i < namearray.length; i++) {
	d |= 1 << namedb[namearray[i]];
    }

    var s = d.toString(2);
    var r = "";
    for (var i = s.length - 1; i >=0; i--) {
	r += s[i];
    }
    return r;
}

/**
 * get value of array by key name list<br/>
 * @function
 * @param {object} val array of associative array
 * @param {string} keys concatinated key list with dot (ex. 'type.name.0.info')
 * @param {object} def default value if value is not found (OPTIONAL)
 * @return {object} value if found otherwise returns def
 * @since jsrsasign 10.8.0 base64x 1.1.32
 *
 * @description
 * This function returns the value of an array or associative array 
 * which referred by a concatinated key list string.
 * If a value for key is not defined, it returns 'undefined' by default.
 * When an optional argument 'def' is specified and a value for key is
 * not defined, it returns a value of 'def'.
 * 
 * @example
 * let p = {
 *   fruit: apple,
 *   info: [
 *     { toy: 4 },
 *     { pen: 6 }
 *   ]
 * };
 * aryval(p, 'fruit') &rarr "apple"
 * aryval(p, 'info') &rarr [{toy: 4},{pen: 6}]
 * aryval(p, 'info.1') &rarr {pen: 6}
 * aryval(p, 'info.1.pen') &rarr 6
 * aryval(p, 'money.amount') &rarr undefined
 * aryval(p, 'money.amount', null) &rarr null
 */
function aryval(val, keys, def) {
    if (typeof val != "object") return undefined
    var keys = String(keys).split('.');
    for (var i = 0; i < keys.length && val; i++) {
	var key = keys[i];
	if (key.match(/^[0-9]+$/)) key = parseInt(key);
        val = val[key];
    }
    return val || val === false ? val : def;
}


// =======================================================
/**
 * set class inheritance<br/>
 * @name extendClass
 * @function
 * @param {Function} subClass sub class to set inheritance
 * @param {Function} superClass super class to inherit
 * @since jsrsasign 10.3.0 base64x 1.1.21
 *
 * @description
 * This function extends a class and set an inheritance
 * for member variables and methods.
 *
 * @example
 * var Animal = function() {
 *   this.hello = function(){console.log("Hello")};
 *   this.name="Ani";
 * };
 * var Dog = function() {
 *   Dog.superclass.constructor.call(this);
 *   this.vow = function(){console.log("Vow wow")};
 *   this.tail=true;
 * };
 * extendClass(Dog, Animal);
 */
function extendClass(subClass, superClass) {
    var F = function() {};
    F.prototype = superClass.prototype;
    subClass.prototype = new F();
    subClass.prototype.constructor = subClass;
    subClass.superclass = superClass.prototype;
     
    if (superClass.prototype.constructor == Object.prototype.constructor) {
        superClass.prototype.constructor = superClass;
    }
};


/* crypto-1.2.6.js (c) 2013-2021 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * crypto.js - Cryptographic Algorithm Provider class
 *
 * Copyright (c) 2013-2021 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name crypto-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.5.0 crypto 1.2.6 (2021-Nov-21)
 * @since jsrsasign 2.2
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/** 
 * kjur's class library name space
 * @name KJUR
 * @namespace kjur's class library name space
 */
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
/**
 * kjur's cryptographic algorithm provider library name space
 * <p>
 * This namespace privides following crytpgrahic classes.
 * <ul>
 * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>
 * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>
 * <li>{@link KJUR.crypto.Cipher} - class for encrypting and decrypting data</li>
 * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>
 * </ul>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * </p>
 * @name KJUR.crypto
 * @namespace
 */
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};

/**
 * static object for cryptographic function utilities
 * @name KJUR.crypto.Util
 * @class static object for cryptographic function utilities
 * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms
 * @property {Array} DEFAULTPROVIDER associative array of default provider name for each hash and signature algorithms
 * @description
 */
KJUR.crypto.Util = new function() {
    this.DIGESTINFOHEAD = {
	'sha1':      "3021300906052b0e03021a05000414",
        'sha224':    "302d300d06096086480165030402040500041c",
	'sha256':    "3031300d060960864801650304020105000420",
	'sha384':    "3041300d060960864801650304020205000430",
	'sha512':    "3051300d060960864801650304020305000440",
	'md2':       "3020300c06082a864886f70d020205000410",
	'md5':       "3020300c06082a864886f70d020505000410",
	'ripemd160': "3021300906052b2403020105000414",
    };

    /*
     * @since crypto 1.1.1
     */
    this.DEFAULTPROVIDER = {
	'md5':			'cryptojs',
	'sha1':			'cryptojs',
	'sha224':		'cryptojs',
	'sha256':		'cryptojs',
	'sha384':		'cryptojs',
	'sha512':		'cryptojs',
	'ripemd160':		'cryptojs',
	'hmacmd5':		'cryptojs',
	'hmacsha1':		'cryptojs',
	'hmacsha224':		'cryptojs',
	'hmacsha256':		'cryptojs',
	'hmacsha384':		'cryptojs',
	'hmacsha512':		'cryptojs',
	'hmacripemd160':	'cryptojs',

	'MD5withRSA':		'cryptojs/jsrsa',
	'SHA1withRSA':		'cryptojs/jsrsa',
	'SHA224withRSA':	'cryptojs/jsrsa',
	'SHA256withRSA':	'cryptojs/jsrsa',
	'SHA384withRSA':	'cryptojs/jsrsa',
	'SHA512withRSA':	'cryptojs/jsrsa',
	'RIPEMD160withRSA':	'cryptojs/jsrsa',

	'MD5withECDSA':		'cryptojs/jsrsa',
	'SHA1withECDSA':	'cryptojs/jsrsa',
	'SHA224withECDSA':	'cryptojs/jsrsa',
	'SHA256withECDSA':	'cryptojs/jsrsa',
	'SHA384withECDSA':	'cryptojs/jsrsa',
	'SHA512withECDSA':	'cryptojs/jsrsa',
	'RIPEMD160withECDSA':	'cryptojs/jsrsa',

	'SHA1withDSA':		'cryptojs/jsrsa',
	'SHA224withDSA':	'cryptojs/jsrsa',
	'SHA256withDSA':	'cryptojs/jsrsa',

	'MD5withRSAandMGF1':		'cryptojs/jsrsa',
	'SHAwithRSAandMGF1':		'cryptojs/jsrsa',
	'SHA1withRSAandMGF1':		'cryptojs/jsrsa',
	'SHA224withRSAandMGF1':		'cryptojs/jsrsa',
	'SHA256withRSAandMGF1':		'cryptojs/jsrsa',
	'SHA384withRSAandMGF1':		'cryptojs/jsrsa',
	'SHA512withRSAandMGF1':		'cryptojs/jsrsa',
	'RIPEMD160withRSAandMGF1':	'cryptojs/jsrsa',
    };

    /*
     * @since crypto 1.1.2
     */
    this.CRYPTOJSMESSAGEDIGESTNAME = {
	'md5':		CryptoJS.algo.MD5,
	'sha1':		CryptoJS.algo.SHA1,
	'sha224':	CryptoJS.algo.SHA224,
	'sha256':	CryptoJS.algo.SHA256,
	'sha384':	CryptoJS.algo.SHA384,
	'sha512':	CryptoJS.algo.SHA512,
	'ripemd160':	CryptoJS.algo.RIPEMD160
    };

    /**
     * get hexadecimal DigestInfo
     * @name getDigestInfoHex
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} hHash hexadecimal hash value
     * @param {String} alg hash algorithm name (ex. 'sha1')
     * @return {String} hexadecimal string DigestInfo ASN.1 structure
     */
    this.getDigestInfoHex = function(hHash, alg) {
	if (typeof this.DIGESTINFOHEAD[alg] == "undefined")
	    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;
	return this.DIGESTINFOHEAD[alg] + hHash;
    };

    /**
     * get PKCS#1 padded hexadecimal DigestInfo
     * @name getPaddedDigestInfoHex
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} hHash hexadecimal hash value of message to be signed
     * @param {String} alg hash algorithm name (ex. 'sha1')
     * @param {Integer} keySize key bit length (ex. 1024)
     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo
     */
    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {
	var hDigestInfo = this.getDigestInfoHex(hHash, alg);
	var pmStrLen = keySize / 4; // minimum PM length

	if (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22
	    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;

	var hHead = "0001";
	var hTail = "00" + hDigestInfo;
	var hMid = "";
	var fLen = pmStrLen - hHead.length - hTail.length;
	for (var i = 0; i < fLen; i += 2) {
	    hMid += "ff";
	}
	var hPaddedMessage = hHead + hMid + hTail;
	return hPaddedMessage;
    };

    /**
     * get hexadecimal hash of string with specified algorithm
     * @name hashString
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s raw input string to be hashed
     * @param {String} alg hash algorithm name
     * @return {String} hexadecimal string of hash value
     * @since 1.1.1
     */
    this.hashString = function(s, alg) {
        var md = new KJUR.crypto.MessageDigest({'alg': alg});
        return md.digestString(s);
    };

    /**
     * get hexadecimal hash of hexadecimal string with specified algorithm
     * @name hashHex
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} sHex input hexadecimal string to be hashed
     * @param {String} alg hash algorithm name
     * @return {String} hexadecimal string of hash value
     * @since 1.1.1
     */
    this.hashHex = function(sHex, alg) {
        var md = new KJUR.crypto.MessageDigest({'alg': alg});
        return md.digestHex(sHex);
    };

    /**
     * get hexadecimal SHA1 hash of string
     * @name sha1
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s raw input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha1 = function(s) {
	return this.hashString(s, 'sha1');
    };

    /**
     * get hexadecimal SHA256 hash of string
     * @name sha256
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s raw input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha256 = function(s) {
	return this.hashString(s, 'sha256');
    };

    this.sha256Hex = function(s) {
	return this.hashHex(s, 'sha256');
    };

    /**
     * get hexadecimal SHA512 hash of string
     * @name sha512
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s raw input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha512 = function(s) {
	return this.hashString(s, 'sha512');
    };

    this.sha512Hex = function(s) {
	return this.hashHex(s, 'sha512');
    };

    /**
     * check if key object (RSA/DSA/ECDSA) or not
     * @name isKey
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {Object} obj any type argument to be checked
     * @return {Boolean} true if this is key object otherwise false
     * @since 1.0.3
     */
    this.isKey = function(obj) {
	if (obj instanceof RSAKey ||
	    obj instanceof KJUR.crypto.DSA ||
	    obj instanceof KJUR.crypto.ECDSA) {
	    return true;
	} else {
	    return false;
	}
    };
};

/**
 * get hexadecimal MD5 hash of string
 * @name md5
 * @memberOf KJUR.crypto.Util
 * @function
 * @param {String} s input string to be hashed
 * @return {String} hexadecimal string of hash value
 * @since 1.0.3
 * @example
 * Util.md5('aaa') &rarr; 47bce5c74f589f4867dbd57e9ca9f808
 */
KJUR.crypto.Util.md5 = function(s) {
    var md = new KJUR.crypto.MessageDigest({'alg':'md5', 'prov':'cryptojs'});
    return md.digestString(s);
};

/**
 * get hexadecimal RIPEMD160 hash of string
 * @name ripemd160
 * @memberOf KJUR.crypto.Util
 * @function
 * @param {String} s input string to be hashed
 * @return {String} hexadecimal string of hash value
 * @since 1.0.3
 * @example
 * KJUR.crypto.Util.ripemd160("aaa") &rarr; 08889bd7b151aa174c21f33f59147fa65381edea
 */
KJUR.crypto.Util.ripemd160 = function(s) {
    var md = new KJUR.crypto.MessageDigest({'alg':'ripemd160', 'prov':'cryptojs'});
    return md.digestString(s);
};

// @since jsrsasign 7.0.0 crypto 1.1.11
KJUR.crypto.Util.SECURERANDOMGEN = new SecureRandom();

/**
 * get hexadecimal string of random value from with specified byte length<br/>
 * @name getRandomHexOfNbytes
 * @memberOf KJUR.crypto.Util
 * @function
 * @param {Integer} n length of bytes of random
 * @return {String} hexadecimal string of random
 * @since jsrsasign 7.0.0 crypto 1.1.11
 * @example
 * KJUR.crypto.Util.getRandomHexOfNbytes(3) &rarr; "6314af", "000000" or "001fb4"
 * KJUR.crypto.Util.getRandomHexOfNbytes(128) &rarr; "8fbc..." in 1024bits 
 */
KJUR.crypto.Util.getRandomHexOfNbytes = function(n) {
    var ba = new Array(n);
    KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(ba);
    return BAtohex(ba);
};

/**
 * get BigInteger object of random value from with specified byte length<br/>
 * @name getRandomBigIntegerOfNbytes
 * @memberOf KJUR.crypto.Util
 * @function
 * @param {Integer} n length of bytes of random
 * @return {BigInteger} BigInteger object of specified random value
 * @since jsrsasign 7.0.0 crypto 1.1.11
 * @example
 * KJUR.crypto.Util.getRandomBigIntegerOfNbytes(3) &rarr; 6314af of BigInteger
 * KJUR.crypto.Util.getRandomBigIntegerOfNbytes(128) &rarr; 8fbc... of BigInteger
 */
KJUR.crypto.Util.getRandomBigIntegerOfNbytes = function(n) {
    return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbytes(n), 16);
};

/**
 * get hexadecimal string of random value from with specified bit length<br/>
 * @name getRandomHexOfNbits
 * @memberOf KJUR.crypto.Util
 * @function
 * @param {Integer} n length of bits of random
 * @return {String} hexadecimal string of random
 * @since jsrsasign 7.0.0 crypto 1.1.11
 * @example
 * KJUR.crypto.Util.getRandomHexOfNbits(24) &rarr; "6314af", "000000" or "001fb4"
 * KJUR.crypto.Util.getRandomHexOfNbits(1024) &rarr; "8fbc..." in 1024bits 
 */
KJUR.crypto.Util.getRandomHexOfNbits = function(n) {
    var n_remainder = n % 8;
    var n_quotient = (n - n_remainder) / 8;
    var ba = new Array(n_quotient + 1);
    KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(ba);
    ba[0] = (((255 << n_remainder) & 255) ^ 255) & ba[0];
    return BAtohex(ba);
};

/**
 * get BigInteger object of random value from with specified bit length<br/>
 * @name getRandomBigIntegerOfNbits
 * @memberOf KJUR.crypto.Util
 * @function
 * @param {Integer} n length of bits of random
 * @return {BigInteger} BigInteger object of specified random value
 * @since jsrsasign 7.0.0 crypto 1.1.11
 * @example
 * KJUR.crypto.Util.getRandomBigIntegerOfNbits(24) &rarr; 6314af of BigInteger
 * KJUR.crypto.Util.getRandomBigIntegerOfNbits(1024) &rarr; 8fbc... of BigInteger
 */
KJUR.crypto.Util.getRandomBigIntegerOfNbits = function(n) {
    return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbits(n), 16);
};

/**
 * get BigInteger object of random value from zero to max value<br/>
 * @name getRandomBigIntegerZeroToMax
 * @memberOf KJUR.crypto.Util
 * @function
 * @param {BigInteger} biMax max value of BigInteger object for random value
 * @return {BigInteger} BigInteger object of specified random value
 * @since jsrsasign 7.0.0 crypto 1.1.11
 * @description
 * This static method generates a BigInteger object with random value
 * greater than or equal to zero and smaller than or equal to biMax
 * (i.e. 0 &le; result &le; biMax).
 * @example
 * biMax = new BigInteger("3fa411...", 16);
 * KJUR.crypto.Util.getRandomBigIntegerZeroToMax(biMax) &rarr; 8fbc... of BigInteger
 */
KJUR.crypto.Util.getRandomBigIntegerZeroToMax = function(biMax) {
    var bitLenMax = biMax.bitLength();
    while (1) {
	var biRand = KJUR.crypto.Util.getRandomBigIntegerOfNbits(bitLenMax);
	if (biMax.compareTo(biRand) != -1) return biRand;
    }
};

/**
 * get BigInteger object of random value from min value to max value<br/>
 * @name getRandomBigIntegerMinToMax
 * @memberOf KJUR.crypto.Util
 * @function
 * @param {BigInteger} biMin min value of BigInteger object for random value
 * @param {BigInteger} biMax max value of BigInteger object for random value
 * @return {BigInteger} BigInteger object of specified random value
 * @since jsrsasign 7.0.0 crypto 1.1.11
 * @description
 * This static method generates a BigInteger object with random value
 * greater than or equal to biMin and smaller than or equal to biMax
 * (i.e. biMin &le; result &le; biMax).
 * @example
 * biMin = new BigInteger("2fa411...", 16);
 * biMax = new BigInteger("3fa411...", 16);
 * KJUR.crypto.Util.getRandomBigIntegerMinToMax(biMin, biMax) &rarr; 32f1... of BigInteger
 */
KJUR.crypto.Util.getRandomBigIntegerMinToMax = function(biMin, biMax) {
    var flagCompare = biMin.compareTo(biMax);
    if (flagCompare == 1) throw "biMin is greater than biMax";
    if (flagCompare == 0) return biMin;

    var biDiff = biMax.subtract(biMin);
    var biRand = KJUR.crypto.Util.getRandomBigIntegerZeroToMax(biDiff);
    return biRand.add(biMin);
};

// === Mac ===============================================================

/**
 * MessageDigest class which is very similar to java.security.MessageDigest class<br/>
 * @name KJUR.crypto.MessageDigest
 * @class MessageDigest class which is very similar to java.security.MessageDigest class
 * @param {Array} params parameters for constructor
 * @property {Array} HASHLENGTH static Array of resulted byte length of hash (ex. HASHLENGTH["sha1"] == 20)
 * @description
 * <br/>
 * Currently this supports following algorithm and providers combination:
 * <ul>
 * <li>md5 - cryptojs</li>
 * <li>sha1 - cryptojs</li>
 * <li>sha224 - cryptojs</li>
 * <li>sha256 - cryptojs</li>
 * <li>sha384 - cryptojs</li>
 * <li>sha512 - cryptojs</li>
 * <li>ripemd160 - cryptojs</li>
 * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>
 * </ul>
 * @example
 * // CryptoJS provider sample
 * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});
 * md.updateString('aaa')
 * var mdHex = md.digest()
 *
 * // SJCL(Stanford JavaScript Crypto Library) provider sample
 * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only
 * md.updateString('aaa')
 * var mdHex = md.digest()
 *
 * // HASHLENGTH property
 * KJUR.crypto.MessageDigest.HASHLENGTH['sha1'] &rarr 20
 * KJUR.crypto.MessageDigest.HASHLENGTH['sha512'] &rarr 64
 */
KJUR.crypto.MessageDigest = function(params) {
    var md = null;
    var algName = null;
    var provName = null;

    /**
     * set hash algorithm and provider<br/>
     * @name setAlgAndProvider
     * @memberOf KJUR.crypto.MessageDigest#
     * @function
     * @param {String} alg hash algorithm name
     * @param {String} prov provider name
     * @description
     * This methods set an algorithm and a cryptographic provider.<br/>
     * Here is acceptable algorithm names ignoring cases and hyphens:
     * <ul>
     * <li>MD5</li>
     * <li>SHA1</li>
     * <li>SHA224</li>
     * <li>SHA256</li>
     * <li>SHA384</li>
     * <li>SHA512</li>
     * <li>RIPEMD160</li>
     * </ul>
     * NOTE: Since jsrsasign 6.2.0 crypto 1.1.10, this method ignores
     * upper or lower cases. Also any hyphens (i.e. "-") will be ignored
     * so that "SHA1" or "SHA-1" will be acceptable.
     * @example
     * // for SHA1
     * md.setAlgAndProvider('sha1', 'cryptojs');
     * md.setAlgAndProvider('SHA1');
     * // for RIPEMD160
     * md.setAlgAndProvider('ripemd160', 'cryptojs');
     */
    this.setAlgAndProvider = function(alg, prov) {
	alg = KJUR.crypto.MessageDigest.getCanonicalAlgName(alg);

	if (alg !== null && prov === undefined) prov = KJUR.crypto.Util.DEFAULTPROVIDER[alg];

	// for cryptojs
	if (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(alg) != -1 &&
	    prov == 'cryptojs') {
	    try {
		this.md = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[alg].create();
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;
	    }
	    this.updateString = function(str) {
		this.md.update(str);
	    };
	    this.updateHex = function(hex) {
		var wHex = CryptoJS.enc.Hex.parse(hex);
		this.md.update(wHex);
	    };
	    this.digest = function() {
		var hash = this.md.finalize();
		return hash.toString(CryptoJS.enc.Hex);
	    };
	    this.digestString = function(str) {
		this.updateString(str);
		return this.digest();
	    };
	    this.digestHex = function(hex) {
		this.updateHex(hex);
		return this.digest();
	    };
	}
	if (':sha256:'.indexOf(alg) != -1 &&
	    prov == 'sjcl') {
	    try {
		this.md = new sjcl.hash.sha256();
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;
	    }
	    this.updateString = function(str) {
		this.md.update(str);
	    };
	    this.updateHex = function(hex) {
		var baHex = sjcl.codec.hex.toBits(hex);
		this.md.update(baHex);
	    };
	    this.digest = function() {
		var hash = this.md.finalize();
		return sjcl.codec.hex.fromBits(hash);
	    };
	    this.digestString = function(str) {
		this.updateString(str);
		return this.digest();
	    };
	    this.digestHex = function(hex) {
		this.updateHex(hex);
		return this.digest();
	    };
	}
    };

    /**
     * update digest by specified string
     * @name updateString
     * @memberOf KJUR.crypto.MessageDigest#
     * @function
     * @param {String} str string to update
     * @description
     * @example
     * md.updateString('New York');
     */
    this.updateString = function(str) {
	throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * update digest by specified hexadecimal string
     * @name updateHex
     * @memberOf KJUR.crypto.MessageDigest#
     * @function
     * @param {String} hex hexadecimal string to update
     * @description
     * @example
     * md.updateHex('0afe36');
     */
    this.updateHex = function(hex) {
	throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * completes hash calculation and returns hash result
     * @name digest
     * @memberOf KJUR.crypto.MessageDigest#
     * @function
     * @description
     * @example
     * md.digest()
     */
    this.digest = function() {
	throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * performs final update on the digest using string, then completes the digest computation
     * @name digestString
     * @memberOf KJUR.crypto.MessageDigest#
     * @function
     * @param {String} str string to final update
     * @description
     * @example
     * md.digestString('aaa')
     */
    this.digestString = function(str) {
	throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * performs final update on the digest using hexadecimal string, then completes the digest computation
     * @name digestHex
     * @memberOf KJUR.crypto.MessageDigest#
     * @function
     * @param {String} hex hexadecimal string to final update
     * @description
     * @example
     * md.digestHex('0f2abd')
     */
    this.digestHex = function(hex) {
	throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    if (params !== undefined) {
	if (params['alg'] !== undefined) {
	    this.algName = params['alg'];
	    if (params['prov'] === undefined)
		this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
	    this.setAlgAndProvider(this.algName, this.provName);
	}
    }
};

/**
 * get canonical hash algorithm name<br/>
 * @name getCanonicalAlgName
 * @memberOf KJUR.crypto.MessageDigest
 * @function
 * @param {String} alg hash algorithm name (ex. MD5, SHA-1, SHA1, SHA512 et.al.)
 * @return {String} canonical hash algorithm name
 * @since jsrsasign 6.2.0 crypto 1.1.10
 * @description
 * This static method normalizes from any hash algorithm name such as
 * "SHA-1", "SHA1", "MD5", "sha512" to lower case name without hyphens
 * such as "sha1".
 * @example
 * KJUR.crypto.MessageDigest.getCanonicalAlgName("SHA-1") &rarr "sha1"
 * KJUR.crypto.MessageDigest.getCanonicalAlgName("MD5")   &rarr "md5"
 */
KJUR.crypto.MessageDigest.getCanonicalAlgName = function(alg) {
    if (typeof alg === "string") {
	alg = alg.toLowerCase();
	alg = alg.replace(/-/, '');
    }
    return alg;
};

/**
 * get resulted hash byte length for specified algorithm name<br/>
 * @name getHashLength
 * @memberOf KJUR.crypto.MessageDigest
 * @function
 * @param {String} alg non-canonicalized hash algorithm name (ex. MD5, SHA-1, SHA1, SHA512 et.al.)
 * @return {Integer} resulted hash byte length
 * @since jsrsasign 6.2.0 crypto 1.1.10
 * @description
 * This static method returns resulted byte length for specified algorithm name such as "SHA-1".
 * @example
 * KJUR.crypto.MessageDigest.getHashLength("SHA-1") &rarr 20
 * KJUR.crypto.MessageDigest.getHashLength("sha1") &rarr 20
 */
KJUR.crypto.MessageDigest.getHashLength = function(alg) {
    var MD = KJUR.crypto.MessageDigest
    var alg2 = MD.getCanonicalAlgName(alg);
    if (MD.HASHLENGTH[alg2] === undefined)
	throw "not supported algorithm: " + alg;
    return MD.HASHLENGTH[alg2];
};

// described in KJUR.crypto.MessageDigest class (since jsrsasign 6.2.0 crypto 1.1.10)
KJUR.crypto.MessageDigest.HASHLENGTH = {
    'md5':		16,
    'sha1':		20,
    'sha224':		28,
    'sha256':		32,
    'sha384':		48,
    'sha512':		64,
    'ripemd160':	20
};

// === Mac ===============================================================

/**
 * Mac(Message Authentication Code) class which is very similar to java.security.Mac class 
 * @name KJUR.crypto.Mac
 * @class Mac class which is very similar to java.security.Mac class
 * @param {Array} params parameters for constructor
 * @description
 * <br/>
 * Currently this supports following algorithm and providers combination:
 * <ul>
 * <li>hmacmd5 - cryptojs</li>
 * <li>hmacsha1 - cryptojs</li>
 * <li>hmacsha224 - cryptojs</li>
 * <li>hmacsha256 - cryptojs</li>
 * <li>hmacsha384 - cryptojs</li>
 * <li>hmacsha512 - cryptojs</li>
 * </ul>
 * NOTE: HmacSHA224 and HmacSHA384 issue was fixed since jsrsasign 4.1.4.
 * Please use 'ext/cryptojs-312-core-fix*.js' instead of 'core.js' of original CryptoJS
 * to avoid those issue.
 * <br/>
 * NOTE2: Hmac signature bug was fixed in jsrsasign 4.9.0 by providing CryptoJS
 * bug workaround.
 * <br/>
 * Please see {@link KJUR.crypto.Mac.setPassword}, how to provide password
 * in various ways in detail.
 * @example
 * var mac = new KJUR.crypto.Mac({alg: "HmacSHA256", "pass": "pass"});
 * mac.updateString('aaa')
 * mac.doFinal() &rarr; "5737da..."
 *
 * // other password representation 
 * var mac = new KJUR.crypto.Mac({alg: "HmacSHA256", "pass": {"hex":  "6161"}});
 * var mac = new KJUR.crypto.Mac({alg: "HmacSHA256", "pass": {"utf8": "aa"}});
 * var mac = new KJUR.crypto.Mac({alg: "HmacSHA256", "pass": {"rstr": "\x61\x61"}});
 * var mac = new KJUR.crypto.Mac({alg: "HmacSHA256", "pass": {"b64":  "Mi02/+...a=="}});
 * var mac = new KJUR.crypto.Mac({alg: "HmacSHA256", "pass": {"b64u": "Mi02_-...a"}});
 */
KJUR.crypto.Mac = function(params) {
    var mac = null;
    var pass = null;
    var algName = null;
    var provName = null;
    var algProv = null;

    this.setAlgAndProvider = function(alg, prov) {
	alg = alg.toLowerCase();

	if (alg == null) alg = "hmacsha1";

	alg = alg.toLowerCase();
        if (alg.substr(0, 4) != "hmac") {
	    throw "setAlgAndProvider unsupported HMAC alg: " + alg;
	}

	if (prov === undefined) prov = KJUR.crypto.Util.DEFAULTPROVIDER[alg];
	this.algProv = alg + "/" + prov;

	var hashAlg = alg.substr(4);

	// for cryptojs
	if (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(hashAlg) != -1 &&
	    prov == 'cryptojs') {
	    try {
		var mdObj = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[hashAlg];
		this.mac = CryptoJS.algo.HMAC.create(mdObj, this.pass);
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail hashAlg=" + hashAlg + "/" + ex;
	    }
	    this.updateString = function(str) {
		this.mac.update(str);
	    };
	    this.updateHex = function(hex) {
		var wHex = CryptoJS.enc.Hex.parse(hex);
		this.mac.update(wHex);
	    };
	    this.doFinal = function() {
		var hash = this.mac.finalize();
		return hash.toString(CryptoJS.enc.Hex);
	    };
	    this.doFinalString = function(str) {
		this.updateString(str);
		return this.doFinal();
	    };
	    this.doFinalHex = function(hex) {
		this.updateHex(hex);
		return this.doFinal();
	    };
	}
    };

    /**
     * update digest by specified string<br/>
     * @name updateString
     * @memberOf KJUR.crypto.Mac#
     * @function
     * @param {String} str string to update
     *
     * @description
     * @example
     * var mac = new KJUR.crypto.Mac({alg: "HmacSHA256", "pass": "pass"});
     * mac.updateString('aaa')
     * mac.doFinal() &rarr; "5737da..."
     */
    this.updateString = function(str) {
	throw "updateString(str) not supported for this alg/prov: " + this.algProv;
    };

    /**
     * update digest by specified hexadecimal string<br/>
     * @name updateHex
     * @memberOf KJUR.crypto.Mac#
     * @function
     * @param {String} hex hexadecimal string to update
     *
     * @description
     * @example
     * var mac = new KJUR.crypto.Mac({alg: "HmacSHA256", "pass": "pass"});
     * mac.updateHex('616161')
     * mac.doFinal() &rarr; "5737da..."
     */
    this.updateHex = function(hex) {
	throw "updateHex(hex) not supported for this alg/prov: " + this.algProv;
    };

    /**
     * completes hash calculation and returns hash result<br/>
     * @name doFinal
     * @memberOf KJUR.crypto.Mac#
     * @function
     * @returns hexadecimal string of Mac result value
     *
     * @description
     * @example
     * var mac = new KJUR.crypto.Mac({alg: "HmacSHA256", "pass": "pass"});
     * mac.updateString('aaa')
     * mac.doFinal() &rarr; "5737da..."
     */
    this.doFinal = function() {
	throw "digest() not supported for this alg/prov: " + this.algProv;
    };

    /**
     * performs final update on the digest using string, then completes the digest computation<br/>
     * @name doFinalString
     * @memberOf KJUR.crypto.Mac#
     * @function
     * @param {String} str raw string to final update
     * @returns hexadecimal string of Mac result value
     *
     * @description
     * @example
     * var mac = new KJUR.crypto.Mac({alg: "HmacSHA256", "pass": "pass"});
     * mac.doFinalString("aaa") &rarr; "5737da..."
     */
    this.doFinalString = function(str) {
	throw "digestString(str) not supported for this alg/prov: " + this.algProv;
    };

    /**
     * performs final update on the digest using hexadecimal string, then completes the digest computation<br/>
     * @name doFinalHex
     * @memberOf KJUR.crypto.Mac#
     * @function
     * @param {String} hex hexadecimal string to final update
     * @returns hexadecimal string of Mac result value
     *
     * @description
     * @example
     * var mac = new KJUR.crypto.Mac({alg: "HmacSHA256", "pass": "pass"});
     * mac.doFinalHex("616161") &rarr; "5737da..."
     */
    this.doFinalHex = function(hex) {
	throw "digestHex(hex) not supported for this alg/prov: " + this.algProv;
    };

    /**
     * set password for Mac<br/>
     * @name setPassword
     * @memberOf KJUR.crypto.Mac#
     * @function
     * @param {Object} pass password for Mac
     * @since crypto 1.1.7 jsrsasign 4.9.0
     * @description
     * This method will set password for (H)Mac internally.
     * Argument 'pass' can be specified as following:
     * <ul>
     * <li>even length string of 0..9, a..f or A-F: implicitly specified as hexadecimal string</li>
     * <li>not above string: implicitly specified as raw string</li>
     * <li>{rstr: "\x65\x70"}: explicitly specified as raw string</li>
     * <li>{hex: "6570"}: explicitly specified as hexacedimal string</li>
     * <li>{utf8: ""}: explicitly specified as UTF8 string</li>
     * <li>{b64: "Mi78..=="}: explicitly specified as Base64 string</li>
     * <li>{b64u: "Mi7-_"}: explicitly specified as Base64URL string</li>
     * </ul>
     * It is *STRONGLY RECOMMENDED* that explicit representation of password argument
     * to avoid ambiguity. For example string  "6161" can mean a string "6161" or 
     * a hexadecimal string of "aa" (i.e. \x61\x61).
     * @example
     * mac = KJUR.crypto.Mac({'alg': 'hmacsha256'});
     * // set password by implicit raw string
     * mac.setPassword("\x65\x70\xb9\x0b");
     * mac.setPassword("password");
     * // set password by implicit hexadecimal string
     * mac.setPassword("6570b90b");
     * mac.setPassword("6570B90B");
     * // set password by explicit raw string
     * mac.setPassword({"rstr": "\x65\x70\xb9\x0b"});
     * // set password by explicit hexadecimal string
     * mac.setPassword({"hex": "6570b90b"});
     * // set password by explicit utf8 string
     * mac.setPassword({"utf8": "password");
     * // set password by explicit Base64 string
     * mac.setPassword({"b64": "Mb+c3f/=="});
     * // set password by explicit Base64URL string
     * mac.setPassword({"b64u": "Mb-c3f_"});
     */
    this.setPassword = function(pass) {
	// internal this.pass shall be CryptoJS DWord Object for CryptoJS bug
	// work around. CrytoJS HMac password can be passed by
	// raw string as described in the manual however it doesn't
	// work properly in some case. If password was passed
	// by CryptoJS DWord which is not described in the manual
	// it seems to work. (fixed since crypto 1.1.7)

	if (typeof pass == 'string') {
	    var hPass = pass;
	    if (pass.length % 2 == 1 || ! pass.match(/^[0-9A-Fa-f]+$/)) { // raw str
		hPass = rstrtohex(pass);
	    }
	    this.pass = CryptoJS.enc.Hex.parse(hPass);
	    return;
	}

	if (typeof pass != 'object')
	    throw "KJUR.crypto.Mac unsupported password type: " + pass;
	
	var hPass = null;
	if (pass.hex  !== undefined) {
	    if (pass.hex.length % 2 != 0 || ! pass.hex.match(/^[0-9A-Fa-f]+$/))
		throw "Mac: wrong hex password: " + pass.hex;
	    hPass = pass.hex;
	}
	if (pass.utf8 !== undefined) hPass = utf8tohex(pass.utf8);
	if (pass.rstr !== undefined) hPass = rstrtohex(pass.rstr);
	if (pass.b64  !== undefined) hPass = b64tohex(pass.b64);
	if (pass.b64u !== undefined) hPass = b64utohex(pass.b64u);

	if (hPass == null)
	    throw "KJUR.crypto.Mac unsupported password type: " + pass;

	this.pass = CryptoJS.enc.Hex.parse(hPass);
    };

    if (params !== undefined) {
	if (params.pass !== undefined) {
	    this.setPassword(params.pass);
	}
	if (params.alg !== undefined) {
	    this.algName = params.alg;
	    if (params['prov'] === undefined)
		this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
	    this.setAlgAndProvider(this.algName, this.provName);
	}
    }
};

// ====== Signature class ====================================================
/**
 * Signature class which is very similar to java.security.Signature class
 * @name KJUR.crypto.Signature
 * @class Signature class which is very similar to java.security.Signature class
 * @param {Array} params parameters for constructor
 * @property {String} state Current state of this signature object whether 'SIGN', 'VERIFY' or null
 * @description
 * <br/>
 * As for params of constructor's argument, it can be specify following attributes:
 * <ul>
 * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}with{RSA,ECDSA,DSA})</li>
 * <li>provider - currently 'cryptojs/jsrsa' only</li>
 * </ul>
 * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>
 * This Signature class supports following signature algorithm and provider names:
 * <ul>
 * <li>MD5withRSA - cryptojs/jsrsa</li>
 * <li>SHA1withRSA - cryptojs/jsrsa</li>
 * <li>SHA224withRSA - cryptojs/jsrsa</li>
 * <li>SHA256withRSA - cryptojs/jsrsa</li>
 * <li>SHA384withRSA - cryptojs/jsrsa</li>
 * <li>SHA512withRSA - cryptojs/jsrsa</li>
 * <li>RIPEMD160withRSA - cryptojs/jsrsa</li>
 * <li>MD5withECDSA - cryptojs/jsrsa</li>
 * <li>SHA1withECDSA - cryptojs/jsrsa</li>
 * <li>SHA224withECDSA - cryptojs/jsrsa</li>
 * <li>SHA256withECDSA - cryptojs/jsrsa</li>
 * <li>SHA384withECDSA - cryptojs/jsrsa</li>
 * <li>SHA512withECDSA - cryptojs/jsrsa</li>
 * <li>RIPEMD160withECDSA - cryptojs/jsrsa</li>
 * <li>MD5withRSAandMGF1 - cryptojs/jsrsa</li>
 * <li>SHAwithRSAandMGF1 - cryptojs/jsrsa</li>
 * <li>SHA1withRSAandMGF1 - cryptojs/jsrsa</li>
 * <li>SHA224withRSAandMGF1 - cryptojs/jsrsa</li>
 * <li>SHA256withRSAandMGF1 - cryptojs/jsrsa</li>
 * <li>SHA384withRSAandMGF1 - cryptojs/jsrsa</li>
 * <li>SHA512withRSAandMGF1 - cryptojs/jsrsa</li>
 * <li>RIPEMD160withRSAandMGF1 - cryptojs/jsrsa</li>
 * <li>SHA1withDSA - cryptojs/jsrsa</li>
 * <li>SHA224withDSA - cryptojs/jsrsa</li>
 * <li>SHA256withDSA - cryptojs/jsrsa</li>
 * </ul>
 * As for RSA-PSS signature algorithm names and signing parameters 
 * such as MGF function and salt length, please see
 * {@link KJUR.asn1.x509.AlgorithmIdentifier} class.
 *
 * Here are supported elliptic cryptographic curve names and their aliases for ECDSA:
 * <ul>
 * <li>secp256k1</li>
 * <li>secp256r1, NIST P-256, P-256, prime256v1</li>
 * <li>secp384r1, NIST P-384, P-384</li>
 * <li>secp521r1, NIST P-521, P-521</li>
 * </ul>
 * NOTE1: DSA signing algorithm is also supported since crypto 1.1.5.
 * <h4>EXAMPLES</h4>
 * @example
 * // RSA signature generation
 * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA"});
 * sig.init(prvKeyPEM);
 * sig.updateString('aaa');
 * var hSigVal = sig.sign();
 *
 * // DSA signature validation
 * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withDSA"});
 * sig2.init(certPEM);
 * sig.updateString('aaa');
 * var isValid = sig2.verify(hSigVal);
 * 
 * // ECDSA signing
 * var sig = new KJUR.crypto.Signature({'alg':'SHA1withECDSA'});
 * sig.init(prvKeyPEM);
 * sig.updateString('aaa');
 * var sigValueHex = sig.sign();
 *
 * // ECDSA verifying
 * var sig2 = new KJUR.crypto.Signature({'alg':'SHA1withECDSA'});
 * sig.init(certPEM);
 * sig.updateString('aaa');
 * var isValid = sig.verify(sigValueHex);
 */
KJUR.crypto.Signature = function(params) {
    var prvKey = null; // RSAKey/KJUR.crypto.{ECDSA,DSA} object for signing
    var pubKey = null; // RSAKey/KJUR.crypto.{ECDSA,DSA} object for verifying

    var md = null; // KJUR.crypto.MessageDigest object
    var sig = null;
    var algName = null;
    var provName = null;
    var algProvName = null;
    var mdAlgName = null;
    var pubkeyAlgName = null;	// rsa,ecdsa,rsaandmgf1(=rsapss)
    var state = null;
    var pssSaltLen = -1;
    var initParams = null;

    var sHashHex = null; // hex hash value for hex
    var hDigestInfo = null;
    var hPaddedDigestInfo = null;
    var hSign = null;

    this._setAlgNames = function() {
    var matchResult = this.algName.match(/^(.+)with(.+)$/);
	if (matchResult) {
	    this.mdAlgName = matchResult[1].toLowerCase();
	    this.pubkeyAlgName = matchResult[2].toLowerCase();
	    if (this.pubkeyAlgName == "rsaandmgf1" &&
	        this.mdAlgName == "sha") {
		this.mdAlgName = "sha1";
	    }
	}
    };

    this._zeroPaddingOfSignature = function(hex, bitLength) {
	var s = "";
	var nZero = bitLength / 4 - hex.length;
	for (var i = 0; i < nZero; i++) {
	    s = s + "0";
	}
	return s + hex;
    };

    /**
     * set signature algorithm and provider
     * @name setAlgAndProvider
     * @memberOf KJUR.crypto.Signature#
     * @function
     * @param {String} alg signature algorithm name
     * @param {String} prov provider name
     * @description
     * @example
     * md.setAlgAndProvider('SHA1withRSA', 'cryptojs/jsrsa');
     */
    this.setAlgAndProvider = function(alg, prov) {
	this._setAlgNames();
	if (prov != 'cryptojs/jsrsa')
	    throw new Error("provider not supported: " + prov);

	if (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(this.mdAlgName) != -1) {
	    try {
		this.md = new KJUR.crypto.MessageDigest({'alg':this.mdAlgName});
	    } catch (ex) {
		throw new Error("setAlgAndProvider hash alg set fail alg=" +
				this.mdAlgName + "/" + ex);
	    }
	    
	    this.init = function(keyparam, pass) {
		var keyObj = null;
		try {
		    if (pass === undefined) {
			keyObj = KEYUTIL.getKey(keyparam);
		    } else {
			keyObj = KEYUTIL.getKey(keyparam, pass);
		    }
		} catch (ex) {
		    throw "init failed:" + ex;
		}

		if (keyObj.isPrivate === true) {
		    this.prvKey = keyObj;
		    this.state = "SIGN";
		} else if (keyObj.isPublic === true) {
		    this.pubKey = keyObj;
		    this.state = "VERIFY";
		} else {
		    throw "init failed.:" + keyObj;
		}
	    };

	    this.updateString = function(str) {
		this.md.updateString(str);
	    };

	    this.updateHex = function(hex) {
		this.md.updateHex(hex);
	    };

	    this.sign = function() {
		this.sHashHex = this.md.digest();
		// hex parameter EC public key
		if (this.prvKey === undefined &&
		    this.ecprvhex !== undefined &&
		    this.eccurvename !== undefined &&
		    KJUR.crypto.ECDSA !== undefined) {
		    this.prvKey = new KJUR.crypto.ECDSA({'curve': this.eccurvename,
							 prv: this.ecprvhex});
		}

		// RSAPSS
		if (this.prvKey instanceof RSAKey &&
		    this.pubkeyAlgName === "rsaandmgf1") {
		    this.hSign = this.prvKey.signWithMessageHashPSS(this.sHashHex,
								    this.mdAlgName,
								    this.pssSaltLen);
		// RSA
		} else if (this.prvKey instanceof RSAKey &&
			   this.pubkeyAlgName === "rsa") {
		    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex,
								 this.mdAlgName);
		// ECDSA
		} else if (this.prvKey instanceof KJUR.crypto.ECDSA) {
		    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);
		// DSA
		} else if (this.prvKey instanceof KJUR.crypto.DSA) {
		    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);
		} else {
		    throw "Signature: unsupported private key alg: " + this.pubkeyAlgName;
		}
		return this.hSign;
	    };
	    this.signString = function(str) {
		this.updateString(str);
		return this.sign();
	    };
	    this.signHex = function(hex) {
		this.updateHex(hex);
		return this.sign();
	    };
	    this.verify = function(hSigVal) {
	        this.sHashHex = this.md.digest();
		// hex parameter EC public key
		if (this.pubKey === undefined &&
		    this.ecpubhex !== undefined &&
		    this.eccurvename !== undefined &&
		    KJUR.crypto.ECDSA !== undefined) {
		    this.pubKey = new KJUR.crypto.ECDSA({curve: this.eccurvename,
							 pub: this.ecpubhex});
		}

		// RSAPSS
		if (this.pubKey instanceof RSAKey &&
		    this.pubkeyAlgName === "rsaandmgf1") {
		    return this.pubKey.verifyWithMessageHashPSS(this.sHashHex, hSigVal, 
								this.mdAlgName,
								this.pssSaltLen);
		// RSA
		} else if (this.pubKey instanceof RSAKey &&
			   this.pubkeyAlgName === "rsa") {
		    return this.pubKey.verifyWithMessageHash(this.sHashHex, hSigVal);
                // ECDSA
		} else if (KJUR.crypto.ECDSA !== undefined &&
			   this.pubKey instanceof KJUR.crypto.ECDSA) {
		    return this.pubKey.verifyWithMessageHash(this.sHashHex, hSigVal);
                // DSA
		} else if (KJUR.crypto.DSA !== undefined &&
			   this.pubKey instanceof KJUR.crypto.DSA) {
		    return this.pubKey.verifyWithMessageHash(this.sHashHex, hSigVal);
		} else {
		    throw "Signature: unsupported public key alg: " + this.pubkeyAlgName;
		}
	    };
	}
    };

    /**
     * Initialize this object for signing or verifying depends on key
     * @name init
     * @memberOf KJUR.crypto.Signature#
     * @function
     * @param {Object} key specifying public or private key as plain/encrypted PKCS#5/8 PEM file, certificate PEM or {@link RSAKey}, {@link KJUR.crypto.DSA} or {@link KJUR.crypto.ECDSA} object
     * @param {String} pass (OPTION) passcode for encrypted private key
     * @since crypto 1.1.3
     * @description
     * This method is very useful initialize method for Signature class since
     * you just specify key then this method will automatically initialize it
     * using {@link KEYUTIL.getKey} method.
     * As for 'key',  following argument type are supported:
     * <h5>signing</h5>
     * <ul>
     * <li>PEM formatted PKCS#8 encrypted RSA/ECDSA private key concluding "BEGIN ENCRYPTED PRIVATE KEY"</li>
     * <li>PEM formatted PKCS#5 encrypted RSA/DSA private key concluding "BEGIN RSA/DSA PRIVATE KEY" and ",ENCRYPTED"</li>
     * <li>PEM formatted PKCS#8 plain RSA/ECDSA private key concluding "BEGIN PRIVATE KEY"</li>
     * <li>PEM formatted PKCS#5 plain RSA/DSA private key concluding "BEGIN RSA/DSA PRIVATE KEY" without ",ENCRYPTED"</li>
     * <li>RSAKey object of private key</li>
     * <li>KJUR.crypto.ECDSA object of private key</li>
     * <li>KJUR.crypto.DSA object of private key</li>
     * </ul>
     * <h5>verification</h5>
     * <ul>
     * <li>PEM formatted PKCS#8 RSA/EC/DSA public key concluding "BEGIN PUBLIC KEY"</li>
     * <li>PEM formatted X.509 certificate with RSA/EC/DSA public key concluding
     *     "BEGIN CERTIFICATE", "BEGIN X509 CERTIFICATE" or "BEGIN TRUSTED CERTIFICATE".</li>
     * <li>RSAKey object of public key</li>
     * <li>KJUR.crypto.ECDSA object of public key</li>
     * <li>KJUR.crypto.DSA object of public key</li>
     * </ul>
     * @example
     * sig.init(sCertPEM)
     */
    this.init = function(key, pass) {
	throw "init(key, pass) not supported for this alg:prov=" +
	      this.algProvName;
    };

    /**
     * Updates the data to be signed or verified by a string
     * @name updateString
     * @memberOf KJUR.crypto.Signature#
     * @function
     * @param {String} str string to use for the update
     * @description
     * @example
     * sig.updateString('aaa')
     */
    this.updateString = function(str) {
	throw "updateString(str) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Updates the data to be signed or verified by a hexadecimal string
     * @name updateHex
     * @memberOf KJUR.crypto.Signature#
     * @function
     * @param {String} hex hexadecimal string to use for the update
     * @description
     * @example
     * sig.updateHex('1f2f3f')
     */
    this.updateHex = function(hex) {
	throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Returns the signature bytes of all data updates as a hexadecimal string
     * @name sign
     * @memberOf KJUR.crypto.Signature#
     * @function
     * @return the signature bytes as a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.sign()
     */
    this.sign = function() {
	throw "sign() not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string
     * @name signString
     * @memberOf KJUR.crypto.Signature#
     * @function
     * @param {String} str string to final update
     * @return the signature bytes of a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.signString('aaa')
     */
    this.signString = function(str) {
	throw "digestString(str) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string
     * @name signHex
     * @memberOf KJUR.crypto.Signature#
     * @function
     * @param {String} hex hexadecimal string to final update
     * @return the signature bytes of a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.signHex('1fdc33')
     */
    this.signHex = function(hex) {
	throw "digestHex(hex) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * verifies the passed-in signature.
     * @name verify
     * @memberOf KJUR.crypto.Signature#
     * @function
     * @param {String} str string to final update
     * @return {Boolean} true if the signature was verified, otherwise false
     * @description
     * @example
     * var isValid = sig.verify('1fbcefdca4823a7(snip)')
     */
    this.verify = function(hSigVal) {
	throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;
    };

    this.initParams = params;

    if (params !== undefined) {
	if (params.alg !== undefined) {
	    this.algName = params.alg;
	    if (params.prov === undefined) {
		this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
	    } else {
		this.provName = params.prov;
	    }
	    this.algProvName = this.algName + ":" + this.provName;
	    this.setAlgAndProvider(this.algName, this.provName);
	    this._setAlgNames();
	}

	if (params['psssaltlen'] !== undefined) this.pssSaltLen = params['psssaltlen'];

	if (params.prvkeypem !== undefined) {
	    if (params.prvkeypas !== undefined) {
		throw "both prvkeypem and prvkeypas parameters not supported";
	    } else {
		try {
		    var prvKey = KEYUTIL.getKey(params.prvkeypem);
		    this.init(prvKey);
		} catch (ex) {
		    throw "fatal error to load pem private key: " + ex;
		}
	    }
	}
    }
};

// ====== Cipher class ============================================================
/**
 * Cipher class to encrypt and decrypt data<br/>
 * @name KJUR.crypto.Cipher
 * @class Cipher class to encrypt and decrypt data<br/>
 * @param {Array} params parameters for constructor
 * @since jsrsasign 6.2.0 crypto 1.1.10
 * @description
 * Here is supported canonicalized cipher algorithm names and its standard names:
 * <ul>
 * <li>RSA - RSA/ECB/PKCS1Padding (default for RSAKey)</li>
 * <li>RSAOAEP - RSA/ECB/OAEPWithSHA-1AndMGF1Padding</li>
 * <li>RSAOAEP224 - RSA/ECB/OAEPWithSHA-224AndMGF1Padding(*)</li>
 * <li>RSAOAEP256 - RSA/ECB/OAEPWithSHA-256AndMGF1Padding</li>
 * <li>RSAOAEP384 - RSA/ECB/OAEPWithSHA-384AndMGF1Padding(*)</li>
 * <li>RSAOAEP512 - RSA/ECB/OAEPWithSHA-512AndMGF1Padding(*)</li>
 * </ul>
 * NOTE: (*) is not supported in Java JCE.<br/>
 * Currently this class supports only RSA encryption and decryption 
 * based on RSAES-OAEP and RSAES-PKCS1-v1_5 scheme. 
 * However it is planning to implement also symmetric ciphers near in the future */
KJUR.crypto.Cipher = function(params) {
};

/**
 * encrypt raw string by specified key and algorithm<br/>
 * @name encrypt
 * @memberOf KJUR.crypto.Cipher
 * @function
 * @param {String} s input string to encrypt
 * @param {Object} keyObj RSAKey object or hexadecimal string of symmetric cipher key
 * @param {String} algName short/long algorithm name for encryption/decryption 
 * @return {String} hexadecimal encrypted string
 * @since jsrsasign 6.2.0 crypto 1.1.10
 * @description
 * This static method encrypts raw string with specified key and algorithm.
 * @example 
 * KJUR.crypto.Cipher.encrypt("aaa", pubRSAKeyObj) &rarr; "1abc2d..."
 * KJUR.crypto.Cipher.encrypt("aaa", pubRSAKeyObj, "RSAOAEP") &rarr; "23ab02..."
 */
KJUR.crypto.Cipher.encrypt = function(s, keyObj, algName) {
    if (keyObj instanceof RSAKey && keyObj.isPublic) {
	var algName2 = KJUR.crypto.Cipher.getAlgByKeyAndName(keyObj, algName);
	if (algName2 === "RSA") return keyObj.encrypt(s);
	if (algName2 === "RSAOAEP") return keyObj.encryptOAEP(s, "sha1");

	var a = algName2.match(/^RSAOAEP(\d+)$/);
	if (a !== null) return keyObj.encryptOAEP(s, "sha" + a[1]);

	throw "Cipher.encrypt: unsupported algorithm for RSAKey: " + algName;
    } else {
	throw "Cipher.encrypt: unsupported key or algorithm";
    }
};

/**
 * decrypt encrypted hexadecimal string with specified key and algorithm<br/>
 * @name decrypt
 * @memberOf KJUR.crypto.Cipher
 * @function
 * @param {String} hex hexadecial string of encrypted message
 * @param {Object} keyObj RSAKey object or hexadecimal string of symmetric cipher key
 * @param {String} algName short/long algorithm name for encryption/decryption
 * @return {String} decrypted raw string
 * @since jsrsasign 6.2.0 crypto 1.1.10
 * @description
 * This static method decrypts encrypted hexadecimal string with specified key and algorithm.
 * @example 
 * KJUR.crypto.Cipher.decrypt("aaa", prvRSAKeyObj) &rarr; "1abc2d..."
 * KJUR.crypto.Cipher.decrypt("aaa", prvRSAKeyObj, "RSAOAEP) &rarr; "23ab02..."
 */
KJUR.crypto.Cipher.decrypt = function(hex, keyObj, algName) {
    if (keyObj instanceof RSAKey && keyObj.isPrivate) {
	var algName2 = KJUR.crypto.Cipher.getAlgByKeyAndName(keyObj, algName);
	if (algName2 === "RSA") return keyObj.decrypt(hex);
	if (algName2 === "RSAOAEP") return keyObj.decryptOAEP(hex, "sha1");

	var a = algName2.match(/^RSAOAEP(\d+)$/);
	if (a !== null) return keyObj.decryptOAEP(hex, "sha" + a[1]);

	throw "Cipher.decrypt: unsupported algorithm for RSAKey: " + algName;
    } else {
	throw "Cipher.decrypt: unsupported key or algorithm";
    }
};

/**
 * get canonicalized encrypt/decrypt algorithm name by key and short/long algorithm name<br/>
 * @name getAlgByKeyAndName
 * @memberOf KJUR.crypto.Cipher
 * @function
 * @param {Object} keyObj RSAKey object or hexadecimal string of symmetric cipher key
 * @param {String} algName short/long algorithm name for encryption/decryption
 * @return {String} canonicalized algorithm name for encryption/decryption
 * @since jsrsasign 6.2.0 crypto 1.1.10
 * @description
 * Here is supported canonicalized cipher algorithm names and its standard names:
 * <ul>
 * <li>RSA - RSA/ECB/PKCS1Padding (default for RSAKey)</li>
 * <li>RSAOAEP - RSA/ECB/OAEPWithSHA-1AndMGF1Padding</li>
 * <li>RSAOAEP224 - RSA/ECB/OAEPWithSHA-224AndMGF1Padding(*)</li>
 * <li>RSAOAEP256 - RSA/ECB/OAEPWithSHA-256AndMGF1Padding</li>
 * <li>RSAOAEP384 - RSA/ECB/OAEPWithSHA-384AndMGF1Padding(*)</li>
 * <li>RSAOAEP512 - RSA/ECB/OAEPWithSHA-512AndMGF1Padding(*)</li>
 * </ul>
 * NOTE: (*) is not supported in Java JCE.
 * @example 
 * KJUR.crypto.Cipher.getAlgByKeyAndName(objRSAKey) &rarr; "RSA"
 * KJUR.crypto.Cipher.getAlgByKeyAndName(objRSAKey, "RSAOAEP") &rarr; "RSAOAEP"
 */
KJUR.crypto.Cipher.getAlgByKeyAndName = function(keyObj, algName) {
    if (keyObj instanceof RSAKey) {
	if (":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(algName) != -1)
	    return algName;
	if (algName === null || algName === undefined) return "RSA";
	throw "getAlgByKeyAndName: not supported algorithm name for RSAKey: " + algName;
    }
    throw "getAlgByKeyAndName: not supported algorithm name: " + algName;
}

// ====== Other Utility class =====================================================

/**
 * static object for cryptographic function utilities
 * @name KJUR.crypto.OID
 * @class static object for cryptography related OIDs
 * @property {Array} oidhex2name key value of hexadecimal OID and its name
 *           (ex. '2a8648ce3d030107' and 'secp256r1')
 * @since crypto 1.1.3
 * @description
 */
KJUR.crypto.OID = new function() {
    this.oidhex2name = {
	'2a864886f70d010101': 'rsaEncryption',
	'2a8648ce3d0201': 'ecPublicKey',
	'2a8648ce380401': 'dsa',
	'2a8648ce3d030107': 'secp256r1',
	'2b8104001f': 'secp192k1',
	'2b81040021': 'secp224r1',
	'2b8104000a': 'secp256k1',
	'2b81040022': 'secp384r1',
	'2b81040023': 'secp521r1',
	'2a8648ce380403': 'SHA1withDSA', // 1.2.840.10040.4.3
	'608648016503040301': 'SHA224withDSA', // 2.16.840.1.101.3.4.3.1
	'608648016503040302': 'SHA256withDSA', // 2.16.840.1.101.3.4.3.2
    };
};

/* ecdsa-modified-1.2.2.js (c) Stephan Thomas, Kenji Urushima | github.com/bitcoinjs/bitcoinjs-lib/blob/master/LICENSE
 */
/*
 * ecdsa-modified.js - modified Bitcoin.ECDSA class
 * 
 * Copyright (c) 2013-2021 Stefan Thomas (github.com/justmoon)
 *                         Kenji Urushima (kenji.urushima@gmail.com)
 * LICENSE
 *   https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/LICENSE
 */

/**
 * @fileOverview
 * @name ecdsa-modified-1.0.js
 * @author Stefan Thomas (github.com/justmoon) and Kenji Urushima (kenji.urushima@gmail.com)
 * @version jsrsasign 10.5.16 ecdsa-modified 1.2.2 (2022-Apr-08)
 * @since jsrsasign 4.0
 * @license <a href="https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/LICENSE">MIT License</a>
 */

if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};

/**
 * class for EC key generation,  ECDSA signing and verifcation
 * @name KJUR.crypto.ECDSA
 * @class class for EC key generation,  ECDSA signing and verifcation
 * @description
 * <p>
 * CAUTION: Most of the case, you don't need to use this class except
 * for generating an EC key pair. Please use {@link KJUR.crypto.Signature} class instead.
 * </p>
 * <p>
 * This class was originally developped by Stefan Thomas for Bitcoin JavaScript library.
 * (See {@link https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/src/ecdsa.js})
 * Currently this class supports following named curves and their aliases.
 * <ul>
 * <li>secp192k1</li>
 * <li>secp256r1, NIST P-256, P-256, prime256v1 (*)</li>
 * <li>secp256k1 (*)</li>
 * <li>secp384r1, NIST P-384, P-384 (*)</li>
 * <li>secp521r1, NIST P-521, P-521 (*)</li>
 * </ul>
 * </p>
 */
KJUR.crypto.ECDSA = function(params) {
    var curveName = "secp256r1";	// curve name default
    var ecparams = null;
    var prvKeyHex = null;
    var pubKeyHex = null;
    var _Error = Error,
	_BigInteger = BigInteger,
	_ECPointFp = ECPointFp,
	_KJUR_crypto_ECDSA = KJUR.crypto.ECDSA,
	_KJUR_crypto_ECParameterDB = KJUR.crypto.ECParameterDB,
	_getName = _KJUR_crypto_ECDSA.getName,
	_ASN1HEX = ASN1HEX,
	_getVbyListEx = _ASN1HEX.getVbyListEx,
	_isASN1HEX = _ASN1HEX.isASN1HEX;

    var rng = new SecureRandom();

    var P_OVER_FOUR = null;

    this.type = "EC";
    this.isPrivate = false;
    this.isPublic = false;

    function implShamirsTrick(P, k, Q, l) {
	var m = Math.max(k.bitLength(), l.bitLength());
	var Z = P.add2D(Q);
	var R = P.curve.getInfinity();

	for (var i = m - 1; i >= 0; --i) {
	    R = R.twice2D();

	    R.z = _BigInteger.ONE;

	    if (k.testBit(i)) {
		if (l.testBit(i)) {
		    R = R.add2D(Z);
		} else {
		    R = R.add2D(P);
		}
	    } else {
		if (l.testBit(i)) {
		    R = R.add2D(Q);
		}
	    }
	}
	
	return R;
    };

    //===========================
    // PUBLIC METHODS
    //===========================
    this.getBigRandom = function (limit) {
	return new _BigInteger(limit.bitLength(), rng)
	.mod(limit.subtract(_BigInteger.ONE))
	.add(_BigInteger.ONE)
	;
    };

    this.setNamedCurve = function(curveName) {
	this.ecparams = _KJUR_crypto_ECParameterDB.getByName(curveName);
	this.prvKeyHex = null;
	this.pubKeyHex = null;
	this.curveName = curveName;
    };

    this.setPrivateKeyHex = function(prvKeyHex) {
        this.isPrivate = true;
	this.prvKeyHex = prvKeyHex;
    };

    this.setPublicKeyHex = function(pubKeyHex) {
        this.isPublic = true;
	this.pubKeyHex = pubKeyHex;
    };

    /**
     * get X and Y hexadecimal string value of public key
     * @name getPublicKeyXYHex
     * @memberOf KJUR.crypto.ECDSA#
     * @function
     * @return {Array} associative array of x and y value of public key
     * @since ecdsa-modified 1.0.5 jsrsasign 5.0.14
     * @example
     * ec = new KJUR.crypto.ECDSA({'curve': 'secp256r1', 'pub': pubHex});
     * ec.getPublicKeyXYHex() &rarr; { x: '01bacf...', y: 'c3bc22...' }
     */
    this.getPublicKeyXYHex = function() {
	var h = this.pubKeyHex;
	if (h.substr(0, 2) !== "04")
	    throw "this method supports uncompressed format(04) only";

	var charlen = this.ecparams.keycharlen;
	if (h.length !== 2 + charlen * 2)
	    throw "malformed public key hex length";

	var result = {};
	result.x = h.substr(2, charlen);
	result.y = h.substr(2 + charlen);
	return result;
    };

    /**
     * get NIST curve short name such as "P-256" or "P-384"
     * @name getShortNISTPCurveName
     * @memberOf KJUR.crypto.ECDSA#
     * @function
     * @return {String} short NIST P curve name such as "P-256" or "P-384" if it's NIST P curve otherwise null;
     * @since ecdsa-modified 1.0.5 jsrsasign 5.0.14
     * @example
     * ec = new KJUR.crypto.ECDSA({'curve': 'secp256r1', 'pub': pubHex});
     * ec.getShortPCurveName() &rarr; "P-256";
     */
    this.getShortNISTPCurveName = function() {
	var s = this.curveName;
	if (s === "secp256r1" || s === "NIST P-256" ||
	    s === "P-256" || s === "prime256v1")
	    return "P-256";
	if (s === "secp384r1" || s === "NIST P-384" || s === "P-384")
	    return "P-384";
	if (s === "secp521r1" || s === "NIST P-521" || s === "P-521")
	    return "P-521";
	return null;
    };

    /**
     * generate a EC key pair
     * @name generateKeyPairHex
     * @memberOf KJUR.crypto.ECDSA#
     * @function
     * @return {Array} associative array of hexadecimal string of private and public key
     * @since ecdsa-modified 1.0.1
     * @example
     * var ec = new KJUR.crypto.ECDSA({'curve': 'secp256r1'});
     * var keypair = ec.generateKeyPairHex();
     * var pubhex = keypair.ecpubhex; // hexadecimal string of EC public key
     * var prvhex = keypair.ecprvhex; // hexadecimal string of EC private key (=d)
     */
    this.generateKeyPairHex = function() {
	var biN = this.ecparams['n'];
	var biPrv = this.getBigRandom(biN);
	var charlen = this.ecparams.keycharlen;
	var hPrv = ("0000000000" + biPrv.toString(16)).slice(- charlen);
	this.setPrivateKeyHex(hPrv);
	var hPub = this.generatePublicKeyHex();
	return {'ecprvhex': hPrv, 'ecpubhex': hPub};
    };

	/**
     * generate public key for EC private key
     * @name generatePublicKeyHex
     * @memberOf KJUR.crypto.ECDSA#
     * @function
     * @return {String} associative array of hexadecimal string of private and public key
     * @example
     * var ec = new KJUR.crypto.ECDSA({'curve': 'secp256r1', 'prv': prvHex});
     * var pubhex = ec.generatePublicKeyHex(); // hexadecimal string of EC public key
     * var pub ec.getPublicKeyXYHex() &rarr; { x: '01bacf...', y: 'c3bc22...' }
     */
	this.generatePublicKeyHex = function() {
		var biPrv = new _BigInteger(this.prvKeyHex, 16);
		var epPub = this.ecparams['G'].multiply(biPrv);
		var biX = epPub.getX().toBigInteger();
		var biY = epPub.getY().toBigInteger();
		var charlen = this.ecparams.keycharlen;;
		var hX   = ("0000000000" + biX.toString(16)).slice(- charlen);
		var hY   = ("0000000000" + biY.toString(16)).slice(- charlen);
		var hPub = "04" + hX + hY;
		this.setPublicKeyHex(hPub);
		return hPub;
	}

    this.signWithMessageHash = function(hashHex) {
	return this.signHex(hashHex, this.prvKeyHex);
    };

    /**
     * signing to message hash
     * @name signHex
     * @memberOf KJUR.crypto.ECDSA#
     * @function
     * @param {String} hashHex hexadecimal string of hash value of signing message
     * @param {String} privHex hexadecimal string of EC private key
     * @return {String} hexadecimal string of ECDSA signature
     * @since ecdsa-modified 1.0.1
     * @example
     * var ec = new KJUR.crypto.ECDSA({'curve': 'secp256r1'});
     * var sigValue = ec.signHex(hash, prvKey);
     */
    this.signHex = function (hashHex, privHex) {
	var d = new _BigInteger(privHex, 16);
	var n = this.ecparams['n'];

	// message hash is truncated with curve key length (FIPS 186-4 6.4)
        var e = new _BigInteger(hashHex.substring(0, this.ecparams.keycharlen), 16);

	do {
	    var k = this.getBigRandom(n);
	    var G = this.ecparams['G'];
	    var Q = G.multiply(k);
	    var r = Q.getX().toBigInteger().mod(n);
	} while (r.compareTo(_BigInteger.ZERO) <= 0);

	var s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);

	return _KJUR_crypto_ECDSA.biRSSigToASN1Sig(r, s);
    };

    this.sign = function (hash, priv) {
	var d = priv;
	var n = this.ecparams['n'];
	var e = _BigInteger.fromByteArrayUnsigned(hash);

	do {
	    var k = this.getBigRandom(n);
	    var G = this.ecparams['G'];
	    var Q = G.multiply(k);
	    var r = Q.getX().toBigInteger().mod(n);
	} while (r.compareTo(BigInteger.ZERO) <= 0);

	var s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
	return this.serializeSig(r, s);
    };

    this.verifyWithMessageHash = function(hashHex, sigHex) {
	return this.verifyHex(hashHex, sigHex, this.pubKeyHex);
    };

    /**
     * verifying signature with message hash and public key
     * @name verifyHex
     * @memberOf KJUR.crypto.ECDSA#
     * @function
     * @param {String} hashHex hexadecimal string of hash value of signing message
     * @param {String} sigHex hexadecimal string of signature value
     * @param {String} pubkeyHex hexadecimal string of public key
     * @return {Boolean} true if the signature is valid, otherwise false
     * @since ecdsa-modified 1.0.1
     * @example
     * var ec = new KJUR.crypto.ECDSA({'curve': 'secp256r1'});
     * var result = ec.verifyHex(msgHashHex, sigHex, pubkeyHex);
     */
    this.verifyHex = function(hashHex, sigHex, pubkeyHex) {
	try {
	    var r,s;

	    var obj = _KJUR_crypto_ECDSA.parseSigHex(sigHex);
	    r = obj.r;
	    s = obj.s;
	    
	    var Q = _ECPointFp.decodeFromHex(this.ecparams['curve'], pubkeyHex);

	    // message hash is truncated with curve key length (FIPS 186-4 6.4)
            var e = new _BigInteger(hashHex.substring(0, this.ecparams.keycharlen), 16);

	    return this.verifyRaw(e, r, s, Q);
	} catch (ex) {
	    return false;
	}
    };

    this.verify = function (hash, sig, pubkey) {
	var r,s;
	if (Bitcoin.Util.isArray(sig)) {
	    var obj = this.parseSig(sig);
	    r = obj.r;
	    s = obj.s;
	} else if ("object" === typeof sig && sig.r && sig.s) {
	    r = sig.r;
	    s = sig.s;
	} else {
	    throw "Invalid value for signature";
	}

	var Q;
	if (pubkey instanceof ECPointFp) {
	    Q = pubkey;
	} else if (Bitcoin.Util.isArray(pubkey)) {
	    Q = _ECPointFp.decodeFrom(this.ecparams['curve'], pubkey);
	} else {
	    throw "Invalid format for pubkey value, must be byte array or ECPointFp";
	}
	var e = _BigInteger.fromByteArrayUnsigned(hash);

	return this.verifyRaw(e, r, s, Q);
    };

    this.verifyRaw = function (e, r, s, Q) {
	var n = this.ecparams['n'];
	var G = this.ecparams['G'];

	if (r.compareTo(_BigInteger.ONE) < 0 ||
	    r.compareTo(n) >= 0)
	    return false;

	if (s.compareTo(_BigInteger.ONE) < 0 ||
	    s.compareTo(n) >= 0)
	    return false;

	var c = s.modInverse(n);

	var u1 = e.multiply(c).mod(n);
	var u2 = r.multiply(c).mod(n);

	// TODO(!!!): For some reason Shamir's trick isn't working with
	// signed message verification!? Probably an implementation
	// error!
	//var point = implShamirsTrick(G, u1, Q, u2);
	var point = G.multiply(u1).add(Q.multiply(u2));

	var v = point.getX().toBigInteger().mod(n);

	return v.equals(r);
    };

    /**
     * Serialize a signature into DER format.
     *
     * Takes two BigIntegers representing r and s and returns a byte array.
     */
    this.serializeSig = function (r, s) {
	var rBa = r.toByteArraySigned();
	var sBa = s.toByteArraySigned();

	var sequence = [];
	sequence.push(0x02); // INTEGER
	sequence.push(rBa.length);
	sequence = sequence.concat(rBa);

	sequence.push(0x02); // INTEGER
	sequence.push(sBa.length);
	sequence = sequence.concat(sBa);

	sequence.unshift(sequence.length);
	sequence.unshift(0x30); // SEQUENCE
	return sequence;
    };

    /**
     * Parses a byte array containing a DER-encoded signature.
     *
     * This function will return an object of the form:
     *
     * {
     *   r: BigInteger,
     *   s: BigInteger
     * }
     */
    this.parseSig = function (sig) {
	var cursor;
	if (sig[0] != 0x30)
	    throw new Error("Signature not a valid DERSequence");

	cursor = 2;
	if (sig[cursor] != 0x02)
	    throw new Error("First element in signature must be a DERInteger");;
	var rBa = sig.slice(cursor+2, cursor+2+sig[cursor+1]);

	cursor += 2+sig[cursor+1];
	if (sig[cursor] != 0x02)
	    throw new Error("Second element in signature must be a DERInteger");
	var sBa = sig.slice(cursor+2, cursor+2+sig[cursor+1]);

	cursor += 2+sig[cursor+1];

	//if (cursor != sig.length)
	//  throw new Error("Extra bytes in signature");

	var r = _BigInteger.fromByteArrayUnsigned(rBa);
	var s = _BigInteger.fromByteArrayUnsigned(sBa);

	return {r: r, s: s};
    };

    this.parseSigCompact = function (sig) {
	if (sig.length !== 65) {
	    throw "Signature has the wrong length";
	}

	// Signature is prefixed with a type byte storing three bits of
	// information.
	var i = sig[0] - 27;
	if (i < 0 || i > 7) {
	    throw "Invalid signature type";
	}

	var n = this.ecparams['n'];
	var r = _BigInteger.fromByteArrayUnsigned(sig.slice(1, 33)).mod(n);
	var s = _BigInteger.fromByteArrayUnsigned(sig.slice(33, 65)).mod(n);

	return {r: r, s: s, i: i};
    };

    /**
     * read an ASN.1 hexadecimal string of PKCS#1/5 plain ECC private key<br/>
     * @name readPKCS5PrvKeyHex
     * @memberOf KJUR.crypto.ECDSA#
     * @function
     * @param {String} h hexadecimal string of PKCS#1/5 ECC private key
     * @since jsrsasign 7.1.0 ecdsa-modified 1.1.0
     */
    this.readPKCS5PrvKeyHex = function(h) {
	if (_isASN1HEX(h) === false)
	    throw new Error("not ASN.1 hex string");

	var hCurve, hPrv, hPub;
	try {
	    hCurve = _getVbyListEx(h, 0, ["[0]", 0], "06");
	    hPrv   = _getVbyListEx(h, 0, [1], "04");
	    try {
		hPub = _getVbyListEx(h, 0, ["[1]", 0], "03");
	    } catch(ex) {};
	} catch(ex) {
	    throw new Error("malformed PKCS#1/5 plain ECC private key");
	}

	this.curveName = _getName(hCurve);
	if (this.curveName === undefined) throw "unsupported curve name";

	this.setNamedCurve(this.curveName);
	this.setPublicKeyHex(hPub);
	this.setPrivateKeyHex(hPrv);
        this.isPublic = false;
    };

    /**
     * read an ASN.1 hexadecimal string of PKCS#8 plain ECC private key<br/>
     * @name readPKCS8PrvKeyHex
     * @memberOf KJUR.crypto.ECDSA#
     * @function
     * @param {String} h hexadecimal string of PKCS#8 ECC private key
     * @since jsrsasign 7.1.0 ecdsa-modified 1.1.0
     */
    this.readPKCS8PrvKeyHex = function(h) {
	if (_isASN1HEX(h) === false)
	    throw new _Error("not ASN.1 hex string");

	var hECOID, hCurve, hPrv, hPub;
	try {
	    hECOID = _getVbyListEx(h, 0, [1, 0], "06");
	    hCurve = _getVbyListEx(h, 0, [1, 1], "06");
	    hPrv   = _getVbyListEx(h, 0, [2, 0, 1], "04");
	    try {
		hPub = _getVbyListEx(h, 0, [2, 0, "[1]", 0], "03"); //.substr(2);
	    } catch(ex) {};
	} catch(ex) {
	    throw new _Error("malformed PKCS#8 plain ECC private key");
	}

	this.curveName = _getName(hCurve);
	if (this.curveName === undefined)
	    throw new _Error("unsupported curve name");

	this.setNamedCurve(this.curveName);
	this.setPublicKeyHex(hPub);
	this.setPrivateKeyHex(hPrv);
        this.isPublic = false;
    };

    /**
     * read an ASN.1 hexadecimal string of PKCS#8 ECC public key<br/>
     * @name readPKCS8PubKeyHex
     * @memberOf KJUR.crypto.ECDSA#
     * @function
     * @param {String} h hexadecimal string of PKCS#8 ECC public key
     * @since jsrsasign 7.1.0 ecdsa-modified 1.1.0
     */
    this.readPKCS8PubKeyHex = function(h) {
	if (_isASN1HEX(h) === false)
	    throw new _Error("not ASN.1 hex string");

	var hECOID, hCurve, hPub;
	try {
	    hECOID = _getVbyListEx(h, 0, [0, 0], "06");
	    hCurve = _getVbyListEx(h, 0, [0, 1], "06");
	    hPub = _getVbyListEx(h, 0, [1], "03"); //.substr(2); 
	} catch(ex) {
	    throw new _Error("malformed PKCS#8 ECC public key");
	}

	this.curveName = _getName(hCurve);
	if (this.curveName === null)
	    throw new _Error("unsupported curve name");

	this.setNamedCurve(this.curveName);
	this.setPublicKeyHex(hPub);
    };

    /**
     * read an ASN.1 hexadecimal string of X.509 ECC public key certificate<br/>
     * @name readCertPubKeyHex
     * @memberOf KJUR.crypto.ECDSA#
     * @function
     * @param {String} h hexadecimal string of X.509 ECC public key certificate
     * @param {Integer} nthPKI nth index of publicKeyInfo. (DEFAULT: 6 for X509v3)
     * @since jsrsasign 7.1.0 ecdsa-modified 1.1.0
     */
    this.readCertPubKeyHex = function(h, nthPKI) {
	if (_isASN1HEX(h) === false)
	    throw new _Error("not ASN.1 hex string");

	var hCurve, hPub;
	try {
	    hCurve = _getVbyListEx(h, 0, [0, 5, 0, 1], "06");
	    hPub = _getVbyListEx(h, 0, [0, 5, 1], "03");
	} catch(ex) {
	    throw new _Error("malformed X.509 certificate ECC public key");
	}

	this.curveName = _getName(hCurve);
	if (this.curveName === null)
	    throw new _Error("unsupported curve name");

	this.setNamedCurve(this.curveName);
	this.setPublicKeyHex(hPub);
    };

    /*
     * Recover a public key from a signature.
     *
     * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, "Public
     * Key Recovery Operation".
     *
     * http://www.secg.org/download/aid-780/sec1-v2.pdf
     */
    /*
    recoverPubKey: function (r, s, hash, i) {
	// The recovery parameter i has two bits.
	i = i & 3;

	// The less significant bit specifies whether the y coordinate
	// of the compressed point is even or not.
	var isYEven = i & 1;

	// The more significant bit specifies whether we should use the
	// first or second candidate key.
	var isSecondKey = i >> 1;

	var n = this.ecparams['n'];
	var G = this.ecparams['G'];
	var curve = this.ecparams['curve'];
	var p = curve.getQ();
	var a = curve.getA().toBigInteger();
	var b = curve.getB().toBigInteger();

	// We precalculate (p + 1) / 4 where p is if the field order
	if (!P_OVER_FOUR) {
	    P_OVER_FOUR = p.add(BigInteger.ONE).divide(BigInteger.valueOf(4));
	}

	// 1.1 Compute x
	var x = isSecondKey ? r.add(n) : r;

	// 1.3 Convert x to point
	var alpha = x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(p);
	var beta = alpha.modPow(P_OVER_FOUR, p);

	var xorOdd = beta.isEven() ? (i % 2) : ((i+1) % 2);
	// If beta is even, but y isn't or vice versa, then convert it,
	// otherwise we're done and y == beta.
	var y = (beta.isEven() ? !isYEven : isYEven) ? beta : p.subtract(beta);

	// 1.4 Check that nR is at infinity
	var R = new ECPointFp(curve,
			      curve.fromBigInteger(x),
			      curve.fromBigInteger(y));
	R.validate();

	// 1.5 Compute e from M
	var e = BigInteger.fromByteArrayUnsigned(hash);
	var eNeg = BigInteger.ZERO.subtract(e).mod(n);

	// 1.6 Compute Q = r^-1 (sR - eG)
	var rInv = r.modInverse(n);
	var Q = implShamirsTrick(R, s, G, eNeg).multiply(rInv);

	Q.validate();
	if (!this.verifyRaw(e, r, s, Q)) {
	    throw "Pubkey recovery unsuccessful";
	}

	var pubKey = new Bitcoin.ECKey();
	pubKey.pub = Q;
	return pubKey;
    },
    */

    /*
     * Calculate pubkey extraction parameter.
     *
     * When extracting a pubkey from a signature, we have to
     * distinguish four different cases. Rather than putting this
     * burden on the verifier, Bitcoin includes a 2-bit value with the
     * signature.
     *
     * This function simply tries all four cases and returns the value
     * that resulted in a successful pubkey recovery.
     */
    /*
    calcPubkeyRecoveryParam: function (address, r, s, hash) {
	for (var i = 0; i < 4; i++) {
	    try {
		var pubkey = Bitcoin.ECDSA.recoverPubKey(r, s, hash, i);
		if (pubkey.getBitcoinAddress().toString() == address) {
		    return i;
		}
	    } catch (e) {}
	}
	throw "Unable to find valid recovery factor";
    }
    */

    if (params !== undefined) {
	if (params['curve'] !== undefined) {
	    this.curveName = params['curve'];
	}
    }
    if (this.curveName === undefined) this.curveName = curveName;
    this.setNamedCurve(this.curveName);
    if (params !== undefined) {
	if (params.prv !== undefined) this.setPrivateKeyHex(params.prv);
	if (params.pub !== undefined) this.setPublicKeyHex(params.pub);
    }
};

/**
 * parse ASN.1 DER encoded ECDSA signature
 * @name parseSigHex
 * @memberOf KJUR.crypto.ECDSA
 * @function
 * @static
 * @param {String} sigHex hexadecimal string of ECDSA signature value
 * @return {Array} associative array of signature field r and s of BigInteger
 * @since ecdsa-modified 1.0.1
 * @see {@link KJUR.crypto.ECDSA.parseSigHexInHexRS}
 * @see {@link ASN1HEX.checkStrictDER}
 * @throws Error when signature value is malformed.
 * @example
 * var ec = new KJUR.crypto.ECDSA({'curve': 'secp256r1'});
 * var sig = ec.parseSigHex('30...');
 * var biR = sig.r; // BigInteger object for 'r' field of signature.
 * var biS = sig.s; // BigInteger object for 's' field of signature.
 */
KJUR.crypto.ECDSA.parseSigHex = function(sigHex) {
    var p = KJUR.crypto.ECDSA.parseSigHexInHexRS(sigHex);
    var biR = new BigInteger(p.r, 16);
    var biS = new BigInteger(p.s, 16);
    
    return {'r': biR, 's': biS};
};

/**
 * parse ASN.1 DER encoded ECDSA signature
 * @name parseSigHexInHexRS
 * @memberOf KJUR.crypto.ECDSA
 * @function
 * @static
 * @param {String} sigHex hexadecimal string of ECDSA signature value
 * @return {Array} associative array of signature field r and s in hexadecimal
 * @since ecdsa-modified 1.0.3
 * @see {@link KJUR.crypto.ECDSA.parseSigHex}
 * @see {@link ASN1HEX.checkStrictDER}
 * @throws Error when signature value is malformed.
 * @example
 * var ec = new KJUR.crypto.ECDSA({'curve': 'secp256r1'});
 * var sig = ec.parseSigHexInHexRS('30...');
 * var hR = sig.r; // hexadecimal string for 'r' field of signature.
 * var hS = sig.s; // hexadecimal string for 's' field of signature.
 */
KJUR.crypto.ECDSA.parseSigHexInHexRS = function(sigHex) {
    var _ASN1HEX = ASN1HEX,
	_getChildIdx = _ASN1HEX.getChildIdx,
	_getV = _ASN1HEX.getV;

    // 1. strict DER check
    _ASN1HEX.checkStrictDER(sigHex, 0);

    // 2. ASN.1 Sequence Check
    if (sigHex.substr(0, 2) != "30")
	throw new Error("signature is not a ASN.1 sequence");

    // 2. Items of ASN.1 Sequence Check
    var a = _getChildIdx(sigHex, 0);
    if (a.length != 2)
	throw new Error("signature shall have two elements");

    // 3. Integer tag check
    var iTLV1 = a[0];
    var iTLV2 = a[1];

    if (sigHex.substr(iTLV1, 2) != "02")
	throw new Error("1st item not ASN.1 integer");
    if (sigHex.substr(iTLV2, 2) != "02")
	throw new Error("2nd item not ASN.1 integer");

    // 4. getting value and least zero check for DER
    var hR = _getV(sigHex, iTLV1);
    var hS = _getV(sigHex, iTLV2);

    return {'r': hR, 's': hS};
};

/**
 * convert hexadecimal ASN.1 encoded signature to concatinated signature
 * @name asn1SigToConcatSig
 * @memberOf KJUR.crypto.ECDSA
 * @function
 * @static
 * @param {String} asn1Hex hexadecimal string of ASN.1 encoded ECDSA signature value
 * @return {String} r-s concatinated format of ECDSA signature value
 * @throws Error when signature length is unsupported
 * @since ecdsa-modified 1.0.3
 */
KJUR.crypto.ECDSA.asn1SigToConcatSig = function(asn1Sig) {
    var pSig = KJUR.crypto.ECDSA.parseSigHexInHexRS(asn1Sig);
    var hR = pSig.r;
    var hS = pSig.s;

	// P-521 special case (65-66 bytes are allowed)
	if (hR.length >= 130 && hR.length <= 134) {
		if (hR.length % 2 != 0) {
			throw Error("unknown ECDSA sig r length error");
		}
		if (hS.length % 2 != 0) {
			throw Error("unknown ECDSA sig s length error");
		}
		if (hR.substr(0, 2) == "00") hR = hR.substr(2);
		if (hS.substr(0, 2) == "00") hS = hS.substr(2);

		// make sure they have the same length
		var length = Math.max(hR.length, hS.length);
		hR = ("000000" + hR).slice(- length);
		hS = ("000000" + hS).slice(- length);

		return hR + hS;
	}

    // R and S length is assumed multiple of 128bit(32chars in hex).
    // If leading is "00" and modulo of length is 2(chars) then
    // leading "00" is for two's complement and will be removed.
    if (hR.substr(0, 2) == "00" && (hR.length % 32) == 2)
	hR = hR.substr(2);

    if (hS.substr(0, 2) == "00" && (hS.length % 32) == 2)
	hS = hS.substr(2);

    // R and S length is assumed multiple of 128bit(32chars in hex).
    // If missing two chars then it will be padded by "00".
    if ((hR.length % 32) == 30) hR = "00" + hR;
    if ((hS.length % 32) == 30) hS = "00" + hS;

    // If R and S length is not still multiple of 128bit(32 chars),
    // then error
    if (hR.length % 32 != 0)
	throw Error("unknown ECDSA sig r length error");
    if (hS.length % 32 != 0)
	throw Error("unknown ECDSA sig s length error");

    return hR + hS;
};

/**
 * convert hexadecimal concatinated signature to ASN.1 encoded signature
 * @name concatSigToASN1Sig
 * @memberOf KJUR.crypto.ECDSA
 * @function
 * @static
 * @param {String} concatSig r-s concatinated format of ECDSA signature value
 * @return {String} hexadecimal string of ASN.1 encoded ECDSA signature value
 * @throws Error when signature length is unsupported
 * @since ecdsa-modified 1.0.3
 */
KJUR.crypto.ECDSA.concatSigToASN1Sig = function(concatSig) {
	if (concatSig.length % 4 != 0) {
		throw Error("unknown ECDSA concatinated r-s sig length error");
	}

    var hR = concatSig.substr(0, concatSig.length / 2);
    var hS = concatSig.substr(concatSig.length / 2);
    return KJUR.crypto.ECDSA.hexRSSigToASN1Sig(hR, hS);
};

/**
 * convert hexadecimal R and S value of signature to ASN.1 encoded signature
 * @name hexRSSigToASN1Sig
 * @memberOf KJUR.crypto.ECDSA
 * @function
 * @static
 * @param {String} hR hexadecimal string of R field of ECDSA signature value
 * @param {String} hS hexadecimal string of S field of ECDSA signature value
 * @return {String} hexadecimal string of ASN.1 encoded ECDSA signature value
 * @since ecdsa-modified 1.0.3
 */
KJUR.crypto.ECDSA.hexRSSigToASN1Sig = function(hR, hS) {
    var biR = new BigInteger(hR, 16);
    var biS = new BigInteger(hS, 16);
    return KJUR.crypto.ECDSA.biRSSigToASN1Sig(biR, biS);
};

/**
 * convert R and S BigInteger object of signature to ASN.1 encoded signature
 * @name biRSSigToASN1Sig
 * @memberOf KJUR.crypto.ECDSA
 * @function
 * @static
 * @param {BigInteger} biR BigInteger object of R field of ECDSA signature value
 * @param {BigInteger} biS BIgInteger object of S field of ECDSA signature value
 * @return {String} hexadecimal string of ASN.1 encoded ECDSA signature value
 * @since ecdsa-modified 1.0.3
 */
KJUR.crypto.ECDSA.biRSSigToASN1Sig = function(biR, biS) {
    var _KJUR_asn1 = KJUR.asn1;
    var derR = new _KJUR_asn1.DERInteger({'bigint': biR});
    var derS = new _KJUR_asn1.DERInteger({'bigint': biS});
    var derSeq = new _KJUR_asn1.DERSequence({'array': [derR, derS]});
    return derSeq.tohex();
};

/**
 * static method to get normalized EC curve name from curve name or hexadecimal OID value
 * @name getName
 * @memberOf KJUR.crypto.ECDSA
 * @function
 * @static
 * @param {String} s curve name (ex. P-256) or hexadecimal OID value (ex. 2a86...)
 * @return {String} normalized EC curve name (ex. secp256r1) 
 * @since jsrsasign 7.1.0 ecdsa-modified 1.1.0 
 * @description
 * This static method returns normalized EC curve name 
 * which is supported in jsrsasign
 * from curve name or hexadecimal OID value.
 * When curve is not supported in jsrsasign, this method returns null.
 * Normalized name will be "secp*" in jsrsasign.
 * @example
 * KJUR.crypto.ECDSA.getName("2b8104000a") &rarr; "secp256k1"
 * KJUR.crypto.ECDSA.getName("NIST P-256") &rarr; "secp256r1"
 * KJUR.crypto.ECDSA.getName("P-521") &rarr; undefined // not supported
 */
KJUR.crypto.ECDSA.getName = function(s) {
    if (s === "2b8104001f") return "secp192k1"; // 1.3.132.0.31
    if (s === "2a8648ce3d030107") return "secp256r1"; // 1.2.840.10045.3.1.7
    if (s === "2b8104000a") return "secp256k1"; // 1.3.132.0.10
    if (s === "2b81040021") return "secp224r1"; // 1.3.132.0.33
    if (s === "2b81040022") return "secp384r1"; // 1.3.132.0.34
	if (s === "2b81040023") return "secp521r1"; // 1.3.132.0.35
    if ("|secp256r1|NIST P-256|P-256|prime256v1|".indexOf(s) !== -1) return "secp256r1";
    if ("|secp256k1|".indexOf(s) !== -1) return "secp256k1";
    if ("|secp224r1|NIST P-224|P-224|".indexOf(s) !== -1) return "secp224r1";
    if ("|secp384r1|NIST P-384|P-384|".indexOf(s) !== -1) return "secp384r1";
	if ("|secp521r1|NIST P-521|P-521|".indexOf(s) !== -1) return "secp521r1";
    return null;
};




/* ecparam-1.0.1.js (c) 2013-2021 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * ecparam.js - Elliptic Curve Cryptography Curve Parameter Definition class
 *
 * Copyright (c) 2013-2021 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name ecparam-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.5.0 ecparam 1.0.1 (2021-Nov-21)
 * @since jsrsasign 4.0
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};

/**
 * static object for elliptic curve names and parameters
 * @name KJUR.crypto.ECParameterDB
 * @class static object for elliptic curve names and parameters
 * @description
 * This class provides parameters for named elliptic curves.
 * Currently it supoprts following curve names and aliases however 
 * the name marked (*) are available for {@link KJUR.crypto.ECDSA} and
 * {@link KJUR.crypto.Signature} classes.
 * <ul>
 * <li>secp128r1</li>
 * <li>secp160r1</li>
 * <li>secp160k1</li>
 * <li>secp192r1</li>
 * <li>secp192k1</li>
 * <li>secp224r1</li>
 * <li>secp256r1, NIST P-256, P-256, prime256v1 (*)</li>
 * <li>secp256k1 (*)</li>
 * <li>secp384r1, NIST P-384, P-384 (*)</li>
 * <li>secp521r1, NIST P-521, P-521</li>
 * </ul>
 * You can register new curves by using 'register' method.
 */
KJUR.crypto.ECParameterDB = new function() {
    var db = {};
    var aliasDB = {};

    function hex2bi(hex) {
        return new BigInteger(hex, 16);
    }
    
    /**
     * get curve inforamtion associative array for curve name or alias
     * @name getByName
     * @memberOf KJUR.crypto.ECParameterDB
     * @function
     * @param {String} nameOrAlias curve name or alias name
     * @return {Array} associative array of curve parameters
     * @example
     * var param = KJUR.crypto.ECParameterDB.getByName('prime256v1');
     * var keylen = param['keylen'];
     * var n = param['n'];
     */
    this.getByName = function(nameOrAlias) {
	var name = nameOrAlias;
	if (typeof aliasDB[name] != "undefined") {
	    name = aliasDB[nameOrAlias];
        }
	if (typeof db[name] != "undefined") {
	    return db[name];
	}
	throw "unregistered EC curve name: " + name;
    };

    /**
     * register new curve
     * @name regist
     * @memberOf KJUR.crypto.ECParameterDB
     * @function
     * @param {String} name name of curve
     * @param {Integer} keylen key length
     * @param {String} pHex hexadecimal value of p
     * @param {String} aHex hexadecimal value of a
     * @param {String} bHex hexadecimal value of b
     * @param {String} nHex hexadecimal value of n
     * @param {String} hHex hexadecimal value of h
     * @param {String} gxHex hexadecimal value of Gx
     * @param {String} gyHex hexadecimal value of Gy
     * @param {Array} aliasList array of string for curve names aliases
     * @param {String} oid Object Identifier for the curve
     * @param {String} info information string for the curve
     */
    this.regist = function(name, keylen, pHex, aHex, bHex, nHex, hHex, gxHex, gyHex, aliasList, oid, info) {
        db[name] = {};
	var p = hex2bi(pHex);
	var a = hex2bi(aHex);
	var b = hex2bi(bHex);
	var n = hex2bi(nHex);
	var h = hex2bi(hHex);
        var curve = new ECCurveFp(p, a, b);
        var G = curve.decodePointHex("04" + gxHex + gyHex);
	db[name]['name'] = name;
	db[name]['keylen'] = keylen;
  db[name]['keycharlen'] = Math.ceil(keylen / 8) * 2; // for P-521
        db[name]['curve'] = curve;
        db[name]['G'] = G;
        db[name]['n'] = n;
        db[name]['h'] = h;
        db[name]['oid'] = oid;
        db[name]['info'] = info;

        for (var i = 0; i < aliasList.length; i++) {
	    aliasDB[aliasList[i]] = name;
        }
    };
};

KJUR.crypto.ECParameterDB.regist(
  "secp128r1", // name / p = 2^128 - 2^97 - 1
  128,
  "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF", // p
  "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC", // a
  "E87579C11079F43DD824993C2CEE5ED3", // b
  "FFFFFFFE0000000075A30D1B9038A115", // n
  "1", // h
  "161FF7528B899B2D0C28607CA52C5B86", // gx
  "CF5AC8395BAFEB13C02DA292DDED7A83", // gy
  [], // alias
  "", // oid (underconstruction)
  "secp128r1 : SECG curve over a 128 bit prime field"); // info

KJUR.crypto.ECParameterDB.regist(
  "secp160k1", // name / p = 2^160 - 2^32 - 2^14 - 2^12 - 2^9 - 2^8 - 2^7 - 2^3 - 2^2 - 1
  160,
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73", // p
  "0", // a
  "7", // b
  "0100000000000000000001B8FA16DFAB9ACA16B6B3", // n
  "1", // h
  "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB", // gx
  "938CF935318FDCED6BC28286531733C3F03C4FEE", // gy
  [], // alias
  "", // oid
  "secp160k1 : SECG curve over a 160 bit prime field"); // info

KJUR.crypto.ECParameterDB.regist(
  "secp160r1", // name / p = 2^160 - 2^31 - 1
  160,
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF", // p
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC", // a
  "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45", // b
  "0100000000000000000001F4C8F927AED3CA752257", // n
  "1", // h
  "4A96B5688EF573284664698968C38BB913CBFC82", // gx
  "23A628553168947D59DCC912042351377AC5FB32", // gy
  [], // alias
  "", // oid
  "secp160r1 : SECG curve over a 160 bit prime field"); // info

KJUR.crypto.ECParameterDB.regist(
  "secp192k1", // name / p = 2^192 - 2^32 - 2^12 - 2^8 - 2^7 - 2^6 - 2^3 - 1
  192,
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37", // p
  "0", // a
  "3", // b
  "FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D", // n
  "1", // h
  "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D", // gx
  "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D", // gy
  []); // alias

KJUR.crypto.ECParameterDB.regist(
  "secp192r1", // name / p = 2^192 - 2^64 - 1
  192,
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF", // p
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC", // a
  "64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1", // b
  "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831", // n
  "1", // h
  "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012", // gx
  "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811", // gy
  []); // alias

KJUR.crypto.ECParameterDB.regist(
  "secp224r1", // name / p = 2^224 - 2^96 + 1
  224,
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001", // p
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE", // a
  "B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4", // b
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D", // n
  "1", // h
  "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21", // gx
  "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34", // gy
  []); // alias

KJUR.crypto.ECParameterDB.regist(
  "secp256k1", // name / p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
  256,
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", // p
  "0", // a
  "7", // b
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", // n
  "1", // h
  "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", // gx
  "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", // gy
  []); // alias

KJUR.crypto.ECParameterDB.regist(
  "secp256r1", // name / p = 2^224 (2^32 - 1) + 2^192 + 2^96 - 1
  256,
  "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF", // p
  "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC", // a
  "5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B", // b
  "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551", // n
  "1", // h
  "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296", // gx
  "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5", // gy
  ["NIST P-256", "P-256", "prime256v1"]); // alias

KJUR.crypto.ECParameterDB.regist(
  "secp384r1", // name
  384,
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF", // p
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC", // a
  "B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF", // b
  "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973", // n
  "1", // h
  "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7", // gx
  "3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f", // gy
  ["NIST P-384", "P-384"]); // alias

KJUR.crypto.ECParameterDB.regist(
  "secp521r1", // name
  521,
  "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", // p
  "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC", // a
  "051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00", // b
  "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409", // n
  "1", // h
  "00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66", // gx
  "011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650", // gy
  ["NIST P-521", "P-521"]); // alias


/* dsa-2.1.2.js (c) 2016-2020 Kenji Urushimma | kjur.github.io/jsrsasign/license
 */
/*
 * dsa.js - new DSA class
 *
 * Copyright (c) 2016-2020 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name dsa-2.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 8.0.21 dsa 2.1.2 (2020-Jul-24)
 * @since jsrsasign 7.0.0
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};

/**
 * class for DSA signing and verification
 * @name KJUR.crypto.DSA
 * @class class for DSA signing and verifcation
 * @since jsrsasign 7.0.0 dsa 2.0.0
 * @description
 * <p>
 * CAUTION: Most of the case, you don't need to use this class.
 * Please use {@link KJUR.crypto.Signature} class instead.
 * </p>
 * <p>
 * NOTE: Until jsrsasign 6.2.3, DSA class have used codes from openpgpjs library 1.0.0
 * licenced under LGPL licence. To avoid license issue dsa-2.0.js was re-written with
 * my own codes in jsrsasign 7.0.0. 
 * Some random number generators used in dsa-2.0.js was newly defined
 * in KJUR.crypto.Util class. Now all of LGPL codes are removed.
 * </p>
 */
KJUR.crypto.DSA = function() {
    var _ASN1HEX = ASN1HEX,
        _getVbyList = _ASN1HEX.getVbyList,
        _getVbyListEx = _ASN1HEX.getVbyListEx,
	_isASN1HEX = _ASN1HEX.isASN1HEX,
	_BigInteger = BigInteger;
    this.p = null;
    this.q = null;
    this.g = null;
    this.y = null;
    this.x = null;
    this.type = "DSA";
    this.isPrivate = false;
    this.isPublic = false;

    //===========================
    // PUBLIC METHODS
    //===========================

    /**
     * set DSA private key by key parameters of BigInteger object
     * @name setPrivate
     * @memberOf KJUR.crypto.DSA#
     * @function
     * @param {BigInteger} p prime P parameter
     * @param {BigInteger} q sub prime Q parameter
     * @param {BigInteger} g base G parameter
     * @param {BigInteger} y public key Y or null
     * @param {BigInteger} x private key X
     * @since jsrsasign 7.0.0 dsa 2.0.0
     */
    this.setPrivate = function(p, q, g, y, x) {
	this.isPrivate = true;
	this.p = p;
	this.q = q;
	this.g = g;
	this.y = y;
	this.x = x;
    };

    /**
     * set DSA private key by key parameters of hexadecimal string
     * @name setPrivateHex
     * @memberOf KJUR.crypto.DSA#
     * @function
     * @param {String} hP prime P parameter
     * @param {String} hQ sub prime Q parameter
     * @param {String} hG base G parameter
     * @param {String} hY public key Y or null
     * @param {String} hX private key X
     * @since jsrsasign 7.1.0 dsa 2.1.0
     */
    this.setPrivateHex = function(hP, hQ, hG, hY, hX) {
	var biP, biQ, biG, biY, biX;
        biP = new BigInteger(hP, 16);
        biQ = new BigInteger(hQ, 16);
        biG = new BigInteger(hG, 16);
	if (typeof hY === "string" && hY.length > 1) {
            biY = new BigInteger(hY, 16);
	} else {
	    biY = null;
	}
        biX = new BigInteger(hX, 16);
        this.setPrivate(biP, biQ, biG, biY, biX);
    };

    /**
     * set DSA public key by key parameters of BigInteger object
     * @name setPublic
     * @memberOf KJUR.crypto.DSA#
     * @function
     * @param {BigInteger} p prime P parameter
     * @param {BigInteger} q sub prime Q parameter
     * @param {BigInteger} g base G parameter
     * @param {BigInteger} y public key Y
     * @since jsrsasign 7.0.0 dsa 2.0.0
     */
    this.setPublic = function(p, q, g, y) {
	this.isPublic = true;
	this.p = p;
	this.q = q;
	this.g = g;
	this.y = y;
	this.x = null;
    };

    /**
     * set DSA public key by key parameters of hexadecimal string
     * @name setPublicHex
     * @memberOf KJUR.crypto.DSA#
     * @function
     * @param {String} hP prime P parameter
     * @param {String} hQ sub prime Q parameter
     * @param {String} hG base G parameter
     * @param {String} hY public key Y
     * @since jsrsasign 7.1.0 dsa 2.1.0
     */
    this.setPublicHex = function(hP, hQ, hG, hY) {
	var biP, biQ, biG, biY;
        biP = new BigInteger(hP, 16);
        biQ = new BigInteger(hQ, 16);
        biG = new BigInteger(hG, 16);
        biY = new BigInteger(hY, 16);
        this.setPublic(biP, biQ, biG, biY);
    };

    /**
     * sign to hashed message by this DSA private key object
     * @name signWithMessageHash
     * @memberOf KJUR.crypto.DSA#
     * @function
     * @param {String} sHashHex hexadecimal string of hashed message
     * @return {String} hexadecimal string of ASN.1 encoded DSA signature value
     * @since jsrsasign 7.0.0 dsa 2.0.0
     */
    this.signWithMessageHash = function(sHashHex) {
	var p = this.p; // parameter p
	var q = this.q; // parameter q
	var g = this.g; // parameter g
	var y = this.y; // public key (p q g y)
	var x = this.x; // private key

	// NIST FIPS 186-4 4.5 DSA Per-Message Secret Number (p18)
	// 1. get random k where 0 < k < q
	var k = KJUR.crypto.Util.getRandomBigIntegerMinToMax(BigInteger.ONE.add(BigInteger.ONE),
							     q.subtract(BigInteger.ONE));

	// NIST FIPS 186-4 4.6 DSA Signature Generation (p19)
	// 2. get z where the left most min(N, outlen) bits of Hash(M)
	var hZ = sHashHex.substr(0, q.bitLength() / 4);
	var z = new BigInteger(hZ, 16);

	// 3. get r where (g^k mod p) mod q, r != 0
	var r = (g.modPow(k,p)).mod(q); 

	// 4. get s where k^-1 (z + xr) mod q, s != 0
	var s = (k.modInverse(q).multiply(z.add(x.multiply(r)))).mod(q);

	// 5. signature (r, s)
	var result = KJUR.asn1.ASN1Util.jsonToASN1HEX({
	    "seq": [{"int": {"bigint": r}}, {"int": {"bigint": s}}] 
	});
	return result;
    };

    /**
     * verify signature by this DSA public key object
     * @name verifyWithMessageHash
     * @memberOf KJUR.crypto.DSA#
     * @function
     * @param {String} sHashHex hexadecimal string of hashed message
     * @param {String} hSigVal hexadecimal string of ASN.1 encoded DSA signature value
     * @return {Boolean} true if the signature is valid otherwise false.
     * @since jsrsasign 7.0.0 dsa 2.0.0
     */
    this.verifyWithMessageHash = function(sHashHex, hSigVal) {
	var p = this.p; // parameter p
	var q = this.q; // parameter q
	var g = this.g; // parameter g
	var y = this.y; // public key (p q g y)

	// 1. parse ASN.1 signature (r, s)
	var rs = this.parseASN1Signature(hSigVal);
        var r = rs[0];
        var s = rs[1];

	// NIST FIPS 186-4 4.6 DSA Signature Generation (p19)
	// 2. get z where the left most min(N, outlen) bits of Hash(M)
	var hZ = sHashHex.substr(0, q.bitLength() / 4);
	var z = new BigInteger(hZ, 16);

	// NIST FIPS 186-4 4.7 DSA Signature Validation (p19)
	// 3.1. 0 < r < q
	if (BigInteger.ZERO.compareTo(r) > 0 || r.compareTo(q) > 0)
	    throw "invalid DSA signature";

	// 3.2. 0 < s < q
	if (BigInteger.ZERO.compareTo(s) >= 0 || s.compareTo(q) > 0)
	    throw "invalid DSA signature";

	// 4. get w where w = s^-1 mod q
	var w = s.modInverse(q);

	// 5. get u1 where u1 = z w mod q
	var u1 = z.multiply(w).mod(q);

	// 6. get u2 where u2 = r w mod q
	var u2 = r.multiply(w).mod(q);

	// 7. get v where v = ((g^u1 y^u2) mod p) mod q
	var v = g.modPow(u1,p).multiply(y.modPow(u2,p)).mod(p).mod(q);

	// 8. signature is valid when v == r
	return v.compareTo(r) == 0;
    };

    /**
     * parse hexadecimal ASN.1 DSA signature value
     * @name parseASN1Signature
     * @memberOf KJUR.crypto.DSA#
     * @function
     * @param {String} hSigVal hexadecimal string of ASN.1 encoded DSA signature value
     * @return {Array} array [r, s] of DSA signature value. Both r and s are BigInteger.
     * @since jsrsasign 7.0.0 dsa 2.0.0
     */
    this.parseASN1Signature = function(hSigVal) {
	try {
	    var r = new _BigInteger(_getVbyListEx(hSigVal, 0, [0], "02"), 16);
	    var s = new _BigInteger(_getVbyListEx(hSigVal, 0, [1], "02"), 16);
	    return [r, s];
	} catch (ex) {
	    throw new Error("malformed ASN.1 DSA signature");
	}
    }

    /**
     * read an ASN.1 hexadecimal string of PKCS#1/5 plain DSA private key<br/>
     * @name readPKCS5PrvKeyHex
     * @memberOf KJUR.crypto.DSA#
     * @function
     * @param {String} h hexadecimal string of PKCS#1/5 DSA private key
     * @since jsrsasign 7.1.0 dsa 2.1.0
     */
    this.readPKCS5PrvKeyHex = function(h) {
	var hP, hQ, hG, hY, hX;

	if (_isASN1HEX(h) === false)
	    throw new Error("not ASN.1 hex string");

	try {
	    hP = _getVbyListEx(h, 0, [1], "02");
	    hQ = _getVbyListEx(h, 0, [2], "02");
	    hG = _getVbyListEx(h, 0, [3], "02");
	    hY = _getVbyListEx(h, 0, [4], "02");
	    hX = _getVbyListEx(h, 0, [5], "02");
	} catch(ex) {
	    //console.log("EXCEPTION:" + ex);
	    throw new Error("malformed PKCS#1/5 plain DSA private key");
	}

	this.setPrivateHex(hP, hQ, hG, hY, hX);
    };

    /**
     * read an ASN.1 hexadecimal string of PKCS#8 plain DSA private key<br/>
     * @name readPKCS8PrvKeyHex
     * @memberOf KJUR.crypto.DSA#
     * @function
     * @param {String} h hexadecimal string of PKCS#8 DSA private key
     * @since jsrsasign 7.1.0 dsa 2.1.0
     */
    this.readPKCS8PrvKeyHex = function(h) {
	var hP, hQ, hG, hX;

	if (_isASN1HEX(h) === false)
	    throw new Error("not ASN.1 hex string");

	try {
	    hP = _getVbyListEx(h, 0, [1, 1, 0], "02");
	    hQ = _getVbyListEx(h, 0, [1, 1, 1], "02");
	    hG = _getVbyListEx(h, 0, [1, 1, 2], "02");
	    hX = _getVbyListEx(h, 0, [2, 0], "02");
	} catch(ex) {
	    //console.log("EXCEPTION:" + ex);
	    throw new Error("malformed PKCS#8 plain DSA private key");
	}

	this.setPrivateHex(hP, hQ, hG, null, hX);
    };

    /**
     * read an ASN.1 hexadecimal string of PKCS#8 plain DSA private key<br/>
     * @name readPKCS8PubKeyHex
     * @memberOf KJUR.crypto.DSA#
     * @function
     * @param {String} h hexadecimal string of PKCS#8 DSA private key
     * @since jsrsasign 7.1.0 dsa 2.1.0
     */
    this.readPKCS8PubKeyHex = function(h) {
	var hP, hQ, hG, hY;

	if (_isASN1HEX(h) === false)
	    throw new Error("not ASN.1 hex string");

	try {
	    hP = _getVbyListEx(h, 0, [0, 1, 0], "02");
	    hQ = _getVbyListEx(h, 0, [0, 1, 1], "02");
	    hG = _getVbyListEx(h, 0, [0, 1, 2], "02");
	    hY = _getVbyListEx(h, 0, [1, 0], "02");
	} catch(ex) {
	    //console.log("EXCEPTION:" + ex);
	    throw new Error("malformed PKCS#8 DSA public key");
	}

	this.setPublicHex(hP, hQ, hG, hY);
    };

    /**
     * read an ASN.1 hexadecimal string of X.509 DSA public key certificate<br/>
     * @name readCertPubKeyHex
     * @memberOf KJUR.crypto.DSA#
     * @function
     * @param {String} h hexadecimal string of X.509 DSA public key certificate
     * @param {Integer} nthPKI (DEPRECATED to use)
     * @since jsrsasign 7.1.0 dsa 2.1.0
     * @description
     * This method reads a hexadecimal string of X.509 DSA public key certificate
     * and set public key parameter internally.
     * @example
     * dsa = new KJUR.crypto.DSA();
     * dsa.readCertPubKeyHex("30...");
     */
    this.readCertPubKeyHex = function(h, nthPKI) {
	//if (nthPKI !== 5) nthPKI = 6;
	var hP, hQ, hG, hY;

	if (_isASN1HEX(h) === false)
	    throw new Error("not ASN.1 hex string");

	try {
	    hP = _getVbyListEx(h, 0, [0, 5, 0, 1, 0], "02");
	    hQ = _getVbyListEx(h, 0, [0, 5, 0, 1, 1], "02");
	    hG = _getVbyListEx(h, 0, [0, 5, 0, 1, 2], "02");
	    hY = _getVbyListEx(h, 0, [0, 5, 1, 0], "02");
	} catch(ex) {
	    //console.log("EXCEPTION:" + ex);
	    throw new Error("malformed X.509 certificate DSA public key");
	}

	this.setPublicHex(hP, hQ, hG, hY);
    };
}

/* keyutil-1.2.7.js (c) 2013-2022 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * keyutil.js - key utility for PKCS#1/5/8 PEM, RSA/DSA/ECDSA key object
 *
 * Copyright (c) 2013-2022 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */
/**
 * @fileOverview
 * @name keyutil-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.5.16 keyutil 1.2.7 (2022-Apr-08)
 * @since jsrsasign 4.1.4
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * @name KEYUTIL
 * @class class for RSA/ECC/DSA key utility
 * @description 
 * <br/>
 * {@link KEYUTIL} class is an update of former {@link PKCS5PKEY} class.
 * {@link KEYUTIL} class has following features:
 * <dl>
 * <dt><b>key loading - {@link KEYUTIL.getKey}</b>
 * <dd>
 * <ul>
 * <li>supports RSAKey and KJUR.crypto.{ECDSA,DSA} key object</li>
 * <li>supports private key and public key</li>
 * <li>supports encrypted and plain private key</li>
 * <li>supports PKCS#1, PKCS#5 and PKCS#8 key</li>
 * <li>supports public key in X.509 certificate</li>
 * <li>key represented by JSON object</li>
 * </ul>
 * NOTE1: Encrypted PKCS#8 only supports PBKDF2/HmacSHA1/3DES <br/>
 * NOTE2: Encrypted PKCS#5 supports DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC <br/>
 *
 * <dt><b>exporting key - {@link KEYUTIL.getPEM}</b>
 * <dd>
 * {@link KEYUTIL.getPEM} method supports following formats:
 * <ul>
 * <li>supports RSA/EC/DSA keys</li>
 * <li>PKCS#1 plain RSA/EC/DSA private key</li>
 * <li>PKCS#5 encrypted RSA/EC/DSA private key with DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC</li>
 * <li>PKCS#8 plain RSA/EC/DSA private key</li>
 * <li>PKCS#8 encrypted RSA/EC/DSA private key with PBKDF2_HmacSHA1_3DES</li>
 * </ul>
 *
 * <dt><b>keypair generation - {@link KEYUTIL.generateKeypair}</b>
 * <ul>
 * <li>generate key pair of {@link RSAKey} or {@link KJUR.crypto.ECDSA}.</li>
 * <li>generate private key and convert it to PKCS#5 encrypted private key.</li>
 * </ul>
 * NOTE: {@link KJUR.crypto.DSA} is not yet supported.
 * </dl>
 * 
 * @example
 * // 1. loading PEM private key
 * var key = KEYUTIL.getKey(pemPKCS1PrivateKey);
 * var key = KEYUTIL.getKey(pemPKCS5EncryptedPrivateKey, "passcode");
 * var key = KEYUTIL.getKey(pemPKCS5PlainRsaDssEcPrivateKey);
 * var key = KEYUTIL.getKey(pemPKC85PlainPrivateKey);
 * var key = KEYUTIL.getKey(pemPKC85EncryptedPrivateKey, "passcode");
 * // 2. loading PEM public key
 * var key = KEYUTIL.getKey(pemPKCS8PublicKey);
 * var key = KEYUTIL.getKey(pemX509Certificate);
 * // 3. exporting private key
 * var pem = KEYUTIL.getPEM(privateKeyObj, "PKCS1PRV");
 * var pem = KEYUTIL.getPEM(privateKeyObj, "PKCS5PRV", "passcode"); // DES-EDE3-CBC by default
 * var pem = KEYUTIL.getPEM(privateKeyObj, "PKCS5PRV", "passcode", "DES-CBC");
 * var pem = KEYUTIL.getPEM(privateKeyObj, "PKCS8PRV");
 * var pem = KEYUTIL.getPEM(privateKeyObj, "PKCS8PRV", "passcode");
 * // 4. exporting public key
 * var pem = KEYUTIL.getPEM(publicKeyObj);
 */
var KEYUTIL = function() {
    // *****************************************************************
    // *** PRIVATE PROPERTIES AND METHODS *******************************
    // *****************************************************************
    // shared key decryption ------------------------------------------
    var decryptAES = function(dataHex, keyHex, ivHex) {
        return decryptGeneral(CryptoJS.AES, dataHex, keyHex, ivHex);
    };

    var decrypt3DES = function(dataHex, keyHex, ivHex) {
        return decryptGeneral(CryptoJS.TripleDES, dataHex, keyHex, ivHex);
    };

    var decryptDES = function(dataHex, keyHex, ivHex) {
        return decryptGeneral(CryptoJS.DES, dataHex, keyHex, ivHex);
    };

    var decryptGeneral = function(f, dataHex, keyHex, ivHex) {
        var data = CryptoJS.enc.Hex.parse(dataHex);
        var key = CryptoJS.enc.Hex.parse(keyHex);
        var iv = CryptoJS.enc.Hex.parse(ivHex);
        var encrypted = {};
        encrypted.key = key;
        encrypted.iv = iv;
        encrypted.ciphertext = data;
        var decrypted = f.decrypt(encrypted, key, { iv: iv });
        return CryptoJS.enc.Hex.stringify(decrypted);
    };

    // shared key decryption ------------------------------------------
    var encryptAES = function(dataHex, keyHex, ivHex) {
        return encryptGeneral(CryptoJS.AES, dataHex, keyHex, ivHex);
    };

    var encrypt3DES = function(dataHex, keyHex, ivHex) {
        return encryptGeneral(CryptoJS.TripleDES, dataHex, keyHex, ivHex);
    };

    var encryptDES = function(dataHex, keyHex, ivHex) {
        return encryptGeneral(CryptoJS.DES, dataHex, keyHex, ivHex);
    };

    var encryptGeneral = function(f, dataHex, keyHex, ivHex) {
        var data = CryptoJS.enc.Hex.parse(dataHex);
        var key = CryptoJS.enc.Hex.parse(keyHex);
        var iv = CryptoJS.enc.Hex.parse(ivHex);
        var encryptedHex = f.encrypt(data, key, { iv: iv });
        var encryptedWA = CryptoJS.enc.Hex.parse(encryptedHex.toString());
        var encryptedB64 = CryptoJS.enc.Base64.stringify(encryptedWA);
        return encryptedB64;
    };

    // other methods and properties ----------------------------------------
    var ALGLIST = {
        'AES-256-CBC':  { 'proc': decryptAES,  'eproc': encryptAES,  keylen: 32, ivlen: 16 },
        'AES-192-CBC':  { 'proc': decryptAES,  'eproc': encryptAES,  keylen: 24, ivlen: 16 },
        'AES-128-CBC':  { 'proc': decryptAES,  'eproc': encryptAES,  keylen: 16, ivlen: 16 },
        'DES-EDE3-CBC': { 'proc': decrypt3DES, 'eproc': encrypt3DES, keylen: 24, ivlen: 8 },
        'DES-CBC':      { 'proc': decryptDES,  'eproc': encryptDES,  keylen: 8,  ivlen: 8 }
    };

    var getFuncByName = function(algName) {
        return ALGLIST[algName]['proc'];
    };

    var _generateIvSaltHex = function(numBytes) {
        var wa = CryptoJS.lib.WordArray.random(numBytes);
        var hex = CryptoJS.enc.Hex.stringify(wa);
        return hex;
    };

    var _parsePKCS5PEM = function(sPKCS5PEM) {
        var info = {};
        var matchResult1 = sPKCS5PEM.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)", "m"));
        if (matchResult1) {
            info.cipher = matchResult1[1];
            info.ivsalt = matchResult1[2];
        }
        var matchResult2 = sPKCS5PEM.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));
        if (matchResult2) {
            info.type = matchResult2[1];
        }
        var i1 = -1;
        var lenNEWLINE = 0;
        if (sPKCS5PEM.indexOf("\r\n\r\n") != -1) {
            i1 = sPKCS5PEM.indexOf("\r\n\r\n");
            lenNEWLINE = 2;
        }
        if (sPKCS5PEM.indexOf("\n\n") != -1) {
            i1 = sPKCS5PEM.indexOf("\n\n");
            lenNEWLINE = 1;
        }
        var i2 = sPKCS5PEM.indexOf("-----END");
        if (i1 != -1 && i2 != -1) {
            var s = sPKCS5PEM.substring(i1 + lenNEWLINE * 2, i2 - lenNEWLINE);
            s = s.replace(/\s+/g, '');
            info.data = s;
        }
        return info;
    };

    var _getKeyAndUnusedIvByPasscodeAndIvsalt = function(algName, passcode, ivsaltHex) {
        //alert("ivsaltHex(2) = " + ivsaltHex);
        var saltHex = ivsaltHex.substring(0, 16);
        //alert("salt = " + saltHex);
        
        var salt = CryptoJS.enc.Hex.parse(saltHex);
        var data = CryptoJS.enc.Utf8.parse(passcode);
        //alert("salt = " + salt);
        //alert("data = " + data);

        var nRequiredBytes = ALGLIST[algName]['keylen'] + ALGLIST[algName]['ivlen'];
        var hHexValueJoined = '';
        var hLastValue = null;
        //alert("nRequiredBytes = " + nRequiredBytes);
        for (;;) {
            var h = CryptoJS.algo.MD5.create();
            if (hLastValue != null) {
                h.update(hLastValue);
            }
            h.update(data);
            h.update(salt);
            hLastValue = h.finalize();
            hHexValueJoined = hHexValueJoined + CryptoJS.enc.Hex.stringify(hLastValue);
            //alert("joined = " + hHexValueJoined);
            if (hHexValueJoined.length >= nRequiredBytes * 2) {
                break;
            }
        }
        var result = {};
        result.keyhex = hHexValueJoined.substr(0, ALGLIST[algName]['keylen'] * 2);
        result.ivhex = hHexValueJoined.substr(ALGLIST[algName]['keylen'] * 2, ALGLIST[algName]['ivlen'] * 2);
        return result;
    };

    /*
     * @param {String} privateKeyB64 base64 string of encrypted private key
     * @param {String} sharedKeyAlgName algorithm name of shared key encryption
     * @param {String} sharedKeyHex hexadecimal string of shared key to encrypt
     * @param {String} ivsaltHex hexadecimal string of IV and salt
     * @param {String} hexadecimal string of decrypted private key
     */
    var _decryptKeyB64 = function(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex) {
        var privateKeyWA = CryptoJS.enc.Base64.parse(privateKeyB64);
        var privateKeyHex = CryptoJS.enc.Hex.stringify(privateKeyWA);
        var f = ALGLIST[sharedKeyAlgName]['proc'];
        var decryptedKeyHex = f(privateKeyHex, sharedKeyHex, ivsaltHex);
        return decryptedKeyHex;
    };
    
    /*
     * @param {String} privateKeyHex hexadecimal string of private key
     * @param {String} sharedKeyAlgName algorithm name of shared key encryption
     * @param {String} sharedKeyHex hexadecimal string of shared key to encrypt
     * @param {String} ivsaltHex hexadecimal string of IV and salt
     * @param {String} base64 string of encrypted private key
     */
    var _encryptKeyHex = function(privateKeyHex, sharedKeyAlgName, sharedKeyHex, ivsaltHex) {
        var f = ALGLIST[sharedKeyAlgName]['eproc'];
        var encryptedKeyB64 = f(privateKeyHex, sharedKeyHex, ivsaltHex);
        return encryptedKeyB64;
    };

    // *****************************************************************
    // *** PUBLIC PROPERTIES AND METHODS *******************************
    // *****************************************************************
    return {
        // -- UTILITY METHODS ------------------------------------------------------------
        /**
         * decrypt private key by shared key
         * @name version
         * @memberOf KEYUTIL
         * @property {String} version
         * @description version string of KEYUTIL class
         */
        version: "1.0.0",

        /**
         * parse PEM formatted passcode protected PKCS#5 private key
         * @name parsePKCS5PEM
         * @memberOf KEYUTIL
         * @function
         * @param {String} sEncryptedPEM PEM formatted protected passcode protected PKCS#5 private key
         * @return {Hash} hash of key information
         * @description
         * Resulted hash has following attributes.
         * <ul>
         * <li>cipher - symmetric key algorithm name (ex. 'DES-EBE3-CBC', 'AES-256-CBC')</li>
         * <li>ivsalt - IV used for decrypt. Its heading 8 bytes will be used for passcode salt.</li>
         * <li>type - asymmetric key algorithm name of private key described in PEM header.</li>
         * <li>data - base64 encoded encrypted private key.</li>
         * </ul>
         *
         */
        parsePKCS5PEM: function(sPKCS5PEM) {
            return _parsePKCS5PEM(sPKCS5PEM);
        },

        /**
         * the same function as OpenSSL EVP_BytsToKey to generate shared key and IV
         * @name getKeyAndUnusedIvByPasscodeAndIvsalt
         * @memberOf KEYUTIL
         * @function
         * @param {String} algName name of symmetric key algorithm (ex. 'DES-EBE3-CBC')
         * @param {String} passcode passcode to decrypt private key (ex. 'password')
         * @param {String} hexadecimal string of IV. heading 8 bytes will be used for passcode salt
         * @return {Hash} hash of key and unused IV (ex. {keyhex:2fe3..., ivhex:3fad..})
         */
        getKeyAndUnusedIvByPasscodeAndIvsalt: function(algName, passcode, ivsaltHex) {
            return _getKeyAndUnusedIvByPasscodeAndIvsalt(algName, passcode, ivsaltHex);
        },

        decryptKeyB64: function(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex) {
            return _decryptKeyB64(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex);
        },

        /**
         * decrypt PEM formatted protected PKCS#5 private key with passcode
         * @name getDecryptedKeyHex
         * @memberOf KEYUTIL
         * @function
         * @param {String} sEncryptedPEM PEM formatted protected passcode protected PKCS#5 private key
         * @param {String} passcode passcode to decrypt private key (ex. 'password')
         * @return {String} hexadecimal string of decrypted RSA priavte key
         */
        getDecryptedKeyHex: function(sEncryptedPEM, passcode) {
            // 1. parse pem
            var info = _parsePKCS5PEM(sEncryptedPEM);
            var publicKeyAlgName = info.type;
            var sharedKeyAlgName = info.cipher;
            var ivsaltHex = info.ivsalt;
            var privateKeyB64 = info.data;
            //alert("ivsaltHex = " + ivsaltHex);

            // 2. generate shared key
            var sharedKeyInfo = _getKeyAndUnusedIvByPasscodeAndIvsalt(sharedKeyAlgName, passcode, ivsaltHex);
            var sharedKeyHex = sharedKeyInfo.keyhex;
            //alert("sharedKeyHex = " + sharedKeyHex);

            // 3. decrypt private key
            var decryptedKey = _decryptKeyB64(privateKeyB64, sharedKeyAlgName, sharedKeyHex, ivsaltHex);
            return decryptedKey;
        },

        /*
         * get PEM formatted encrypted PKCS#5 private key from hexadecimal string of plain private key
         * @name getEncryptedPKCS5PEMFromPrvKeyHex
         * @memberOf KEYUTIL
         * @function
         * @param {String} pemHeadAlg algorithm name in the pem header (i.e. RSA,EC or DSA)
         * @param {String} hPrvKey hexadecimal string of plain private key
         * @param {String} passcode pass code to protect private key (ex. password)
         * @param {String} sharedKeyAlgName algorithm name to protect private key (ex. AES-256-CBC)
         * @param {String} ivsaltHex hexadecimal string of IV and salt
         * @return {String} string of PEM formatted encrypted PKCS#5 private key
         * @since pkcs5pkey 1.0.2
         * @description
         * <br/>
         * generate PEM formatted encrypted PKCS#5 private key by hexadecimal string encoded
         * ASN.1 object of plain RSA private key.
         * Following arguments can be omitted.
         * <ul>
         * <li>alg - AES-256-CBC will be used if omitted.</li>
         * <li>ivsaltHex - automatically generate IV and salt which length depends on algorithm</li>
         * </ul>
         * NOTE1: DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC algorithm are supported.
         * @example
         * var pem = 
         *   KEYUTIL.getEncryptedPKCS5PEMFromPrvKeyHex(plainKeyHex, "password");
         * var pem2 = 
         *   KEYUTIL.getEncryptedPKCS5PEMFromPrvKeyHex(plainKeyHex, "password", "AES-128-CBC");
         * var pem3 = 
         *   KEYUTIL.getEncryptedPKCS5PEMFromPrvKeyHex(plainKeyHex, "password", "AES-128-CBC", "1f3d02...");
         */
        getEncryptedPKCS5PEMFromPrvKeyHex: function(pemHeadAlg, hPrvKey, passcode, sharedKeyAlgName, ivsaltHex) {
            var sPEM = "";

            // 1. set sharedKeyAlgName if undefined (default AES-256-CBC)
            if (typeof sharedKeyAlgName == "undefined" ||
		sharedKeyAlgName == null) {
                sharedKeyAlgName = "AES-256-CBC";
            }
            if (typeof ALGLIST[sharedKeyAlgName] == "undefined")
                throw new Error("KEYUTIL unsupported algorithm: " + 
				sharedKeyAlgName);

            // 2. set ivsaltHex if undefined
            if (typeof ivsaltHex == "undefined" || ivsaltHex == null) {
                var ivlen = ALGLIST[sharedKeyAlgName]['ivlen'];
                var randIV = _generateIvSaltHex(ivlen);
                ivsaltHex = randIV.toUpperCase();
            }

            // 3. get shared key
            //alert("ivsalthex=" + ivsaltHex);
            var sharedKeyInfo = _getKeyAndUnusedIvByPasscodeAndIvsalt(sharedKeyAlgName, passcode, ivsaltHex);
            var sharedKeyHex = sharedKeyInfo.keyhex;
            // alert("sharedKeyHex = " + sharedKeyHex);

            // 3. get encrypted Key in Base64
            var encryptedKeyB64 = _encryptKeyHex(hPrvKey, sharedKeyAlgName, sharedKeyHex, ivsaltHex);

            var pemBody = encryptedKeyB64.replace(/(.{64})/g, "$1\r\n");
            var sPEM = "-----BEGIN " + pemHeadAlg + " PRIVATE KEY-----\r\n";
            sPEM += "Proc-Type: 4,ENCRYPTED\r\n";
            sPEM += "DEK-Info: " + sharedKeyAlgName + "," + ivsaltHex + "\r\n";
            sPEM += "\r\n";
            sPEM += pemBody;
            sPEM += "\r\n-----END " + pemHeadAlg + " PRIVATE KEY-----\r\n";

            return sPEM;
        },

        // === PKCS8 ===============================================================

        /**
         * generate PBKDF2 key hexstring with specified passcode and information
         * @name parseHexOfEncryptedPKCS8
         * @memberOf KEYUTIL
         * @function
         * @param {String} passcode passcode to decrypto private key
         * @return {Array} info associative array of PKCS#8 parameters
         * @since pkcs5pkey 1.0.3
         * @description
         * The associative array which is returned by this method has following properties:
         * <ul>
         * <li>info.pbkdf2Salt - hexadecimal string of PBKDF2 salt</li>
         * <li>info.pkbdf2Iter - iteration count</li>
         * <li>info.ciphertext - hexadecimal string of encrypted private key</li>
         * <li>info.encryptionSchemeAlg - encryption algorithm name (currently TripleDES only)</li>
         * <li>info.encryptionSchemeIV - initial vector for encryption algorithm</li>
         * </ul>
         * Currently, this method only supports PKCS#5v2.0 with PBES2/PBDKF2 of HmacSHA1 and TripleDES.
         * <ul>
         * <li>keyDerivationFunc = pkcs5PBKDF2 with HmacSHA1</li>
         * <li>encryptionScheme = des-EDE3-CBC(i.e. TripleDES</li>
         * </ul>
         * @example
         * // to convert plain PKCS#5 private key to encrypted PKCS#8 private
         * // key with PBKDF2 with TripleDES
         * % openssl pkcs8 -in plain_p5.pem -topk8 -v2 -des3 -out encrypted_p8.pem
         */
        parseHexOfEncryptedPKCS8: function(sHEX) {
	    var _ASN1HEX = ASN1HEX;
	    var _getChildIdx = _ASN1HEX.getChildIdx;
	    var _getV = _ASN1HEX.getV;
            var info = {};
            
            var a0 = _getChildIdx(sHEX, 0);
            if (a0.length != 2)
                throw new Error("malformed format: SEQUENCE(0).items != 2: " +
				a0.length);

            // 1. ciphertext
            info.ciphertext = _getV(sHEX, a0[1]);

            // 2. pkcs5PBES2
            var a0_0 = _getChildIdx(sHEX, a0[0]); 
            if (a0_0.length != 2)
                throw new Error("malformed format: SEQUENCE(0.0).items != 2: "
				+ a0_0.length);

            // 2.1 check if pkcs5PBES2(1 2 840 113549 1 5 13)
            if (_getV(sHEX, a0_0[0]) != "2a864886f70d01050d")
                throw new Error("this only supports pkcs5PBES2");

            // 2.2 pkcs5PBES2 param
            var a0_0_1 = _getChildIdx(sHEX, a0_0[1]); 
            if (a0_0.length != 2)
                throw new Error("malformed format: SEQUENCE(0.0.1).items != 2: "
				+ a0_0_1.length);

            // 2.2.1 encryptionScheme
            var a0_0_1_1 = _getChildIdx(sHEX, a0_0_1[1]); 
            if (a0_0_1_1.length != 2)
                throw new Error("malformed format: " + 
				"SEQUENCE(0.0.1.1).items != 2: " +
				a0_0_1_1.length);
            if (_getV(sHEX, a0_0_1_1[0]) != "2a864886f70d0307")
                throw "this only supports TripleDES";
            info.encryptionSchemeAlg = "TripleDES";

            // 2.2.1.1 IV of encryptionScheme
            info.encryptionSchemeIV = _getV(sHEX, a0_0_1_1[1]);

            // 2.2.2 keyDerivationFunc
            var a0_0_1_0 = _getChildIdx(sHEX, a0_0_1[0]); 
            if (a0_0_1_0.length != 2)
                throw new Error("malformed format: " +
				"SEQUENCE(0.0.1.0).items != 2: "
				+ a0_0_1_0.length);
            if (_getV(sHEX, a0_0_1_0[0]) != "2a864886f70d01050c")
                throw new Error("this only supports pkcs5PBKDF2");

            // 2.2.2.1 pkcs5PBKDF2 param
            var a0_0_1_0_1 = _getChildIdx(sHEX, a0_0_1_0[1]); 
            if (a0_0_1_0_1.length < 2)
                throw new Error("malformed format: " +
				"SEQUENCE(0.0.1.0.1).items < 2: " + 
				a0_0_1_0_1.length);

            // 2.2.2.1.1 PBKDF2 salt
            info.pbkdf2Salt = _getV(sHEX, a0_0_1_0_1[0]);

            // 2.2.2.1.2 PBKDF2 iter
            var iterNumHex = _getV(sHEX, a0_0_1_0_1[1]);
            try {
                info.pbkdf2Iter = parseInt(iterNumHex, 16);
            } catch(ex) {
                throw new Error("malformed format pbkdf2Iter: " + iterNumHex);
            }

            // 2.2.2.1.3 PBKDF2 prf AlgorithmIdentifier 
            if (a0_0_1_0_1.length < 3)
                info.prf = CryptoJS.algo.SHA1; 
            else
                throw new Error("pbkdf2Prf parm not implemented");
            return info;
        },

        /**
         * generate PBKDF2 key hexstring with specified passcode and information
         * @name getPBKDF2KeyHexFromParam
         * @memberOf KEYUTIL
         * @function
         * @param {Array} info result of {@link parseHexOfEncryptedPKCS8} which has preference of PKCS#8 file
         * @param {String} passcode passcode to decrypto private key
         * @return {String} hexadecimal string of PBKDF2 key
         * @since pkcs5pkey 1.0.3
         * @description
         * As for info, this uses following properties:
         * <ul>
         * <li>info.pbkdf2Salt - hexadecimal string of PBKDF2 salt</li>
         * <li>info.pkbdf2Iter - iteration count</li>
         * </ul>
         * Currently, this method only supports PKCS#5v2.0 with PBES2/PBDKF2 of HmacSHA1 and TripleDES.
         * <ul>
         * <li>keyDerivationFunc = pkcs5PBKDF2 with HmacSHA1</li>
         * <li>encryptionScheme = des-EDE3-CBC(i.e. TripleDES</li>
         * </ul>
         * @example
         * // to convert plain PKCS#5 private key to encrypted PKCS#8 private
         * // key with PBKDF2 with TripleDES
         * % openssl pkcs8 -in plain_p5.pem -topk8 -v2 -des3 -out encrypted_p8.pem
         */
        getPBKDF2KeyHexFromParam: function(info, passcode) {
            var pbkdf2SaltWS = CryptoJS.enc.Hex.parse(info.pbkdf2Salt);
            var pbkdf2Iter = info.pbkdf2Iter;
            var pbkdf2KeyWS = CryptoJS.PBKDF2(passcode, 
                                              pbkdf2SaltWS, 
                                              { keySize: 192/32, iterations: pbkdf2Iter, hasher: pbkdf2prf });
            var pbkdf2KeyHex = CryptoJS.enc.Hex.stringify(pbkdf2KeyWS);
            return pbkdf2KeyHex;
        },

        /*
         * read PEM formatted encrypted PKCS#8 private key and returns hexadecimal string of plain PKCS#8 private key
         * @name getPlainPKCS8HexFromEncryptedPKCS8PEM
         * @memberOf KEYUTIL
         * @function
         * @param {String} pkcs8PEM PEM formatted encrypted PKCS#8 private key
         * @param {String} passcode passcode to decrypto private key
         * @return {String} hexadecimal string of plain PKCS#8 private key
         * @since pkcs5pkey 1.0.3
         * @description
         * Currently, this method only supports PKCS#5v2.0 with PBES2/PBDKF2 of HmacSHA1 and TripleDES.
         * <ul>
         * <li>keyDerivationFunc = pkcs5PBKDF2 with HmacSHA1</li>
         * <li>encryptionScheme = des-EDE3-CBC(i.e. TripleDES</li>
         * </ul>
         * @example
         * // to convert plain PKCS#5 private key to encrypted PKCS#8 private
         * // key with PBKDF2 with TripleDES
         * % openssl pkcs8 -in plain_p5.pem -topk8 -v2 -des3 -out encrypted_p8.pem
         */
        _getPlainPKCS8HexFromEncryptedPKCS8PEM: function(pkcs8PEM, passcode) {
            // 1. derHex - PKCS#8 private key encrypted by PBKDF2
            var derHex = pemtohex(pkcs8PEM, "ENCRYPTED PRIVATE KEY");
            // 2. info - PKCS#5 PBES info
            var info = this.parseHexOfEncryptedPKCS8(derHex);
            // 3. hKey - PBKDF2 key
            var pbkdf2KeyHex = KEYUTIL.getPBKDF2KeyHexFromParam(info, passcode);
            // 4. decrypt ciphertext by PBKDF2 key
            var encrypted = {};
            encrypted.ciphertext = CryptoJS.enc.Hex.parse(info.ciphertext);
            var pbkdf2KeyWS = CryptoJS.enc.Hex.parse(pbkdf2KeyHex);
            var des3IVWS = CryptoJS.enc.Hex.parse(info.encryptionSchemeIV);
            var decWS = CryptoJS.TripleDES.decrypt(encrypted, pbkdf2KeyWS, { iv: des3IVWS });
            var decHex = CryptoJS.enc.Hex.stringify(decWS);
            return decHex;
        },

        /**
         * get RSAKey/ECDSA private key object from encrypted PEM PKCS#8 private key
         * @name getKeyFromEncryptedPKCS8PEM
         * @memberOf KEYUTIL
         * @function
         * @param {String} pkcs8PEM string of PEM formatted PKCS#8 private key
         * @param {String} passcode passcode string to decrypt key
         * @return {Object} RSAKey or KJUR.crypto.ECDSA private key object
         * @since pkcs5pkey 1.0.5
         */
        getKeyFromEncryptedPKCS8PEM: function(pkcs8PEM, passcode) {
            var prvKeyHex = this._getPlainPKCS8HexFromEncryptedPKCS8PEM(pkcs8PEM, passcode);
            var key = this.getKeyFromPlainPrivatePKCS8Hex(prvKeyHex);
            return key;
        },

        /**
         * parse hexadecimal string of plain PKCS#8 private key
         * @name parsePlainPrivatePKCS8Hex
         * @memberOf KEYUTIL
         * @function
         * @param {String} pkcs8PrvHex hexadecimal string of PKCS#8 plain private key
         * @return {Array} associative array of parsed key
         * @since pkcs5pkey 1.0.5
         * @description
         * Resulted associative array has following properties:
         * <ul>
         * <li>algoid - hexadecimal string of OID of asymmetric key algorithm</li>
         * <li>algparam - hexadecimal string of OID of ECC curve name or null</li>
         * <li>keyidx - string starting index of key in pkcs8PrvHex</li>
         * </ul>
         */
        parsePlainPrivatePKCS8Hex: function(pkcs8PrvHex) {
	    var _ASN1HEX = ASN1HEX;
	    var _getChildIdx = _ASN1HEX.getChildIdx;
	    var _getV = _ASN1HEX.getV;
            var result = {};
            result.algparam = null;

            // 1. sequence
            if (pkcs8PrvHex.substr(0, 2) != "30")
                throw new Error("malformed plain PKCS8 private key(code:001)");
	        // not sequence

            var a1 = _getChildIdx(pkcs8PrvHex, 0);
            if (a1.length < 3)
                throw new Error("malformed plain PKCS8 private key(code:002)");
                // less elements

            // 2. AlgID
            if (pkcs8PrvHex.substr(a1[1], 2) != "30")
                throw new Error("malformed PKCS8 private key(code:003)");
                // AlgId not sequence

            var a2 = _getChildIdx(pkcs8PrvHex, a1[1]);
            if (a2.length != 2)
                throw new Error("malformed PKCS8 private key(code:004)");
                // AlgId not have two elements

            // 2.1. AlgID OID
            if (pkcs8PrvHex.substr(a2[0], 2) != "06")
                throw new Error("malformed PKCS8 private key(code:005)");
                // AlgId.oid is not OID

            result.algoid = _getV(pkcs8PrvHex, a2[0]);

            // 2.2. AlgID param
            if (pkcs8PrvHex.substr(a2[1], 2) == "06") {
                result.algparam = _getV(pkcs8PrvHex, a2[1]);
            }

            // 3. Key index
            if (pkcs8PrvHex.substr(a1[2], 2) != "04")
                throw new Error("malformed PKCS8 private key(code:006)");
                // not octet string

            result.keyidx = _ASN1HEX.getVidx(pkcs8PrvHex, a1[2]);

            return result;
        },

        /**
         * get RSAKey/ECDSA private key object from PEM plain PEM PKCS#8 private key
         * @name getKeyFromPlainPrivatePKCS8PEM
         * @memberOf KEYUTIL
         * @function
         * @param {String} pkcs8PEM string of plain PEM formatted PKCS#8 private key
         * @return {Object} RSAKey or KJUR.crypto.ECDSA private key object
         * @since pkcs5pkey 1.0.5
         */
        getKeyFromPlainPrivatePKCS8PEM: function(prvKeyPEM) {
            var prvKeyHex = pemtohex(prvKeyPEM, "PRIVATE KEY");
            var key = this.getKeyFromPlainPrivatePKCS8Hex(prvKeyHex);
            return key;
        },

        /**
         * get RSAKey/DSA/ECDSA private key object from HEX plain PEM PKCS#8 private key
         * @name getKeyFromPlainPrivatePKCS8Hex
         * @memberOf KEYUTIL
         * @function
         * @param {String} prvKeyHex hexadecimal string of plain PKCS#8 private key
         * @return {Object} RSAKey or KJUR.crypto.{DSA,ECDSA} private key object
         * @since pkcs5pkey 1.0.5
         */
        getKeyFromPlainPrivatePKCS8Hex: function(prvKeyHex) {
            var p8 = this.parsePlainPrivatePKCS8Hex(prvKeyHex);
	    var key;
            
            if (p8.algoid == "2a864886f70d010101") { // RSA
		key = new RSAKey();
	    } else if (p8.algoid == "2a8648ce380401") { // DSA
		key = new KJUR.crypto.DSA();
            } else if (p8.algoid == "2a8648ce3d0201") { // ECC
                key = new KJUR.crypto.ECDSA();
            } else {
                throw new Error("unsupported private key algorithm");
            }

	    key.readPKCS8PrvKeyHex(prvKeyHex);
	    return key;
        },

        // === PKCS8 RSA Public Key ================================================

        /*
         * get RSAKey/DSA/ECDSA public key object from hexadecimal string of PKCS#8 public key
         * @name _getKeyFromPublicPKCS8Hex
         * @memberOf KEYUTIL
         * @function
         * @param {String} pkcsPub8Hex hexadecimal string of PKCS#8 public key
         * @return {Object} RSAKey or KJUR.crypto.{ECDSA,DSA} private key object
         * @since pkcs5pkey 1.0.5
         */
        _getKeyFromPublicPKCS8Hex: function(h) {
	    var key;
	    var hOID = ASN1HEX.getVbyList(h, 0, [0, 0], "06");

	    if (hOID === "2a864886f70d010101") {    // oid=RSA
		key = new RSAKey();
	    } else if (hOID === "2a8648ce380401") { // oid=DSA
		key = new KJUR.crypto.DSA();
	    } else if (hOID === "2a8648ce3d0201") { // oid=ECPUB
		key = new KJUR.crypto.ECDSA();
	    } else {
		throw new Error("unsupported PKCS#8 public key hex");
	    }
	    key.readPKCS8PubKeyHex(h);
	    return key;
	},

        /**
         * parse hexadecimal string of plain PKCS#8 private key
         * @name parsePublicRawRSAKeyHex
         * @memberOf KEYUTIL
         * @function
         * @param {String} pubRawRSAHex hexadecimal string of ASN.1 encoded PKCS#8 public key
         * @return {Array} associative array of parsed key
         * @since pkcs5pkey 1.0.5
         * @description
         * Resulted associative array has following properties:
         * <ul>
         * <li>n - hexadecimal string of public key
         * <li>e - hexadecimal string of public exponent
         * </ul>
         */
        parsePublicRawRSAKeyHex: function(pubRawRSAHex) {
	    var _ASN1HEX = ASN1HEX;
	    var _getChildIdx = _ASN1HEX.getChildIdx;
	    var _getV = _ASN1HEX.getV;
            var result = {};
            
            // 1. Sequence
            if (pubRawRSAHex.substr(0, 2) != "30")
                throw new Error("malformed RSA key(code:001)"); // not sequence
            
            var a1 = _getChildIdx(pubRawRSAHex, 0);
            if (a1.length != 2)
                throw new Error("malformed RSA key(code:002)"); // not 2 items in seq

            // 2. public key "N"
            if (pubRawRSAHex.substr(a1[0], 2) != "02")
                throw new Error("malformed RSA key(code:003)"); // 1st item is not integer

            result.n = _getV(pubRawRSAHex, a1[0]);

            // 3. public key "E"
            if (pubRawRSAHex.substr(a1[1], 2) != "02")
                throw new Error("malformed RSA key(code:004)"); // 2nd item is not integer

            result.e = _getV(pubRawRSAHex, a1[1]);

            return result;
        },

        /**
         * parse hexadecimal string of PKCS#8 RSA/EC/DSA public key
         * @name parsePublicPKCS8Hex
         * @memberOf KEYUTIL
         * @function
         * @param {String} pkcs8PubHex hexadecimal string of PKCS#8 public key
         * @return {Hash} hash of key information
         * @description
         * Resulted hash has following attributes.
         * <ul>
         * <li>algoid - hexadecimal string of OID of asymmetric key algorithm</li>
         * <li>algparam - hexadecimal string of OID of ECC curve name, parameter SEQUENCE of DSA or null</li>
         * <li>key - hexadecimal string of public key</li>
         * </ul>
         */
        parsePublicPKCS8Hex: function(pkcs8PubHex) {
	    var _ASN1HEX = ASN1HEX;
	    var _getChildIdx = _ASN1HEX.getChildIdx;
	    var _getV = _ASN1HEX.getV;
            var result = {};
            result.algparam = null;

            // 1. AlgID and Key bit string
            var a1 = _getChildIdx(pkcs8PubHex, 0);
            if (a1.length != 2)
                throw new Error("outer DERSequence shall have 2 elements: " + a1.length);

            // 2. AlgID
            var idxAlgIdTLV = a1[0];
            if (pkcs8PubHex.substr(idxAlgIdTLV, 2) != "30")
                throw new Error("malformed PKCS8 public key(code:001)"); // AlgId not sequence

            var a2 = _getChildIdx(pkcs8PubHex, idxAlgIdTLV);
            if (a2.length != 2)
                throw new Error("malformed PKCS8 public key(code:002)"); // AlgId not have two elements

            // 2.1. AlgID OID
            if (pkcs8PubHex.substr(a2[0], 2) != "06")
                throw new Error("malformed PKCS8 public key(code:003)"); // AlgId.oid is not OID

            result.algoid = _getV(pkcs8PubHex, a2[0]);

            // 2.2. AlgID param
            if (pkcs8PubHex.substr(a2[1], 2) == "06") { // OID for EC
                result.algparam = _getV(pkcs8PubHex, a2[1]);
            } else if (pkcs8PubHex.substr(a2[1], 2) == "30") { // SEQ for DSA
                result.algparam = {};
                result.algparam.p = _ASN1HEX.getVbyList(pkcs8PubHex, a2[1], [0], "02");
                result.algparam.q = _ASN1HEX.getVbyList(pkcs8PubHex, a2[1], [1], "02");
                result.algparam.g = _ASN1HEX.getVbyList(pkcs8PubHex, a2[1], [2], "02");
            }

            // 3. Key
            if (pkcs8PubHex.substr(a1[1], 2) != "03")
                throw new Error("malformed PKCS8 public key(code:004)"); // Key is not bit string

            result.key = _getV(pkcs8PubHex, a1[1]).substr(2);
            
            // 4. return result assoc array
            return result;
        },
    };
}();

// -- MAJOR PUBLIC METHODS ----------------------------------------------------
/**
 * get private or public key object from any arguments
 * @name getKey
 * @memberOf KEYUTIL
 * @function
 * @static
 * @param {Object} param parameter to get key object. see description in detail.
 * @param {String} passcode (OPTION) parameter to get key object. see description in detail.
 * @param {String} hextype (OPTOIN) parameter to get key object. see description in detail.
 * @return {Object} {@link RSAKey}, {@link KJUR.crypto.ECDSA} or {@link KJUR.crypto.ECDSA} object
 * @since keyutil 1.0.0
 * @description
 * This method gets private or public key object({@link RSAKey}, {@link KJUR.crypto.DSA} or {@link KJUR.crypto.ECDSA})
 * for RSA, DSA and ECC.
 * Arguments for this methods depends on a key format you specify.
 * Following key representations are supported.
 * <ul>
 * <li>ECC private/public key object(as is): param=KJUR.crypto.ECDSA</li>
 * <li>DSA private/public key object(as is): param=KJUR.crypto.DSA</li>
 * <li>RSA private/public key object(as is): param=RSAKey </li>
 * <li>ECC private key parameters: param={d: d, curve: curveName}</li>
 * <li>RSA private key parameters: param={n: n, e: e, d: d, p: p, q: q, dp: dp, dq: dq, co: co}<br/>
 * NOTE: Each value shall be hexadecimal string of key spec.</li>
 * <li>DSA private key parameters: param={p: p, q: q, g: g, y: y, x: x}<br/>
 * NOTE: Each value shall be hexadecimal string of key spec.</li>
 * <li>ECC public key parameters: param={xy: xy, curve: curveName}<br/>
 * NOTE: ECC public key 'xy' shall be concatination of "04", x-bytes-hex and y-bytes-hex.</li>
 * <li>DSA public key parameters: param={p: p, q: q, g: g, y: y}<br/>
 * NOTE: Each value shall be hexadecimal string of key spec.</li>
 * <li>RSA public key parameters: param={n: n, e: e} </li>
 * <li>X.509v1/v3 PEM certificate (RSA/DSA/ECC): param=pemString</li>
 * <li>PKCS#8 hexadecimal RSA/ECC public key: param=pemString, null, "pkcs8pub"</li>
 * <li>PKCS#8 PEM RSA/DSA/ECC public key: param=pemString</li>
 * <li>PKCS#5 plain hexadecimal RSA private key: param=hexString, null, "pkcs5prv"</li>
 * <li>PKCS#5 plain PEM RSA/DSA/EC private key: param=pemString</li>
 * <li>PKCS#8 plain PEM RSA/EC private key: param=pemString</li>
 * <li>PKCS#5 encrypted PEM RSA/DSA/EC private key: param=pemString, passcode</li>
 * <li>PKCS#8 encrypted PEM RSA/EC private key: param=pemString, passcode</li>
 * </ul>
 * Please note following limitation on encrypted keys:
 * <ul>
 * <li>Encrypted PKCS#8 only supports PBKDF2/HmacSHA1/3DES</li>
 * <li>Encrypted PKCS#5 supports DES-CBC, DES-EDE3-CBC, AES-{128,192.256}-CBC</li>
 * <li>JWT plain ECC private/public key</li>
 * <li>JWT plain RSA public key</li>
 * <li>JWT plain RSA private key with P/Q/DP/DQ/COEFF</li>
 * <li>JWT plain RSA private key without P/Q/DP/DQ/COEFF (since jsrsasign 5.0.0)</li>
 * </ul>
 * NOTE1: <a href="https://tools.ietf.org/html/rfc7517">RFC 7517 JSON Web Key(JWK)</a> support for RSA/ECC private/public key from jsrsasign 4.8.1.<br/>
 * NOTE2: X509v1 support is added since jsrsasign 5.0.11.
 * 
 * <h5>EXAMPLE</h5>
 * @example
 * // 1. loading private key from PEM string
 * keyObj = KEYUTIL.getKey("-----BEGIN RSA PRIVATE KEY...");
 * keyObj = KEYUTIL.getKey("-----BEGIN RSA PRIVATE KEY..., "passcode");
 * keyObj = KEYUTIL.getKey("-----BEGIN PRIVATE KEY...");
 * keyObj = KEYUTIL.getKey("-----BEGIN PRIVATE KEY...", "passcode");
 * keyObj = KEYUTIL.getKey("-----BEGIN EC PARAMETERS...-----BEGIN EC PRIVATE KEY...");
 * // 2. loading public key from PEM string
 * keyObj = KEYUTIL.getKey("-----BEGIN PUBLIC KEY...");
 * keyObj = KEYUTIL.getKey("-----BEGIN X509 CERTIFICATE...");
 * // 3. loading hexadecimal PKCS#5/PKCS#8 key
 * keyObj = KEYUTIL.getKey("308205c1...", null, "pkcs8pub");
 * keyObj = KEYUTIL.getKey("3082048b...", null, "pkcs5prv");
 * // 4. loading JSON Web Key(JWK)
 * keyObj = KEYUTIL.getKey({kty: "RSA", n: "0vx7...", e: "AQAB"});
 * keyObj = KEYUTIL.getKey({kty: "EC", crv: "P-256", 
 *                          x: "MKBC...", y: "4Etl6...", d: "870Mb..."});
 * // 5. bare hexadecimal key
 * keyObj = KEYUTIL.getKey({n: "75ab..", e: "010001"});
 */
KEYUTIL.getKey = function(param, passcode, hextype) {
    var _ASN1HEX = ASN1HEX,
	_getChildIdx = _ASN1HEX.getChildIdx,
	_getV = _ASN1HEX.getV,
	_getVbyList = _ASN1HEX.getVbyList,
	_KJUR_crypto = KJUR.crypto,
	_KJUR_crypto_ECDSA = _KJUR_crypto.ECDSA,
	_KJUR_crypto_DSA = _KJUR_crypto.DSA,
	_RSAKey = RSAKey,
	_pemtohex = pemtohex,
	_KEYUTIL = KEYUTIL;

    // 1. by key RSAKey/KJUR.crypto.ECDSA/KJUR.crypto.DSA object
    if (typeof _RSAKey != 'undefined' && param instanceof _RSAKey)
        return param;
    if (typeof _KJUR_crypto_ECDSA != 'undefined' && param instanceof _KJUR_crypto_ECDSA)
        return param;
    if (typeof _KJUR_crypto_DSA != 'undefined' && param instanceof _KJUR_crypto_DSA)
        return param;

    // 2. by parameters of key

    // 2.1. bare ECC
    // 2.1.1. bare ECC public key by hex values
    if (param.curve !== undefined &&
	param.xy !== undefined && param.d === undefined) {
        return new _KJUR_crypto_ECDSA({pub: param.xy, curve: param.curve});
    }

    // 2.1.2. bare ECC private key by hex values
    if (param.curve !== undefined && param.d !== undefined) {
        return new _KJUR_crypto_ECDSA({prv: param.d, curve: param.curve});
    }

    // 2.2. bare RSA
    // 2.2.1. bare RSA public key by hex values
    if (param.kty === undefined &&
	param.n !== undefined && param.e !== undefined &&
        param.d === undefined) {
        var key = new _RSAKey();
        key.setPublic(param.n, param.e);
        return key;
    }

    // 2.2.2. bare RSA private key with P/Q/DP/DQ/COEFF by hex values
    if (param.kty === undefined &&
	param.n !== undefined &&
	param.e !== undefined &&
	param.d !== undefined &&
        param.p !== undefined &&
	param.q !== undefined &&
        param.dp !== undefined &&
	param.dq !== undefined &&
	param.co !== undefined &&
        param.qi === undefined) {
        var key = new _RSAKey();
        key.setPrivateEx(param.n, param.e, param.d, param.p, param.q,
                         param.dp, param.dq, param.co);
        return key;
    }

    // 2.2.3. bare RSA public key without P/Q/DP/DQ/COEFF by hex values
    if (param.kty === undefined &&
	param.n !== undefined &&
	param.e !== undefined &&
	param.d !== undefined &&
        param.p === undefined) {
        var key = new _RSAKey();
        key.setPrivate(param.n, param.e, param.d);
        return key;
    }

    // 2.3. bare DSA
    // 2.3.1. bare DSA public key by hex values
    if (param.p !== undefined && param.q !== undefined &&
	param.g !== undefined &&
        param.y !== undefined && param.x === undefined) {
        var key = new _KJUR_crypto_DSA();
        key.setPublic(param.p, param.q, param.g, param.y);
        return key;
    }

    // 2.3.2. bare DSA private key by hex values
    if (param.p !== undefined && param.q !== undefined &&
	param.g !== undefined &&
        param.y !== undefined && param.x !== undefined) {
        var key = new _KJUR_crypto_DSA();
        key.setPrivate(param.p, param.q, param.g, param.y, param.x);
        return key;
    }

    // 3. JWK
    // 3.1. JWK RSA
    // 3.1.1. JWK RSA public key by b64u values
    if (param.kty === "RSA" &&
	param.n !== undefined &&
	param.e !== undefined &&
	param.d === undefined) {
	var key = new _RSAKey();
	key.setPublic(b64utohex(param.n), b64utohex(param.e));
	return key;
    }

    // 3.1.2. JWK RSA private key with p/q/dp/dq/coeff by b64u values
    if (param.kty === "RSA" &&
	param.n !== undefined &&
	param.e !== undefined &&
	param.d !== undefined &&
	param.p !== undefined &&
	param.q !== undefined &&
	param.dp !== undefined &&
	param.dq !== undefined &&
	param.qi !== undefined) {
	var key = new _RSAKey();
        key.setPrivateEx(b64utohex(param.n),
			 b64utohex(param.e),
			 b64utohex(param.d),
			 b64utohex(param.p),
			 b64utohex(param.q),
                         b64utohex(param.dp),
			 b64utohex(param.dq),
			 b64utohex(param.qi));
	return key;
    }

    // 3.1.3. JWK RSA private key without p/q/dp/dq/coeff by b64u
    //        since jsrsasign 5.0.0 keyutil 1.0.11
    if (param.kty === "RSA" &&
	param.n !== undefined &&
	param.e !== undefined &&
	param.d !== undefined) {
	var key = new _RSAKey();
        key.setPrivate(b64utohex(param.n),
		       b64utohex(param.e),
		       b64utohex(param.d));
	return key;
    }

    // 3.2. JWK ECC
    // 3.2.1. JWK ECC public key by b64u values
    if (param.kty === "EC" &&
	param.crv !== undefined &&
	param.x !== undefined &&
	param.y !== undefined &&
        param.d === undefined) {
	var ec = new _KJUR_crypto_ECDSA({"curve": param.crv});
	var charlen = ec.ecparams.keycharlen;
        var hX   = ("0000000000" + b64utohex(param.x)).slice(- charlen);
        var hY   = ("0000000000" + b64utohex(param.y)).slice(- charlen);
        var hPub = "04" + hX + hY;
	ec.setPublicKeyHex(hPub);
	return ec;
    }

    // 3.2.2. JWK ECC private key by b64u values
    if (param.kty === "EC" &&
	param.crv !== undefined &&
	param.x !== undefined &&
	param.y !== undefined &&
        param.d !== undefined) {
	var ec = new _KJUR_crypto_ECDSA({"curve": param.crv});
	var charlen = ec.ecparams.keycharlen;
        var hX   = ("0000000000" + b64utohex(param.x)).slice(- charlen);
        var hY   = ("0000000000" + b64utohex(param.y)).slice(- charlen);
        var hPub = "04" + hX + hY;
        var hPrv = ("0000000000" + b64utohex(param.d)).slice(- charlen);
	ec.setPublicKeyHex(hPub);
	ec.setPrivateKeyHex(hPrv);
	return ec;
    }
    
    // 4. (plain) hexadecimal data
    // 4.1. get private key by PKCS#5 plain RSA/DSA/ECDSA hexadecimal string
    if (hextype === "pkcs5prv") {
	var h = param, _ASN1HEX = ASN1HEX, a, key;
	a = _getChildIdx(h, 0);
	if (a.length === 9) {        // RSA (INT x 9)
	    key = new _RSAKey();
            key.readPKCS5PrvKeyHex(h);
	} else if (a.length === 6) { // DSA (INT x 6)
	    key = new _KJUR_crypto_DSA();
	    key.readPKCS5PrvKeyHex(h);
	} else if (a.length > 2 &&   // ECDSA (INT, OCT prv, [0] curve, [1] pub)
		   h.substr(a[1], 2) === "04") {
	    key = new _KJUR_crypto_ECDSA();
	    key.readPKCS5PrvKeyHex(h);
	} else {
	    throw new Error("unsupported PKCS#1/5 hexadecimal key");
	}

        return key;
    }

    // 4.2. get private key by PKCS#8 plain RSA/DSA/ECDSA hexadecimal string
    if (hextype === "pkcs8prv") {
	var key = _KEYUTIL.getKeyFromPlainPrivatePKCS8Hex(param);
        return key;
    }

    // 4.3. get public key by PKCS#8 RSA/DSA/ECDSA hexadecimal string
    if (hextype === "pkcs8pub") {
        return _KEYUTIL._getKeyFromPublicPKCS8Hex(param);
    }

    // 4.4. get public key by X.509 hexadecimal string for RSA/DSA/ECDSA
    if (hextype === "x509pub") {
        return X509.getPublicKeyFromCertHex(param);
    }

    // 5. by PEM certificate (-----BEGIN ... CERTIFICATE----)
    if (param.indexOf("-END CERTIFICATE-", 0) != -1 ||
        param.indexOf("-END X509 CERTIFICATE-", 0) != -1 ||
        param.indexOf("-END TRUSTED CERTIFICATE-", 0) != -1) {
        return X509.getPublicKeyFromCertPEM(param);
    }

    // 6. public key by PKCS#8 PEM string
    if (param.indexOf("-END PUBLIC KEY-") != -1) {
        var pubKeyHex = pemtohex(param, "PUBLIC KEY");
        return _KEYUTIL._getKeyFromPublicPKCS8Hex(pubKeyHex);
    }
    
    // 8.1 private key by plain PKCS#5 PEM RSA string 
    //    getKey("-----BEGIN RSA PRIVATE KEY-...")
    if (param.indexOf("-END RSA PRIVATE KEY-") != -1 &&
        param.indexOf("4,ENCRYPTED") == -1) {
        var hex = _pemtohex(param, "RSA PRIVATE KEY");
        return _KEYUTIL.getKey(hex, null, "pkcs5prv");
    }

    // 8.2. private key by plain PKCS#5 PEM DSA string
    if (param.indexOf("-END DSA PRIVATE KEY-") != -1 &&
        param.indexOf("4,ENCRYPTED") == -1) {

        var hKey = _pemtohex(param, "DSA PRIVATE KEY");
        var p = _getVbyList(hKey, 0, [1], "02");
        var q = _getVbyList(hKey, 0, [2], "02");
        var g = _getVbyList(hKey, 0, [3], "02");
        var y = _getVbyList(hKey, 0, [4], "02");
        var x = _getVbyList(hKey, 0, [5], "02");
        var key = new _KJUR_crypto_DSA();
        key.setPrivate(new BigInteger(p, 16),
                       new BigInteger(q, 16),
                       new BigInteger(g, 16),
                       new BigInteger(y, 16),
                       new BigInteger(x, 16));
        return key;
    }

    // 8.3. private key by plain PKCS#5 PEM EC string
    if (param.indexOf("-END EC PRIVATE KEY-") != -1 &&
        param.indexOf("4,ENCRYPTED") == -1) {
        var hex = _pemtohex(param, "EC PRIVATE KEY");
        return _KEYUTIL.getKey(hex, null, "pkcs5prv");
    }

    // 10. private key by plain PKCS#8 PEM ECC/RSA string
    if (param.indexOf("-END PRIVATE KEY-") != -1) {
        return _KEYUTIL.getKeyFromPlainPrivatePKCS8PEM(param);
    }

    // 11.1 private key by encrypted PKCS#5 PEM RSA string
    if (param.indexOf("-END RSA PRIVATE KEY-") != -1 &&
        param.indexOf("4,ENCRYPTED") != -1) {
        var hPKey = _KEYUTIL.getDecryptedKeyHex(param, passcode);
        var rsaKey = new RSAKey();
        rsaKey.readPKCS5PrvKeyHex(hPKey);
        return rsaKey;
    }

    // 11.2. private key by encrypted PKCS#5 PEM ECDSA string
    if (param.indexOf("-END EC PRIVATE KEY-") != -1 &&
        param.indexOf("4,ENCRYPTED") != -1) {
        var hKey = _KEYUTIL.getDecryptedKeyHex(param, passcode);

        var key = _getVbyList(hKey, 0, [1], "04");
        var curveNameOidHex = _getVbyList(hKey, 0, [2,0], "06");
        var pubkey = _getVbyList(hKey, 0, [3,0], "03").substr(2);
        var curveName = "";

        if (KJUR.crypto.OID.oidhex2name[curveNameOidHex] !== undefined) {
            curveName = KJUR.crypto.OID.oidhex2name[curveNameOidHex];
        } else {
            throw new Error("undefined OID(hex) in KJUR.crypto.OID: " + 
			    curveNameOidHex);
        }

        var ec = new _KJUR_crypto_ECDSA({'curve': curveName});
        ec.setPublicKeyHex(pubkey);
        ec.setPrivateKeyHex(key);
        ec.isPublic = false;
        return ec;
    }

    // 11.3. private key by encrypted PKCS#5 PEM DSA string
    if (param.indexOf("-END DSA PRIVATE KEY-") != -1 &&
        param.indexOf("4,ENCRYPTED") != -1) {
        var hKey = _KEYUTIL.getDecryptedKeyHex(param, passcode);
        var p = _getVbyList(hKey, 0, [1], "02");
        var q = _getVbyList(hKey, 0, [2], "02");
        var g = _getVbyList(hKey, 0, [3], "02");
        var y = _getVbyList(hKey, 0, [4], "02");
        var x = _getVbyList(hKey, 0, [5], "02");
        var key = new _KJUR_crypto_DSA();
        key.setPrivate(new BigInteger(p, 16),
                       new BigInteger(q, 16),
                       new BigInteger(g, 16),
                       new BigInteger(y, 16),
                       new BigInteger(x, 16));
        return key;
    }

    // 11. private key by encrypted PKCS#8 hexadecimal RSA/ECDSA string
    if (param.indexOf("-END ENCRYPTED PRIVATE KEY-") != -1) {
        return _KEYUTIL.getKeyFromEncryptedPKCS8PEM(param, passcode);
    }

    throw new Error("not supported argument");
};

/**
 * @name generateKeypair
 * @memberOf KEYUTIL
 * @function
 * @static
 * @param {String} alg 'RSA' or 'EC'
 * @param {Object} keylenOrCurve key length for RSA or curve name for EC
 * @return {Array} associative array of keypair which has prvKeyObj and pubKeyObj parameters
 * @since keyutil 1.0.1
 * @description
 * This method generates a key pair of public key algorithm.
 * The result will be an associative array which has following
 * parameters:
 * <ul>
 * <li>prvKeyObj - RSAKey or ECDSA object of private key</li>
 * <li>pubKeyObj - RSAKey or ECDSA object of public key</li>
 * </ul>
 * NOTE1: As for RSA algoirthm, public exponent has fixed
 * value '0x10001'.
 * NOTE2: As for EC algorithm, supported names of curve are
 * secp256r1, secp256k1, secp384r1 and secp521r1.
 * NOTE3: DSA is not supported yet.
 * @example
 * var rsaKeypair = KEYUTIL.generateKeypair("RSA", 1024);
 * var ecKeypair = KEYUTIL.generateKeypair("EC", "secp256r1");
 *
 */
KEYUTIL.generateKeypair = function(alg, keylenOrCurve) {
    if (alg == "RSA") {
        var keylen = keylenOrCurve;
        var prvKey = new RSAKey();
        prvKey.generate(keylen, '10001');
        prvKey.isPrivate = true;
        prvKey.isPublic = true;
        
        var pubKey = new RSAKey();
        var hN = prvKey.n.toString(16);
        var hE = prvKey.e.toString(16);
        pubKey.setPublic(hN, hE);
        pubKey.isPrivate = false;
        pubKey.isPublic = true;
        
        var result = {};
        result.prvKeyObj = prvKey;
        result.pubKeyObj = pubKey;
        return result;
    } else if (alg == "EC") {
        var curve = keylenOrCurve;
        var ec = new KJUR.crypto.ECDSA({curve: curve});
        var keypairHex = ec.generateKeyPairHex();

        var prvKey = new KJUR.crypto.ECDSA({curve: curve});
        prvKey.setPublicKeyHex(keypairHex.ecpubhex);
        prvKey.setPrivateKeyHex(keypairHex.ecprvhex);
        prvKey.isPrivate = true;
        prvKey.isPublic = false;

        var pubKey = new KJUR.crypto.ECDSA({curve: curve});
        pubKey.setPublicKeyHex(keypairHex.ecpubhex);
        pubKey.isPrivate = false;
        pubKey.isPublic = true;

        var result = {};
        result.prvKeyObj = prvKey;
        result.pubKeyObj = pubKey;
        return result;
    } else {
        throw new Error("unknown algorithm: " + alg);
    }
};

/**
 * get PEM formatted private or public key file from a RSA/ECDSA/DSA key object
 * @name getPEM
 * @memberOf KEYUTIL
 * @function
 * @static
 * @param {Object} keyObjOrHex key object {@link RSAKey}, {@link KJUR.crypto.ECDSA} or {@link KJUR.crypto.DSA} to encode to
 * @param {String} formatType (OPTION) output format type of "PKCS1PRV", "PKCS5PRV" or "PKCS8PRV" for private key
 * @param {String} passwd (OPTION) password to protect private key
 * @param {String} encAlg (OPTION) encryption algorithm for PKCS#5. currently supports DES-CBC, DES-EDE3-CBC and AES-{128,192,256}-CBC
 * @param {String} hexType (OPTION) type of hex string (ex. pkcs5prv, pkcs8prv)
 * @param {String} ivsaltHex hexadecimal string of IV and salt (default generated random IV)
 * @since keyutil 1.0.4
 * @description
 * <dl>
 * <dt><b>NOTE1:</b>
 * <dd>
 * PKCS#5 encrypted private key protection algorithm supports DES-CBC, 
 * DES-EDE3-CBC and AES-{128,192,256}-CBC
 * <dt><b>NOTE2:</b>
 * <dd>
 * OpenSSL supports
 * <dt><b>NOTE3:</b>
 * <dd>
 * Parameter "ivsaltHex" supported since jsrsasign 8.0.0 keyutil 1.2.0.
 * </dl>
 * @example
 * KEUUTIL.getPEM(publicKey) &rarr; generates PEM PKCS#8 public key 
 * KEUUTIL.getPEM(privateKey) &rarr; generates PEM PKCS#8 plain private key by default
 * KEUUTIL.getPEM(privateKey, "PKCS1PRV") &rarr; generates PEM PKCS#1 plain private key
 * KEUUTIL.getPEM(privateKey, "PKCS5PRV", "pass") &rarr; generates PEM PKCS#5 encrypted private key 
 *                                                          with DES-EDE3-CBC (DEFAULT)
 * KEUUTIL.getPEM(privateKey, "PKCS5PRV", "pass", "DES-CBC") &rarr; generates PEM PKCS#5 encrypted 
 *                                                                 private key with DES-CBC
 * KEUUTIL.getPEM(privateKey, "PKCS8PRV") &rarr; generates PEM PKCS#8 plain private key
 * KEUUTIL.getPEM(privateKey, "PKCS8PRV", "pass") &rarr; generates PEM PKCS#8 encrypted private key
 *                                                      with PBKDF2_HmacSHA1_3DES
 */
KEYUTIL.getPEM = function(keyObjOrHex, formatType, passwd, encAlg, hexType, ivsaltHex) {
    var _KJUR = KJUR,
	_KJUR_asn1 = _KJUR.asn1,
	_DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
	_DERInteger = _KJUR_asn1.DERInteger,
	_newObject = _KJUR_asn1.ASN1Util.newObject,
	_KJUR_asn1_x509 = _KJUR_asn1.x509,
	_SubjectPublicKeyInfo = _KJUR_asn1_x509.SubjectPublicKeyInfo,
	_KJUR_crypto = _KJUR.crypto,
	_DSA = _KJUR_crypto.DSA,
	_ECDSA = _KJUR_crypto.ECDSA,
	_RSAKey = RSAKey;

    function _rsaprv2asn1obj(keyObjOrHex) {
        var asn1Obj = _newObject({
            "seq": [
                {"int": 0 },
                {"int": {"bigint": keyObjOrHex.n}},
                {"int": keyObjOrHex.e},
                {"int": {"bigint": keyObjOrHex.d}},
                {"int": {"bigint": keyObjOrHex.p}},
                {"int": {"bigint": keyObjOrHex.q}},
                {"int": {"bigint": keyObjOrHex.dmp1}},
                {"int": {"bigint": keyObjOrHex.dmq1}},
                {"int": {"bigint": keyObjOrHex.coeff}}
            ]
        });
        return asn1Obj;
    };

    function _ecdsaprv2asn1obj(keyObjOrHex) {
        var asn1Obj2 = _newObject({
            "seq": [
                {"int": 1 },
                {"octstr": {"hex": keyObjOrHex.prvKeyHex}},
                {"tag": ['a0', true, {'oid': {'name': keyObjOrHex.curveName}}]},
                {"tag": ['a1', true, {'bitstr': {'hex': '00' + keyObjOrHex.pubKeyHex}}]}
            ]
        });
        return asn1Obj2;
    };

    function _dsaprv2asn1obj(keyObjOrHex) {
        var asn1Obj = _newObject({
            "seq": [
                {"int": 0 },
                {"int": {"bigint": keyObjOrHex.p}},
                {"int": {"bigint": keyObjOrHex.q}},
                {"int": {"bigint": keyObjOrHex.g}},
                {"int": {"bigint": keyObjOrHex.y}},
                {"int": {"bigint": keyObjOrHex.x}}
            ]
        });
        return asn1Obj;
    };

    // 1. public key

    // x. PEM PKCS#8 public key of RSA/ECDSA/DSA public key object
    if (((_RSAKey !== undefined && keyObjOrHex instanceof _RSAKey) ||
         (_DSA !== undefined    && keyObjOrHex instanceof _DSA) ||
         (_ECDSA !== undefined  && keyObjOrHex instanceof _ECDSA)) &&
        keyObjOrHex.isPublic == true &&
        (formatType === undefined || formatType == "PKCS8PUB")) {
        var asn1Obj = new _SubjectPublicKeyInfo(keyObjOrHex);
        var asn1Hex = asn1Obj.tohex();
        return hextopem(asn1Hex, "PUBLIC KEY");
    }
    
    // 2. private

    // x. PEM PKCS#1 plain private key of RSA private key object
    if (formatType == "PKCS1PRV" &&
        _RSAKey !== undefined &&
        keyObjOrHex instanceof _RSAKey &&
        (passwd === undefined || passwd == null) &&
        keyObjOrHex.isPrivate  == true) {

        var asn1Obj = _rsaprv2asn1obj(keyObjOrHex);
        var asn1Hex = asn1Obj.tohex();
        return hextopem(asn1Hex, "RSA PRIVATE KEY");
    }

    // x. PEM PKCS#1 plain private key of ECDSA private key object
    if (formatType == "PKCS1PRV" &&
        _ECDSA !== undefined &&
        keyObjOrHex instanceof _ECDSA &&
        (passwd === undefined || passwd == null) &&
        keyObjOrHex.isPrivate  == true) {

        var asn1Obj1 = 
	    new _DERObjectIdentifier({'name': keyObjOrHex.curveName});
        var asn1Hex1 = asn1Obj1.tohex();
        var asn1Obj2 = _ecdsaprv2asn1obj(keyObjOrHex);
        var asn1Hex2 = asn1Obj2.tohex();

        var s = "";
        s += hextopem(asn1Hex1, "EC PARAMETERS");
        s += hextopem(asn1Hex2, "EC PRIVATE KEY");
        return s;
    }

    // x. PEM PKCS#1 plain private key of DSA private key object
    if (formatType == "PKCS1PRV" &&
        _DSA !== undefined &&
        keyObjOrHex instanceof _DSA &&
        (passwd === undefined || passwd == null) &&
        keyObjOrHex.isPrivate  == true) {

        var asn1Obj = _dsaprv2asn1obj(keyObjOrHex);
        var asn1Hex = asn1Obj.tohex();
        return hextopem(asn1Hex, "DSA PRIVATE KEY");
    }

    // 3. private

    // x. PEM PKCS#5 encrypted private key of RSA private key object
    if (formatType == "PKCS5PRV" &&
        _RSAKey !== undefined &&
        keyObjOrHex instanceof _RSAKey &&
        (passwd !== undefined && passwd != null) &&
        keyObjOrHex.isPrivate  == true) {

        var asn1Obj = _rsaprv2asn1obj(keyObjOrHex);
        var asn1Hex = asn1Obj.tohex();

        if (encAlg === undefined) encAlg = "DES-EDE3-CBC";
        return this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA", asn1Hex, passwd, encAlg, ivsaltHex);
    }

    // x. PEM PKCS#5 encrypted private key of ECDSA private key object
    if (formatType == "PKCS5PRV" &&
        _ECDSA !== undefined &&
        keyObjOrHex instanceof _ECDSA &&
        (passwd !== undefined && passwd != null) &&
        keyObjOrHex.isPrivate  == true) {

        var asn1Obj = _ecdsaprv2asn1obj(keyObjOrHex);
        var asn1Hex = asn1Obj.tohex();

        if (encAlg === undefined) encAlg = "DES-EDE3-CBC";
        return this.getEncryptedPKCS5PEMFromPrvKeyHex("EC", asn1Hex, passwd, encAlg, ivsaltHex);
    }

    // x. PEM PKCS#5 encrypted private key of DSA private key object
    if (formatType == "PKCS5PRV" &&
        _DSA !== undefined &&
        keyObjOrHex instanceof _DSA &&
        (passwd !== undefined && passwd != null) &&
        keyObjOrHex.isPrivate  == true) {

        var asn1Obj = _dsaprv2asn1obj(keyObjOrHex);
        var asn1Hex = asn1Obj.tohex();

        if (encAlg === undefined) encAlg = "DES-EDE3-CBC";
        return this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA", asn1Hex, passwd, encAlg, ivsaltHex);
    }

    // x. ======================================================================

    var _getEncryptedPKCS8 = function(plainKeyHex, passcode) {
        var info = _getEencryptedPKCS8Info(plainKeyHex, passcode);
        //alert("iv=" + info.encryptionSchemeIV);
        //alert("info.ciphertext2[" + info.ciphertext.length + "=" + info.ciphertext);
        var asn1Obj = new _newObject({
            "seq": [
                {"seq": [
                    {"oid": {"name": "pkcs5PBES2"}},
                    {"seq": [
                        {"seq": [
                            {"oid": {"name": "pkcs5PBKDF2"}},
                            {"seq": [
                                {"octstr": {"hex": info.pbkdf2Salt}},
                                {"int": info.pbkdf2Iter}
                            ]}
                        ]},
                        {"seq": [
                            {"oid": {"name": "des-EDE3-CBC"}},
                            {"octstr": {"hex": info.encryptionSchemeIV}}
                        ]}
                    ]}
                ]},
                {"octstr": {"hex": info.ciphertext}}
            ]
        });
        return asn1Obj.tohex();
    };

    var _getEencryptedPKCS8Info = function(plainKeyHex, passcode) {
        var pbkdf2Iter = 100;
        var pbkdf2SaltWS = CryptoJS.lib.WordArray.random(8);
        var encryptionSchemeAlg = "DES-EDE3-CBC";
        var encryptionSchemeIVWS = CryptoJS.lib.WordArray.random(8);
        // PBKDF2 key
        var pbkdf2KeyWS = CryptoJS.PBKDF2(passcode, 
                                          pbkdf2SaltWS, { "keySize": 192/32,
                                                          "iterations": pbkdf2Iter });
        // ENCRYPT
        var plainKeyWS = CryptoJS.enc.Hex.parse(plainKeyHex);
        var encryptedKeyHex = 
            CryptoJS.TripleDES.encrypt(plainKeyWS, pbkdf2KeyWS, { "iv": encryptionSchemeIVWS }) + "";

        //alert("encryptedKeyHex=" + encryptedKeyHex);

        var info = {};
        info.ciphertext = encryptedKeyHex;
        //alert("info.ciphertext=" + info.ciphertext);
        info.pbkdf2Salt = CryptoJS.enc.Hex.stringify(pbkdf2SaltWS);
        info.pbkdf2Iter = pbkdf2Iter;
        info.encryptionSchemeAlg = encryptionSchemeAlg;
        info.encryptionSchemeIV = CryptoJS.enc.Hex.stringify(encryptionSchemeIVWS);
        return info;
    };

    // x. PEM PKCS#8 plain private key of RSA private key object
    if (formatType == "PKCS8PRV" &&
        _RSAKey != undefined &&
        keyObjOrHex instanceof _RSAKey &&
        keyObjOrHex.isPrivate  == true) {

        var keyObj = _rsaprv2asn1obj(keyObjOrHex);
        var keyHex = keyObj.tohex();

        var asn1Obj = _newObject({
            "seq": [
                {"int": 0},
                {"seq": [{"oid": {"name": "rsaEncryption"}},{"null": true}]},
                {"octstr": {"hex": keyHex}}
            ]
        });
        var asn1Hex = asn1Obj.tohex();

        if (passwd === undefined || passwd == null) {
            return hextopem(asn1Hex, "PRIVATE KEY");
        } else {
            var asn1Hex2 = _getEncryptedPKCS8(asn1Hex, passwd);
            return hextopem(asn1Hex2, "ENCRYPTED PRIVATE KEY");
        }
    }

    // x. PEM PKCS#8 plain private key of ECDSA private key object
    if (formatType == "PKCS8PRV" &&
        _ECDSA !== undefined &&
        keyObjOrHex instanceof _ECDSA &&
        keyObjOrHex.isPrivate  == true) {

	var pKeyObj = {
            "seq": [
                {"int": 1},
                {"octstr": {"hex": keyObjOrHex.prvKeyHex}}
            ]
        };
	if (typeof keyObjOrHex.pubKeyHex == "string") {
	    pKeyObj.seq.push({"tag": ['a1', true, {"bitstr": {"hex": "00" + keyObjOrHex.pubKeyHex}}]});
	}
        var keyObj = new _newObject(pKeyObj);
        var keyHex = keyObj.tohex();

        var asn1Obj = _newObject({
            "seq": [
                {"int": 0},
                {"seq": [
                    {"oid": {"name": "ecPublicKey"}},
                    {"oid": {"name": keyObjOrHex.curveName}}
                ]},
                {"octstr": {"hex": keyHex}}
            ]
        });

        var asn1Hex = asn1Obj.tohex();
        if (passwd === undefined || passwd == null) {
            return hextopem(asn1Hex, "PRIVATE KEY");
        } else {
            var asn1Hex2 = _getEncryptedPKCS8(asn1Hex, passwd);
            return hextopem(asn1Hex2, "ENCRYPTED PRIVATE KEY");
        }
    }

    // x. PEM PKCS#8 plain private key of DSA private key object
    if (formatType == "PKCS8PRV" &&
        _DSA !== undefined &&
        keyObjOrHex instanceof _DSA &&
        keyObjOrHex.isPrivate  == true) {

        var keyObj = new _DERInteger({'bigint': keyObjOrHex.x});
        var keyHex = keyObj.tohex();

        var asn1Obj = _newObject({
            "seq": [
                {"int": 0},
                {"seq": [
                    {"oid": {"name": "dsa"}},
                    {"seq": [
                        {"int": {"bigint": keyObjOrHex.p}},
                        {"int": {"bigint": keyObjOrHex.q}},
                        {"int": {"bigint": keyObjOrHex.g}}
                    ]}
                ]},
                {"octstr": {"hex": keyHex}}
            ]
        });

        var asn1Hex = asn1Obj.tohex();
        if (passwd === undefined || passwd == null) {
            return hextopem(asn1Hex, "PRIVATE KEY");
        } else {
            var asn1Hex2 = _getEncryptedPKCS8(asn1Hex, passwd);
            return hextopem(asn1Hex2, "ENCRYPTED PRIVATE KEY");
        }
    }

    throw new Error("unsupported object nor format");
};

// -- PUBLIC METHODS FOR CSR --------------------------------------------------

/**
 * get RSAKey/DSA/ECDSA public key object from PEM formatted PKCS#10 CSR string
 * @name getKeyFromCSRPEM
 * @memberOf KEYUTIL
 * @function
 * @param {String} csrPEM PEM formatted PKCS#10 CSR string
 * @return {Object} RSAKey/DSA/ECDSA public key object
 * @since keyutil 1.0.5
 */
KEYUTIL.getKeyFromCSRPEM = function(csrPEM) {
    var csrHex = pemtohex(csrPEM, "CERTIFICATE REQUEST");
    var key = KEYUTIL.getKeyFromCSRHex(csrHex);
    return key;
};

/**
 * get RSAKey/DSA/ECDSA public key object from hexadecimal string of PKCS#10 CSR
 * @name getKeyFromCSRHex
 * @memberOf KEYUTIL
 * @function
 * @param {String} csrHex hexadecimal string of PKCS#10 CSR
 * @return {Object} RSAKey/DSA/ECDSA public key object
 * @since keyutil 1.0.5
 */
KEYUTIL.getKeyFromCSRHex = function(csrHex) {
    var info = KEYUTIL.parseCSRHex(csrHex);
    var key = KEYUTIL.getKey(info.p8pubkeyhex, null, "pkcs8pub");
    return key;
};

/**
 * parse hexadecimal string of PKCS#10 CSR (certificate signing request)
 * @name parseCSRHex
 * @memberOf KEYUTIL
 * @function
 * @param {String} csrHex hexadecimal string of PKCS#10 CSR
 * @return {Array} associative array of parsed CSR
 * @since keyutil 1.0.5
 * @description
 * Resulted associative array has following properties:
 * <ul>
 * <li>p8pubkeyhex - hexadecimal string of subject public key in PKCS#8</li>
 * </ul>
 */
KEYUTIL.parseCSRHex = function(csrHex) {
    var _ASN1HEX = ASN1HEX;
    var _getChildIdx = _ASN1HEX.getChildIdx;
    var _getTLV = _ASN1HEX.getTLV;
    var result = {};
    var h = csrHex;

    // 1. sequence
    if (h.substr(0, 2) != "30")
        throw new Error("malformed CSR(code:001)"); // not sequence

    var a1 = _getChildIdx(h, 0);
    if (a1.length < 1)
        throw new Error("malformed CSR(code:002)"); // short length

    // 2. 2nd sequence
    if (h.substr(a1[0], 2) != "30")
        throw new Error("malformed CSR(code:003)"); // not sequence

    var a2 = _getChildIdx(h, a1[0]);
    if (a2.length < 3)
        throw new Error("malformed CSR(code:004)"); // 2nd seq short elem

    result.p8pubkeyhex = _getTLV(h, a2[2]);

    return result;
};

// -- OTHER STATIC PUBLIC METHODS  --------------------------------------------

/**
 * get key ID by public key object for subject or authority key identifier
 * @name getKeyID
 * @memberof KEYUTIL
 * @function
 * @static
 * @param {Object} obj RSAKey/KJUR.crypto.ECDSA,DSA public key object or public key PEM string
 * @return hexadecimal string of public key identifier
 * @since keyutil 1.2.2 jsrsasign 5.0.16
 * @description
 * This static method generates a key identifier from a public key
 * by the method described in 
 * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.2"
 * target="_blank">RFC 5280 4.2.1.2. Subject Key Identifier (1)</a>.
 * @example
 * pubkeyobj = KEYUTIL.getKey(...);
 * KEYTUTIL.getKey(pubkeyobj) &rarr; "a612..."
 */
KEYUTIL.getKeyID = function(obj) {
    var _KEYUTIL = KEYUTIL;
    var _ASN1HEX = ASN1HEX;

    if (typeof obj  === "string" && obj.indexOf("BEGIN ") != -1) {
	obj = _KEYUTIL.getKey(obj);
    }

    var p8hex = pemtohex(_KEYUTIL.getPEM(obj));
    var idx = _ASN1HEX.getIdxbyList(p8hex, 0, [1]); // BITSTRING
    var hV = _ASN1HEX.getV(p8hex, idx).substring(2); // value without unused bit
    return KJUR.crypto.Util.hashHex(hV, "sha1");
}

/**
 * convert from certificate, public/private key object to RFC 7517 JSON Web Key(JWK)<br/>
 * @name getJWK
 * @memberOf KEYUTIL
 * @function
 * @static
 * @param {Object or string} keyinfo public/private key object, PEM key or PEM certificate
 * @param {boolean} nokid set true if you don't need kid (OPTION, DEFAULT=undefined)
 * @param {boolean} nox5c set true if you don't need x5c of certificate (OPTION, DEFAULT=undefined)
 * @param {boolean} nox5t set true if you don't need x5t of certificate (OPTION, DEFAULT=undefined)
 * @param {boolean} nox5t2 set true if you don't need x5c#S256 of certificate (OPTION, DEFAULT=undefined)
 * @return {Object} JWK object
 * @since keyutil 1.2.5 jsrsasign 10.5.1
 * @see RSAKey
 * @see KJUR.crypto.ECDSA
 * @see KJUR.crypto.DSA
 *
 * @description
 * This static method provides 
 * <a href="https://datatracker.ietf.org/doc/html/rfc7517">
 * RFC 7517 JSON Web Key(JWK) JSON</a>
 * object from following argument types:
 * <ul>
 * <li>
 * <b>JWK private key</b>
 * <ul>
 * <li>RSAKey or KJUR.crypto.{ECDSA,DSA} private key object</li>
 * <li>PKCS#5 or PKCS#8 plain PEM private key</li>
 * </ul>
 * </li>
 * <li>
 * <b>JWK public key</b>
 * <ul>
 * <li>RSAKey or KJUR.crypto.{ECDSA,DSA} public key object</li>
 * <li>PKCS#5 or PKCS#8 PEM public key</li>
 * <li>X509 certificate object</li>
 * <li>PEM certificate</li>
 * </ul>
 * </li>
 * </ul>
 * 
 * @example
 * kp1 = KEYUTIL.generateKeypair("EC", "P-256");
 * jwkPrv1 = KEYUTIL.getJWK(kp1.prvKeyObj);
 * jwkPub1 = KEYUTIL.getJWK(kp1.pubKeyObj);
 *
 * kp2 = KEYUTIL.generateKeypair("RSA", 2048);
 * jwkPrv2 = KEYUTIL.getJWK(kp2.prvKeyObj);
 * jwkPub2 = KEYUTIL.getJWK(kp2.pubKeyObj);
 *
 * // from PEM certificate
 * KEYUTIL.getJWK("-----BEGIN CERTIFICATE...") &rarr;
 * {
 *   kty: "EC", crv: "P-521", x: "...", y: "...",
 *   x5c: ["MI..."],
 *   x5t: "...",
 *   "x5t#S256": "...",
 *   kid: "..."
 * }
 *
 * // from X509 object
 * x509obj = new X509("-----BEGIN CERTIFICATE...");
 * KEYUTIL.getJWK(x509obj) &rarr;
 * {
 *   kty: "EC", crv: "P-521", x: "...", y: "...",
 *   ...
 * }
 *
 * // from PEM certificate without kid, x5t and x5t#S256 (i.e. only x5c)
 * KEYUTIL.getJWK("-----BEGIN CERTIFICATE...", true, false, true, true) &rarr;
 * {
 *   kty: "EC", crv: "P-521", x: "...", y: "...",
 *   x5c: ["MI..."]
 * }
 */
KEYUTIL.getJWK = function(keyinfo, nokid, nox5c, nox5t, nox5t2) {
    var keyObj;
    var jwk = {};
    var hCert;
    var _hashHex = KJUR.crypto.Util.hashHex;

    if (typeof keyinfo == "string") {
	keyObj = KEYUTIL.getKey(keyinfo);
	if (keyinfo.indexOf("CERTIFICATE") != -1) {
	    hCert = pemtohex(keyinfo)
	}
    } else if (typeof keyinfo == "object") {
	if (keyinfo instanceof X509) {
	    keyObj = keyinfo.getPublicKey();
	    hCert = keyinfo.hex;
	} else {
	    keyObj = keyinfo;
	}
    } else {
	throw new Error("unsupported keyinfo type");
    }

    if (keyObj instanceof RSAKey && keyObj.isPrivate) {
	jwk.kty = "RSA";
	jwk.n = hextob64u(keyObj.n.toString(16));
	jwk.e = hextob64u(keyObj.e.toString(16));
	jwk.d = hextob64u(keyObj.d.toString(16));
	jwk.p = hextob64u(keyObj.p.toString(16));
	jwk.q = hextob64u(keyObj.q.toString(16));
	jwk.dp = hextob64u(keyObj.dmp1.toString(16));
	jwk.dq = hextob64u(keyObj.dmq1.toString(16));
	jwk.qi = hextob64u(keyObj.coeff.toString(16));
    } else if (keyObj instanceof RSAKey && keyObj.isPublic) {
	jwk.kty = "RSA";
	jwk.n = hextob64u(keyObj.n.toString(16));
	jwk.e = hextob64u(keyObj.e.toString(16));
    } else if (keyObj instanceof KJUR.crypto.ECDSA && keyObj.isPrivate) {
	var name = keyObj.getShortNISTPCurveName();
	if (name !== "P-256" && name !== "P-384" && name !== "P-521")
	    throw new Error("unsupported curve name for JWT: " + name);
	var xy = keyObj.getPublicKeyXYHex();
	jwk.kty = "EC";
	jwk.crv =  name;
	jwk.x = hextob64u(xy.x);
	jwk.y = hextob64u(xy.y);
	jwk.d = hextob64u(keyObj.prvKeyHex);
    } else if (keyObj instanceof KJUR.crypto.ECDSA && keyObj.isPublic) {
	var name = keyObj.getShortNISTPCurveName();
	if (name !== "P-256" && name !== "P-384" && name !== "P-521")
	    throw new Error("unsupported curve name for JWT: " + name);
	var xy = keyObj.getPublicKeyXYHex();
	jwk.kty = "EC";
	jwk.crv =  name;
	jwk.x = hextob64u(xy.x);
	jwk.y = hextob64u(xy.y);
    }
    if (jwk.kty == undefined) throw new Error("unsupported keyinfo");

    if ((! keyObj.isPrivate) && nokid != true) {
	jwk.kid = KJUR.jws.JWS.getJWKthumbprint(jwk);
    }

    if (hCert != undefined && nox5c != true) {
	jwk.x5c = [hex2b64(hCert)];
    }

    if (hCert != undefined && nox5t != true) {
	jwk.x5t = b64tob64u(hex2b64(_hashHex(hCert, "sha1")));
    }

    if (hCert != undefined && nox5t2 != true) {
	jwk["x5t#S256"] = b64tob64u(hex2b64(_hashHex(hCert, "sha256")));
    }

    return jwk;
};

/**
 * convert from RSAKey/KJUR.crypto.ECDSA public/private key object to RFC 7517 JSON Web Key(JWK) (DEPRECATED)<br/>
 * @name getJWKFromKey
 * @memberOf KEYUTIL
 * @function
 * @static
 * @param {Object} RSAKey/KJUR.crypto.ECDSA public/private key object
 * @return {Object} JWK object
 * @since keyutil 1.0.13 jsrsasign 5.0.14
 * @deprecated since jsrsasign 10.5.1 keyutil 1.2.5 please use getJWK method
 * @see KEYUTIL.getJWK
 *
 * @description
 * This static method convert from RSAKey/KJUR.crypto.ECDSA public/private key object 
 * to RFC 7517 JSON Web Key(JWK)
 * 
 * @example
 * kp1 = KEYUTIL.generateKeypair("EC", "P-256");
 * jwkPrv1 = KEYUTIL.getJWKFromKey(kp1.prvKeyObj);
 * jwkPub1 = KEYUTIL.getJWKFromKey(kp1.pubKeyObj);
 *
 * kp2 = KEYUTIL.generateKeypair("RSA", 2048);
 * jwkPrv2 = KEYUTIL.getJWKFromKey(kp2.prvKeyObj);
 * jwkPub2 = KEYUTIL.getJWKFromKey(kp2.pubKeyObj);
 *
 * // if you need RFC 7638 JWK thumprint as kid do like this:
 * jwkPub2.kid = KJUR.jws.JWS.getJWKthumbprint(jwkPub2);
 */
KEYUTIL.getJWKFromKey = function(keyObj) {
    return KEYUTIL.getJWK(keyObj, true, true, true, true);
}

/* rsapem-1.3.1.js (c) 2012-2020 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * rsapem.js - Cryptographic Algorithm Provider class
 *
 * Copyright (c) 2013-2020 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name rsapem-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 8.0.21 rsapem 1.3.1 (2020-Jul-24)
 * @since jsrsasign 1.0
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * static method to get array of field positions from hexadecimal PKCS#5 RSA private key.<br/>
 * @name getPosArrayOfChildrenFromHex
 * @memberOf RSAKey
 * @function
 * @param {String} sPEMPrivateKey PEM PKCS#1/5 s private key string
 * @return {Array} array of field positions
 * @example
 * RSAKey.getPosArrayOfChildrenFromHex("3082...") &rarr; [8, 32, ...]
 */
RSAKey.getPosArrayOfChildrenFromHex = function(hPrivateKey) {
    return ASN1HEX.getChildIdx(hPrivateKey, 0);
};

/**
 * static method to get array of hex field values from hexadecimal PKCS#5 RSA private key.<br/>
 * @name getHexValueArrayOfChildrenFromHex
 * @memberOf RSAKey
 * @function
 * @param {String} sPEMPrivateKey PEM PKCS#1/5 s private key string
 * @return {Array} array of field hex value
 * @example
 * RSAKey.getHexValueArrayOfChildrenFromHex("3082...") &rarr; ["00", "3b42...", ...]
 */
RSAKey.getHexValueArrayOfChildrenFromHex = function(hPrivateKey) {
    var _ASN1HEX = ASN1HEX;
    var _getV = _ASN1HEX.getV;
    var a = RSAKey.getPosArrayOfChildrenFromHex(hPrivateKey);
    var h_v =  _getV(hPrivateKey, a[0]);
    var h_n =  _getV(hPrivateKey, a[1]);
    var h_e =  _getV(hPrivateKey, a[2]);
    var h_d =  _getV(hPrivateKey, a[3]);
    var h_p =  _getV(hPrivateKey, a[4]);
    var h_q =  _getV(hPrivateKey, a[5]);
    var h_dp = _getV(hPrivateKey, a[6]);
    var h_dq = _getV(hPrivateKey, a[7]);
    var h_co = _getV(hPrivateKey, a[8]);
    var a = new Array();
    a.push(h_v, h_n, h_e, h_d, h_p, h_q, h_dp, h_dq, h_co);
    return a;
};

/**
 * read PKCS#1 private key from a string<br/>
 * @name readPrivateKeyFromPEMString
 * @memberOf RSAKey#
 * @function
 * @param {String} keyPEM string of PKCS#1 private key.
 */
RSAKey.prototype.readPrivateKeyFromPEMString = function(keyPEM) {
    var keyHex = pemtohex(keyPEM);
    var a = RSAKey.getHexValueArrayOfChildrenFromHex(keyHex);
    this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
};

/**
 * read an ASN.1 hexadecimal string of PKCS#1/5 plain RSA private key<br/>
 * @name readPKCS5PrvKeyHex
 * @memberOf RSAKey#
 * @function
 * @param {String} h hexadecimal string of PKCS#1/5 plain RSA private key
 * @since jsrsasign 7.1.0 rsapem 1.2.0
 * @see {@link RSAKey.readPrivateKeyFromASN1HexString} former method
 */
RSAKey.prototype.readPKCS5PrvKeyHex = function(h) {
    var a = RSAKey.getHexValueArrayOfChildrenFromHex(h);
    this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
};

/**
 * read an ASN.1 hexadecimal string of PKCS#8 plain RSA private key<br/>
 * @name readPKCS8PrvKeyHex
 * @memberOf RSAKey#
 * @function
 * @param {String} h hexadecimal string of PKCS#8 plain RSA private key
 * @since jsrsasign 7.1.0 rsapem 1.2.0
 */
RSAKey.prototype.readPKCS8PrvKeyHex = function(h) {
    var hN, hE, hD, hP, hQ, hDP, hDQ, hCO;
    var _ASN1HEX = ASN1HEX;
    var _getVbyListEx = _ASN1HEX.getVbyListEx;

    if (_ASN1HEX.isASN1HEX(h) === false)
	throw new Error("not ASN.1 hex string");

    try {
	hN  = _getVbyListEx(h, 0, [2, 0, 1], "02");
	hE  = _getVbyListEx(h, 0, [2, 0, 2], "02");
	hD  = _getVbyListEx(h, 0, [2, 0, 3], "02");
	hP  = _getVbyListEx(h, 0, [2, 0, 4], "02");
	hQ  = _getVbyListEx(h, 0, [2, 0, 5], "02");
	hDP = _getVbyListEx(h, 0, [2, 0, 6], "02");
	hDQ = _getVbyListEx(h, 0, [2, 0, 7], "02");
	hCO = _getVbyListEx(h, 0, [2, 0, 8], "02");
    } catch(ex) {
	throw new Error("malformed PKCS#8 plain RSA private key");
    }

    this.setPrivateEx(hN, hE, hD, hP, hQ, hDP, hDQ, hCO);
};

/**
 * read an ASN.1 hexadecimal string of PKCS#5 RSA public key<br/>
 * @name readPKCS5PubKeyHex
 * @memberOf RSAKey#
 * @function
 * @param {String} h hexadecimal string of PKCS#5 public key
 * @since jsrsasign 7.1.0 rsapem 1.2.0
 */
RSAKey.prototype.readPKCS5PubKeyHex = function(h) {
    var _ASN1HEX = ASN1HEX;
    var _getV = _ASN1HEX.getV;

    if (_ASN1HEX.isASN1HEX(h) === false)
	throw new Error("keyHex is not ASN.1 hex string");
    var aIdx = _ASN1HEX.getChildIdx(h, 0);
    if (aIdx.length !== 2 ||
	h.substr(aIdx[0], 2) !== "02" ||
	h.substr(aIdx[1], 2) !== "02")
	throw new Error("wrong hex for PKCS#5 public key");
    var hN = _getV(h, aIdx[0]);
    var hE = _getV(h, aIdx[1]);
    this.setPublic(hN, hE);
};

/**
 * read an ASN.1 hexadecimal string of PKCS#8 RSA public key<br/>
 * @name readPKCS8PubKeyHex
 * @memberOf RSAKey#
 * @function
 * @param {String} h hexadecimal string of PKCS#8 public key
 * @since jsrsasign 7.1.0 rsapem 1.2.0
 */
RSAKey.prototype.readPKCS8PubKeyHex = function(h) {
    var _ASN1HEX = ASN1HEX;
    if (_ASN1HEX.isASN1HEX(h) === false)
	throw new Error("not ASN.1 hex string");

    // 06092a864886f70d010101: OBJECT IDENTIFIER rsaEncryption (1 2 840 113549 1 1 1)
    if (_ASN1HEX.getTLVbyListEx(h, 0, [0, 0]) !== "06092a864886f70d010101")
	throw new Error("not PKCS8 RSA public key");

    var p5hex = _ASN1HEX.getTLVbyListEx(h, 0, [1, 0]);
    this.readPKCS5PubKeyHex(p5hex);
};

/**
 * read an ASN.1 hexadecimal string of X.509 RSA public key certificate<br/>
 * @name readCertPubKeyHex
 * @memberOf RSAKey#
 * @function
 * @param {String} h hexadecimal string of X.509 RSA public key certificate
 * @param {Integer} nthPKI nth index of publicKeyInfo. (DEFAULT: 6 for X509v3)
 * @since jsrsasign 7.1.0 rsapem 1.2.0
 */
RSAKey.prototype.readCertPubKeyHex = function(h, nthPKI) {
    var x, hPub;
    x = new X509();
    x.readCertHex(h);
    hPub = x.getPublicKeyHex();
    this.readPKCS8PubKeyHex(hPub);
};

/* rsasign-1.3.4.js (c) 2010-2021 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * rsa-sign.js - adding signing functions to RSAKey class.
 *
 * Copyright (c) 2010-2021 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license/
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name rsasign-1.2.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.2.0 rsasign 1.3.4 (2021-Apr-13)
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

var _RE_HEXDECONLY = new RegExp("[^0-9a-f]", "gi");

// ========================================================================
// Signature Generation
// ========================================================================

function _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {
    var hashFunc = function(s) { return KJUR.crypto.Util.hashString(s, hashAlg); };
    var sHashHex = hashFunc(s);

    return KJUR.crypto.Util.getPaddedDigestInfoHex(sHashHex, hashAlg, keySize);
}

function _zeroPaddingOfSignature(hex, bitLength) {
    var s = "";
    var nZero = bitLength / 4 - hex.length;
    for (var i = 0; i < nZero; i++) {
	s = s + "0";
    }
    return s + hex;
}

/**
 * sign for a message string with RSA private key.<br/>
 * @name sign
 * @memberOf RSAKey
 * @function
 * @param {String} s message string to be signed.
 * @param {String} hashAlg hash algorithm name for signing.<br/>
 * @return returns hexadecimal string of signature value.
 */
RSAKey.prototype.sign = function(s, hashAlg) {
    var hashFunc = function(s) { return KJUR.crypto.Util.hashString(s, hashAlg); };
    var sHashHex = hashFunc(s);

    return this.signWithMessageHash(sHashHex, hashAlg);
};

/**
 * sign hash value of message to be signed with RSA private key.<br/>
 * @name signWithMessageHash
 * @memberOf RSAKey
 * @function
 * @param {String} sHashHex hexadecimal string of hash value of message to be signed.
 * @param {String} hashAlg hash algorithm name for signing.<br/>
 * @return returns hexadecimal string of signature value.
 * @since rsasign 1.2.6
 */
RSAKey.prototype.signWithMessageHash = function(sHashHex, hashAlg) {
    var hPM = KJUR.crypto.Util.getPaddedDigestInfoHex(sHashHex, hashAlg, this.n.bitLength());
    var biPaddedMessage = parseBigInt(hPM, 16);
    var biSign = this.doPrivate(biPaddedMessage);
    var hexSign = biSign.toString(16);
    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());
}

// PKCS#1 (PSS) mask generation function
function pss_mgf1_str(seed, len, hash) {
    var mask = '', i = 0;

    while (mask.length < len) {
        mask += hextorstr(hash(rstrtohex(seed + String.fromCharCode.apply(String, [
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff]))));
        i += 1;
    }

    return mask;
}

/**
 * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>
 * @name signPSS
 * @memberOf RSAKey
 * @function
 * @param {String} s message string to be signed.
 * @param {String} hashAlg hash algorithm name for signing.
 * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).
 *        There are two special values:
 *        <ul>
 *        <li>-1: sets the salt length to the digest length</li>
 *        <li>-2: sets the salt length to maximum permissible value
 *           (i.e. keybytelen - hashbytelen - 2)</li>
 *        </ul>
 *        DEFAULT is -1. (NOTE: OpenSSL's default is -2.)
 * @return returns hexadecimal string of signature value.
 */
RSAKey.prototype.signPSS = function(s, hashAlg, sLen) {
    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); } 
    var hHash = hashFunc(rstrtohex(s));

    if (sLen === undefined) sLen = -1;
    return this.signWithMessageHashPSS(hHash, hashAlg, sLen);
};

/**
 * sign hash value of message with RSA private key by PKCS#1 PSS signing.<br/>
 * @name signWithMessageHashPSS
 * @memberOf RSAKey
 * @function
 * @param {String} hHash hexadecimal hash value of message to be signed.
 * @param {String} hashAlg hash algorithm name for signing.
 * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).
 *        There are two special values:
 *        <ul>
 *        <li>-1: sets the salt length to the digest length</li>
 *        <li>-2: sets the salt length to maximum permissible value
 *           (i.e. keybytelen - hashbytelen - 2)</li>
 *        </ul>
 *        DEFAULT is -1. (NOTE: OpenSSL's default is -2.)
 * @return returns hexadecimal string of signature value.
 * @since rsasign 1.2.6
 */
RSAKey.prototype.signWithMessageHashPSS = function(hHash, hashAlg, sLen) {
    var mHash = hextorstr(hHash);
    var hLen = mHash.length;
    var emBits = this.n.bitLength() - 1;
    var emLen = Math.ceil(emBits / 8);
    var i;
    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); } 

    if (sLen === -1 || sLen === undefined) {
        sLen = hLen; // same as hash length
    } else if (sLen === -2) {
        sLen = emLen - hLen - 2; // maximum
    } else if (sLen < -2) {
        throw new Error("invalid salt length");
    }

    if (emLen < (hLen + sLen + 2)) {
        throw new Error("data too long");
    }

    var salt = '';

    if (sLen > 0) {
        salt = new Array(sLen);
        new SecureRandom().nextBytes(salt);
        salt = String.fromCharCode.apply(String, salt);
    }

    var H = hextorstr(hashFunc(rstrtohex('\x00\x00\x00\x00\x00\x00\x00\x00' + mHash + salt)));
    var PS = [];

    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {
        PS[i] = 0x00;
    }

    var DB = String.fromCharCode.apply(String, PS) + '\x01' + salt;
    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);
    var maskedDB = [];

    for (i = 0; i < DB.length; i += 1) {
        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;
    maskedDB[0] &= ~mask;

    for (i = 0; i < hLen; i++) {
        maskedDB.push(H.charCodeAt(i));
    }

    maskedDB.push(0xbc);

    return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(maskedDB)).toString(16),
				   this.n.bitLength());
}

// ========================================================================
// Signature Verification
// ========================================================================

function _rsasign_getDecryptSignatureBI(biSig, hN, hE) {
    var rsa = new RSAKey();
    rsa.setPublic(hN, hE);
    var biDecryptedSig = rsa.doPublic(biSig);
    return biDecryptedSig;
}

function _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {
    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);
    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');
    return hDigestInfo;
}

function _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {
    for (var algName in KJUR.crypto.Util.DIGESTINFOHEAD) {
	var head = KJUR.crypto.Util.DIGESTINFOHEAD[algName];
	var len = head.length;
	if (hDigestInfo.substring(0, len) == head) {
	    var a = [algName, hDigestInfo.substring(len)];
	    return a;
	}
    }
    return [];
}

/**
 * verifies a sigature for a message string with RSA public key.<br/>
 * @name verify
 * @memberOf RSAKey#
 * @function
 * @param {String} sMsg raw message string to be verified.
 * @param {String} hSig hexadecimal string of siganture.<br/>
 *                 non-hexadecimal charactors including new lines will be ignored.
 * @return returns true if valid, otherwise false
 *
 * @description
 * This method verifies RSA signature with raw message string and
 * hexadecimal signature value.
 *
 * @example
 * pubkey = new RSAKey();
 * pubkey.setPublic("1abd...", "10001");
 * pubkey.verify("hello world", "3da1...") &rarr; true or false
 */
RSAKey.prototype.verify = function(sMsg, hSig) {
    hSig = hSig.toLowerCase();
    if (hSig.match(/^[0-9a-f]+$/) == null) return false;
    var biSig = parseBigInt(hSig, 16);
    var keySize = this.n.bitLength();
    if (biSig.bitLength() > keySize) return false;
    var biDecryptedSig = this.doPublic(biSig);
    var hDecryptedSig = biDecryptedSig.toString(16);
    if (hDecryptedSig.length + 3 != keySize / 4) return false;
    var hDigestInfo = hDecryptedSig.replace(/^1f+00/, '');
    var digestInfoAry = 
	_rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);
  
    if (digestInfoAry.length == 0) return false;
    var algName = digestInfoAry[0];
    var diHashValue = digestInfoAry[1];
    var ff = function(s) { return KJUR.crypto.Util.hashString(s, algName); };
    var msgHashValue = ff(sMsg);
    return (diHashValue == msgHashValue);
};

/**
 * verifies a sigature for a message string with RSA public key.<br/>
 * @name verifyWithMessageHash
 * @memberOf RSAKey
 * @function
 * @param {String} sHashHex hexadecimal hash value of message to be verified.
 * @param {String} hSig hexadecimal string of siganture.<br/>
 *                 non-hexadecimal charactors including new lines will be ignored.
 * @return returns 1 if valid, otherwise 0
 * @since rsasign 1.2.6
 */
RSAKey.prototype.verifyWithMessageHash = function(sHashHex, hSig) {
    if (hSig.length != Math.ceil(this.n.bitLength() / 4.0)) {
	return false;
    }

    var biSig = parseBigInt(hSig, 16);

    if (biSig.bitLength() > this.n.bitLength()) return 0;

    var biDecryptedSig = this.doPublic(biSig);
    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');
    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);
  
    if (digestInfoAry.length == 0) return false;
    var algName = digestInfoAry[0];
    var diHashValue = digestInfoAry[1];
    return (diHashValue == sHashHex);
};

/**
 * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>
 * @name verifyPSS
 * @memberOf RSAKey
 * @function
 * @param {String} sMsg message string to be verified.
 * @param {String} hSig hexadecimal string of signature value
 * @param {String} hashAlg hash algorithm name
 * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).
 *        There are two special values:
 *        <ul>
 *        <li>-1: sets the salt length to the digest length</li>
 *        <li>-2: sets the salt length to maximum permissible value
 *           (i.e. keybytelen - hashbytelen - 2)</li>
 *        </ul>
 *        DEFAULT is -1. (NOTE: OpenSSL's default is -2.)
 * @return returns true if valid, otherwise false
 */
RSAKey.prototype.verifyPSS = function(sMsg, hSig, hashAlg, sLen) {
    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); };
    var hHash = hashFunc(rstrtohex(sMsg));

    if (sLen === undefined) sLen = -1;
    return this.verifyWithMessageHashPSS(hHash, hSig, hashAlg, sLen);
}

/**
 * verifies a sigature for a hash value of message string with RSA public key by PKCS#1 PSS sign.<br/>
 * @name verifyWithMessageHashPSS
 * @memberOf RSAKey
 * @function
 * @param {String} hHash hexadecimal hash value of message string to be verified.
 * @param {String} hSig hexadecimal string of signature value
 * @param {String} hashAlg hash algorithm name
 * @param {Integer} sLen salt byte length from 0 to (keybytelen - hashbytelen - 2).
 *        There are two special values:
 *        <ul>
 *        <li>-1: sets the salt length to the digest length</li>
 *        <li>-2: sets the salt length to maximum permissible value
 *           (i.e. keybytelen - hashbytelen - 2)</li>
 *        </ul>
 *        DEFAULT is -1 (NOTE: OpenSSL's default is -2.)
 * @return returns true if valid, otherwise false
 * @since rsasign 1.2.6
 */
RSAKey.prototype.verifyWithMessageHashPSS = function(hHash, hSig, hashAlg, sLen) {
    if (hSig.length != Math.ceil(this.n.bitLength() / 4.0)) {
	return false;
    }

    var biSig = new BigInteger(hSig, 16);

    var hashFunc = function(sHex) { return KJUR.crypto.Util.hashHex(sHex, hashAlg); };
    var mHash = hextorstr(hHash);
    var hLen = mHash.length;
    var emBits = this.n.bitLength() - 1;
    var emLen = Math.ceil(emBits / 8);
    var i;

    if (sLen === -1 || sLen === undefined) {
        sLen = hLen; // same as hash length
    } else if (sLen === -2) {
        sLen = emLen - hLen - 2; // recover
    } else if (sLen < -2) {
        throw new Error("invalid salt length");
    }

    if (emLen < (hLen + sLen + 2)) {
        throw new Error("data too long");
    }

    var em = this.doPublic(biSig).toByteArray();

    for (i = 0; i < em.length; i += 1) {
        em[i] &= 0xff;
    }

    while (em.length < emLen) {
        em.unshift(0);
    }

    if (em[emLen -1] !== 0xbc) {
        throw new Error("encoded message does not end in 0xbc");
    }

    em = String.fromCharCode.apply(String, em);

    var maskedDB = em.substr(0, emLen - hLen - 1);
    var H = em.substr(maskedDB.length, hLen);

    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;

    if ((maskedDB.charCodeAt(0) & mask) !== 0) {
        throw new Error("bits beyond keysize not zero");
    }

    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);
    var DB = [];

    for (i = 0; i < maskedDB.length; i += 1) {
        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    DB[0] &= ~mask;

    var checkLen = emLen - hLen - sLen - 2;

    for (i = 0; i < checkLen; i += 1) {
        if (DB[i] !== 0x00) {
            throw new Error("leftmost octets not zero");
        }
    }

    if (DB[checkLen] !== 0x01) {
        throw new Error("0x01 marker not found");
    }

    return H === hextorstr(hashFunc(rstrtohex('\x00\x00\x00\x00\x00\x00\x00\x00' + mHash +
				     String.fromCharCode.apply(String, DB.slice(-sLen)))));
}

RSAKey.SALT_LEN_HLEN = -1;
RSAKey.SALT_LEN_MAX = -2;
RSAKey.SALT_LEN_RECOVER = -2;

/**
 * @name RSAKey
 * @class key of RSA public key algorithm
 * @description Tom Wu's RSA Key class and extension
 */

/* x509-2.1.6.js (c) 2012-2023 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * x509.js - X509 class to read subject public key from certificate.
 *
 * Copyright (c) 2010-2023 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name x509-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.8.6 x509 2.1.6 (2023-Apr-26)
 * @since jsrsasign 1.x.x
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * hexadecimal X.509 certificate ASN.1 parser class.<br/>
 * @class hexadecimal X.509 certificate ASN.1 parser class
 * @property {String} hex hexacedimal string for X.509 certificate.
 * @property {Number} version format version (1: X509v1, 3: X509v3, otherwise: unknown) since jsrsasign 7.1.4
 * @property {Array} aExtInfo (DEPRECATED) array of parameters for extensions
 * @author Kenji Urushima
 * @version 1.0.1 (08 May 2012)
 * @see <a href="https://kjur.github.io/jsrsasigns/">'jsrsasign'(RSA Sign JavaScript Library) home page https://kjur.github.io/jsrsasign/</a>
 * @description
 * X509 class provides following functionality:
 * <ul>
 * <li>parse X.509 certificate ASN.1 structure</li>
 * <li>get basic fields, extensions, signature algorithms and signature values</li>
 * <li>read PEM certificate</li>
 * </ul>
 *
 * <ul>
 * <li><b>TO GET FIELDS</b>
 *   <ul>
 *   <li>serial - {@link X509#getSerialNumberHex}</li>
 *   <li>signature algorithm field - {@link X509#getSignatureAlgorithmField}</li>
 *   <li>issuer - {@link X509#getIssuerHex}</li>
 *   <li>issuer - {@link X509#getIssuerString}</li>
 *   <li>notBefore - {@link X509#getNotBefore}</li>
 *   <li>notAfter - {@link X509#getNotAfter}</li>
 *   <li>subject - {@link X509#getSubjectHex}</li>
 *   <li>subject - {@link X509#getSubjectString}</li>
 *   <li>subjectPublicKeyInfo - {@link X509#getPublicKey}</li>
 *   <li>subjectPublicKeyInfo - {@link X509#getPublicKeyHex}</li>
 *   <li>subjectPublicKeyInfo - {@link X509#getPublicKeyIdx}</li>
 *   <li>subjectPublicKeyInfo - {@link X509.getPublicKeyFromCertPEM}</li>
 *   <li>subjectPublicKeyInfo - {@link X509.getPublicKeyFromCertHex}</li>
 *   <li>subjectPublicKeyInfo - {@link X509#getPublicKeyContentIdx}</li>
 *   <li>signature algorithm - {@link X509#getSignatureAlgorithmName}</li>
 *   <li>signature value - {@link X509#getSignatureValueHex}</li>
 *   </ul>
 * </li>
 * <li><b>X509 METHODS TO GET EXTENSIONS</b>
 *   <ul>
 *   <li>authorityKeyIdentifier - {@link X509#getExtAuthorityKeyIdentifier}</li>
 *   <li>subjectKeyIdentifier - {@link X509#getExtSubjectKeyIdentifier}</li>
 *   <li>keyUsage - {@link X509#getExtKeyUsage}</li>
 *   <li>keyUsage - {@link X509#getExtKeyUsageBin}</li>
 *   <li>keyUsage - {@link X509#getExtKeyUsageString}</li>
 *   <li>certificatePolicies - {@link X509#getExtCertificatePolicies}</li>
 *   <li>policyMappings - {@link X509#getExtPolicyMappings}</li>
 *   <li>policyConstraints - {@link X509#getExtPolicyConstraints}</li>
 *   <li>inhibitAnyPolicy - {@link X509#getExtInhibitAnyPolicy}</li>
 *   <li>subjectAltName - {@link X509#getExtSubjectAltName}</li>
 *   <li>subjectAltName2 - {@link X509#getExtSubjectAltName2} (DEPRECATED)</li>
 *   <li>issuerAltName - {@link X509#getExtIssuerAltName}</li>
 *   <li>basicConstraints - {@link X509#getExtBasicConstraints}</li>
 *   <li>nameConstraints - {@link X509#getExtNameConstraints}</li>
 *   <li>extKeyUsage - {@link X509#getExtExtKeyUsage}</li>
 *   <li>extKeyUsage - {@link X509#getExtExtKeyUsageName} (DEPRECATED)</li>
 *   <li>cRLDistributionPoints - {@link X509#getExtCRLDistributionPoints}</li>
 *   <li>cRLDistributionPoints - {@link X509#getExtCRLDistributionPointsURI} (DEPRECATED)</li>
 *   <li>authorityInfoAccess - {@link X509#getExtAuthorityInfoAccess}</li>
 *   <li>authorityInfoAccess - {@link X509#getExtAIAInfo} (DEPRECATED)</li>
 *   <li>cRLNumber - {@link X509#getExtCRLNumber}</li>
 *   <li>cRLReason - {@link X509#getExtCRLReason}</li>
 *   <li>ocspNonce - {@link X509#getExtOcspNonce}</li>
 *   <li>ocspNoCheck - {@link X509#getExtOcspNoCheck}</li>
 *   <li>adobeTimeStamp - {@link X509#getExtAdobeTimeStamp}</li>
 *   </ul>
 * </li>
 * <li><b>UTILITIES</b>
 *   <ul>
 *   <li>reading PEM X.509 certificate - {@link X509#readCertPEM}</li>
 *   <li>reading hexadecimal string of X.509 certificate - {@link X509#readCertHex}</li>
 *   <li>get all certificate information - {@link X509#getInfo}</li>
 *   <li>get specified extension information - {@link X509#getExtInfo}</li>
 *   <li>verify signature value - {@link X509#verifySignature}</li>
 *   <li>utility for extensions - {@link X509#getCriticalExtV}</li>
 *   </ul>
 * </li>
 * </ul>
 */
function X509(params) {
    var _ASN1HEX = ASN1HEX,
	_getChildIdx = _ASN1HEX.getChildIdx,
	_getV = _ASN1HEX.getV,
	_dump = _ASN1HEX.dump,
	_ASN1HEX_parse = _ASN1HEX.parse,
	_getTLV = _ASN1HEX.getTLV,
	_getVbyList = _ASN1HEX.getVbyList,
	_getVbyListEx = _ASN1HEX.getVbyListEx,
	_getTLVbyList = _ASN1HEX.getTLVbyList,
	_getTLVbyListEx = _ASN1HEX.getTLVbyListEx,
	_getIdxbyList = _ASN1HEX.getIdxbyList,
	_getIdxbyListEx = _ASN1HEX.getIdxbyListEx,
	_getVidx = _ASN1HEX.getVidx,
	_getInt = _ASN1HEX.getInt,
	_oidname = _ASN1HEX.oidname,
	_hextooidstr = _ASN1HEX.hextooidstr,
	_X509 = X509,
	_pemtohex = pemtohex,
	_PSSNAME2ASN1TLV,
	_Error = Error;

    try {
	_PSSNAME2ASN1TLV = KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;
    } catch (ex) {};
    this.HEX2STAG = {"0c": "utf8", "13": "prn", "16": "ia5",
		     "1a": "vis" , "1e": "bmp"};

    this.hex = null;
    this.version = 0; // version (1: X509v1, 3: X509v3, others: unspecified)
    this.foffset = 0; // field index offset (-1: for X509v1, 0: for X509v3)
    this.aExtInfo = null;

    // ===== get basic fields from hex =====================================

    /**
     * get format version (X.509v1 or v3 certificate)<br/>
     * @name getVersion
     * @memberOf X509#
     * @function
     * @return {Number} 1 for X509v1, 3 for X509v3, otherwise 0
     * @since jsrsasign 7.1.14 x509 1.1.13
     * @description
     * This method returns a format version of X.509 certificate.
     * It returns 1 for X.509v1 certificate and 3 for v3 certificate.
     * Otherwise returns 0.
     * This method will be automatically called in
     * {@link X509#readCertPEM}. After then, you can use
     * {@link X509.version} parameter.
     * @example
     * var x = new X509();
     * x.readCertPEM(sCertPEM);
     * version = x.getVersion();    // 1 or 3
     * sn = x.getSerialNumberHex(); // return string like "01ad..."
     */
    this.getVersion = function() {
	if (this.hex === null || this.version !== 0) return this.version;

	// check if the first item of tbsCertificate "[0] { INTEGER 2 }"
	var hFirstObj = _getTLVbyList(this.hex, 0, [0, 0]);
	if (hFirstObj.substr(0, 2) == "a0") {
	    var hVersionTLV = _getTLVbyList(hFirstObj, 0, [0]);
	    var iVersion = _getInt(hVersionTLV, 0);
	    if (iVersion < 0 || 2 < iVersion) {
		throw new Error("malformed version field");
	    }
	    this.version = iVersion + 1;
	    return this.version;
	} else {
	    this.version = 1;
	    this.foffset = -1;
	    return 1;
	}
    };

    /**
     * get hexadecimal string of serialNumber field of certificate.<br/>
     * @name getSerialNumberHex
     * @memberOf X509#
     * @function
     * @return {String} hexadecimal string of certificate serial number
     * @example
     * var x = new X509();
     * x.readCertPEM(sCertPEM);
     * var sn = x.getSerialNumberHex(); // return string like "01ad..."
     */
    this.getSerialNumberHex = function() {
	return _getVbyListEx(this.hex, 0, [0, 0], "02");
    };

    /**
     * get signature algorithm name in basic field
     * @name getSignatureAlgorithmField
     * @memberOf X509#
     * @function
     * @return {String} signature algorithm name (ex. SHA1withRSA, SHA256withECDSA, SHA512withRSAandMGF1)
     * @since x509 1.1.8
     * @see X509#getAlgorithmIdentifierName
     * @description
     * This method will get a name of signature algorithm in 
     * basic field of certificate.
     * <br/>
     * NOTE: From jsrsasign 8.0.21, RSA-PSS certificate is also supported.
     * For supported RSA-PSS algorithm name and PSS parameters,
     * see {@link X509#getSignatureAlgorithmField}.
     * @example
     * var x = new X509();
     * x.readCertPEM(sCertPEM);
     * algName = x.getSignatureAlgorithmField();
     */
    this.getSignatureAlgorithmField = function() {
	var hTLV = _getTLVbyListEx(this.hex, 0, [0, 1]);
	return this.getAlgorithmIdentifierName(hTLV);
    };

    /**
     * get algorithm name name of AlgorithmIdentifier ASN.1 structure
     * @name getAlgorithmIdentifierName
     * @memberOf X509#
     * @function
     * @param {String} hTLV hexadecimal string of AlgorithmIdentifier
     * @return {String} algorithm name (ex. SHA1withRSA, SHA256withECDSA, SHA512withRSAandMGF1, SHA1)
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @description
     * This method will get a name of AlgorithmIdentifier.
     * <br/>
     * @example
     * var x = new X509();
     * algName = x.getAlgorithmIdentifierName("30...");
     */
    this.getAlgorithmIdentifierName = function(hTLV) {
	for (var key in _PSSNAME2ASN1TLV) {
	    if (hTLV === _PSSNAME2ASN1TLV[key]) {
		return key;
	    }
	}
	return _oidname(_getVbyListEx(hTLV, 0, [0], "06"));
    };

    /**
     * get JSON object of issuer field<br/>
     * @name getIssuer
     * @memberOf X509#
     * @function
     * @param {boolean} flagCanon flag to conclude canonicalized name (DEFAULT false)
     * @param {boolean} flagHex flag to conclude hexadecimal string (DEFAULT false)
     * @return {Array} JSON object of issuer field
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see X509#getX500Name
     *
     * @description
     * Get a JSON object of an issuer field.
     * <br>
     * NOTE: From jsrsasign 10.6.0, flagHex and flagCanon has been 
     * supported to conclude a canonicalized name for caseIgnoreMatch
     * desribed in <a href="https://tools.ietf.org/html/rfc4518">
     * RFC 4518</a>.
     *
     * @example
     * var x = new X509(sCertPEM);
     * x.getIssuer() &rarr;
     * { array: [[{type:'C',value:'JP',ds:'prn'}],...],
     *   str: "/C=JP/..." }
     *
     * // with flags
     * x.getIssuer(true, true) &rarr;
     * { array: ...,
     *   str: "/C=JP/O=   Test    123   ",
     *   canon: "/c=jp/o=test 123",
     *   hex: "30..." }
     */
    this.getIssuer = function(flagCanon, flagHex) {
	return this.getX500Name(this.getIssuerHex(), flagCanon, flagHex);
    };

    /**
     * get hexadecimal string of issuer field TLV of certificate.<br/>
     * @name getIssuerHex
     * @memberOf X509#
     * @function
     * @return {String} hexadecial string of issuer DN ASN.1
     * @example
     * var x = new X509();
     * x.readCertPEM(sCertPEM);
     * var issuer = x.getIssuerHex(); // return string like "3013..."
     */
    this.getIssuerHex = function() {
	return _getTLVbyList(this.hex, 0, [0, 3 + this.foffset], "30");
    };

    /**
     * get string of issuer field of certificate.<br/>
     * @name getIssuerString
     * @memberOf X509#
     * @function
     * @return {String} issuer DN string
     * @see X509#getIssuer
     * @example
     * var x = new X509();
     * x.readCertPEM(sCertPEM);
     * var dn1 = x.getIssuerString(); // return string like "/C=US/O=TEST"
     * var dn2 = KJUR.asn1.x509.X500Name.compatToLDAP(dn1); // returns "O=TEST, C=US"
     */
    this.getIssuerString = function() {
	var pIssuer = this.getIssuer();
	return pIssuer.str;
    };

    /**
     * get JSON object of subject field<br/>
     * @name getSubject
     * @memberOf X509#
     * @function
     * @param {boolean} flagCanon flag to conclude canonicalized name (DEFAULT false)
     * @param {boolean} flagHex flag to conclude hexadecimal string (DEFAULT false)
     * @return {object} JSON object of subject field
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see X509#getX500Name
     *
     * @description
     * Get a JSON object of a subject field.
     * <br>
     * NOTE: From jsrsasign 10.6.0, flagHex and flagCanon has been 
     * supported to conclude a canonicalized name for caseIgnoreMatch
     * desribed in <a href="https://tools.ietf.org/html/rfc4518">
     * RFC 4518</a>.
     *
     * @example
     * var x = new X509(sCertPEM);
     * x.getSubject() &rarr;
     * { array: [[{type:'C',value:'JP',ds:'prn'}],...],
     *   str: "/C=JP/..." }
     *
     * // with flags
     * x.getSubject(true, true) &rarr;
     * { array: ...,
     *   str: "/C=JP/O=   Test    123   ",
     *   canon: "/c=jp/o=test 123",
     *   hex: "30..." }
     */
    this.getSubject = function(flagCanon, flagHex) {
	return this.getX500Name(this.getSubjectHex(), flagCanon, flagHex);
    };

    /**
     * get hexadecimal string of subject field of certificate.<br/>
     * @name getSubjectHex
     * @memberOf X509#
     * @function
     * @return {String} hexadecial string of subject DN ASN.1
     * @example
     * var x = new X509();
     * x.readCertPEM(sCertPEM);
     * var subject = x.getSubjectHex(); // return string like "3013..."
     */
    this.getSubjectHex = function() {
	return _getTLVbyList(this.hex, 0, [0, 5 + this.foffset], "30");
    };

    /**
     * get string of subject field of certificate.<br/>
     * @name getSubjectString
     * @memberOf X509#
     * @function
     * @return {String} subject DN string
     * @see X509#getSubject
     * @example
     * var x = new X509();
     * x.readCertPEM(sCertPEM);
     * var dn1 = x.getSubjectString(); // return string like "/C=US/O=TEST"
     * var dn2 = KJUR.asn1.x509.X500Name.compatToLDAP(dn1); // returns "O=TEST, C=US"
     */
    this.getSubjectString = function() {
	var pSubject = this.getSubject();
	return pSubject.str;
    };

    /**
     * get notBefore field string of certificate.<br/>
     * @name getNotBefore
     * @memberOf X509#
     * @function
     * @return {String} not before time value (ex. "151231235959Z")
     * @example
     * var x = new X509();
     * x.readCertPEM(sCertPEM);
     * var notBefore = x.getNotBefore(); // return string like "151231235959Z"
     */
    this.getNotBefore = function() {
        var s = _getVbyList(this.hex, 0, [0, 4 + this.foffset, 0]);
        s = s.replace(/(..)/g, "%$1");
        s = decodeURIComponent(s);
        return s;
    };

    /**
     * get notAfter field string of certificate.<br/>
     * @name getNotAfter
     * @memberOf X509#
     * @function
     * @return {String} not after time value (ex. "151231235959Z")
     * @example
     * var x = new X509();
     * x.readCertPEM(sCertPEM);
     * var notAfter = x.getNotAfter(); // return string like "151231235959Z"
     */
    this.getNotAfter = function() {
	var s = _getVbyList(this.hex, 0, [0, 4 + this.foffset, 1]);
        s = s.replace(/(..)/g, "%$1");
        s = decodeURIComponent(s);
        return s;
    };

    /**
     * get a hexadecimal string of subjectPublicKeyInfo field.<br/>
     * @name getPublicKeyHex
     * @memberOf X509#
     * @function
     * @return {String} ASN.1 SEQUENCE hexadecimal string of subjectPublicKeyInfo field
     * @since jsrsasign 7.1.4 x509 1.1.13
     * @deprecated since jsrsasign 10.5.7 x509 2.0.13. Please use {@link X509#getSPKI} instead.
     *
     * @example
     * x = new X509(sCertPEM);
     * hSPKI = x.getPublicKeyHex(); // return string like "30820122..."
     */
    this.getPublicKeyHex = function() {
	return this.getSPKI();
    };

    /**
     * get ASN.1 TLV hexadecimal string of subjectPublicKeyInfo field.<br/>
     * @name getSPKI
     * @memberOf X509#
     * @function
     * @return {string} ASN.1 SEQUENCE hexadecimal string of subjectPublicKeyInfo field
     * @since jsrsasign 10.5.8 x509 2.0.13
     * @see X509#getPublicKeyHex
     * @see X509#getSPKIValue
     *
     * @description
     * Get a hexadecimal string of SubjectPublicKeyInfo ASN.1 TLV of the certificate.<br/>
     * <pre>
     * SubjectPublicKeyInfo  ::=  SEQUENCE  {
     *    algorithm         AlgorithmIdentifier,
     *    subjectPublicKey  BIT STRING  }
     * </pre>
     *
     * @example
     * x = new X509(sCertPEM);
     * hSPKI = x.getSPKI(); // return string like "30820122..."
     */
    this.getSPKI = function() {
	return _getTLVbyList(this.hex, 0, [0, 6 + this.foffset], "30");
    };

    /**
     * get hexadecimal string of subjectPublicKey of subjectPublicKeyInfo field.<br/>
     * @name getSPKIValue
     * @memberOf X509#
     * @function
     * @return {string} ASN.1 hexadecimal string of subjectPublicKey
     * @since jsrsasign 10.5.8 x509 2.0.13
     * @see X509#getSPKI
     *
     * @description
     * Get a hexadecimal string of subjectPublicKey ASN.1 value of SubjectPublicKeyInfo 
     * of the certificate without unusedbit "00".
     * The "subjectPublicKey" is encapsulated by BIT STRING.
     * This method returns BIT STRING value without unusedbits.
     * <br/>
     * <pre>
     * SubjectPublicKeyInfo  ::=  SEQUENCE  {
     *    algorithm         AlgorithmIdentifier,
     *    subjectPublicKey  BIT STRING  }
     * </pre>
     *
     * @example
     * x = new X509(sCertPEM);
     * hSPKIValue = x.getSPKIValue(); // without BIT STRING Encapusulation.
     */
    this.getSPKIValue = function() {
	var hSPKI = this.getSPKI();
	if (hSPKI == null) return null;
	return _getVbyList(hSPKI, 0, [1], "03", true); // true: remove unused bit
    };

    /**
     * get a string index of subjectPublicKeyInfo field for hexadecimal string certificate.<br/>
     * @name getPublicKeyIdx
     * @memberOf X509#
     * @function
     * @return {Number} string index of subjectPublicKeyInfo field for hexadecimal string certificate.
     * @since jsrsasign 7.1.4 x509 1.1.13
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM);
     * idx = x.getPublicKeyIdx(); // return string index in x.hex parameter
     */
    this.getPublicKeyIdx = function() {
	return _getIdxbyList(this.hex, 0, [0, 6 + this.foffset], "30");
    };

    /**
     * get a string index of contents of subjectPublicKeyInfo BITSTRING value from hexadecimal certificate<br/>
     * @name getPublicKeyContentIdx
     * @memberOf X509#
     * @function
     * @return {Integer} string index of key contents
     * @since jsrsasign 8.0.0 x509 1.2.0
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM);
     * idx = x.getPublicKeyContentIdx(); // return string index in x.hex parameter
     */
    // NOTE: Without BITSTRING encapsulation.
    this.getPublicKeyContentIdx = function() {
	var idx = this.getPublicKeyIdx();
	return _getIdxbyList(this.hex, idx, [1, 0], "30");
    };

    /**
     * get a RSAKey/ECDSA/DSA public key object of subjectPublicKeyInfo field.<br/>
     * @name getPublicKey
     * @memberOf X509#
     * @function
     * @return {Object} RSAKey/ECDSA/DSA public key object of subjectPublicKeyInfo field
     * @since jsrsasign 7.1.4 x509 1.1.13
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM);
     * pubkey= x.getPublicKey();
     */
    this.getPublicKey = function() {
	return KEYUTIL.getKey(this.getPublicKeyHex(), null, "pkcs8pub");
    };

    /**
     * get signature algorithm name from hexadecimal certificate data
     * @name getSignatureAlgorithmName
     * @memberOf X509#
     * @function
     * @return {String} signature algorithm name (ex. SHA1withRSA, SHA256withECDSA)
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @see X509#getAlgorithmIdentifierName
     * @description
     * This method will get signature algorithm name of certificate:
     * @example
     * var x = new X509();
     * x.readCertPEM(sCertPEM);
     * x.getSignatureAlgorithmName() &rarr; "SHA256withRSA"
     */
    this.getSignatureAlgorithmName = function() {
	var hTLV = _getTLVbyList(this.hex, 0, [1], "30");
	return this.getAlgorithmIdentifierName(hTLV);
    };

    /**
     * get signature value as hexadecimal string<br/>
     * @name getSignatureValueHex
     * @memberOf X509#
     * @function
     * @return {String} signature value hexadecimal string without BitString unused bits
     * @since jsrsasign 7.2.0 x509 1.1.14
     *
     * @description
     * This method will get signature value of certificate:
     *
     * @example
     * var x = new X509();
     * x.readCertPEM(sCertPEM);
     * x.getSignatureValueHex() &rarr "8a4c47913..."
     */
    this.getSignatureValueHex = function() {
	return _getVbyList(this.hex, 0, [2], "03", true);
    };

    /**
     * verifies signature value by public key<br/>
     * @name verifySignature
     * @memberOf X509#
     * @function
     * @param {Object} pubKey public key object
     * @return {Boolean} true if signature value is valid otherwise false
     * @since jsrsasign 7.2.0 x509 1.1.14
     *
     * @description
     * This method verifies signature value of hexadecimal string of 
     * X.509 certificate by specified public key object.
     * The signature algorithm used to verify will refer
     * signatureAlgorithm field. (See {@link X509#getSignatureAlgorithmField})
     * RSA-PSS signature algorithms (SHA{,256,384,512}withRSAandMGF1)
     * are available.
     *
     * @example
     * pubKey = KEYUTIL.getKey(pemPublicKey); // or certificate
     * x = new X509();
     * x.readCertPEM(pemCert);
     * x.verifySignature(pubKey) &rarr; true, false or raising exception
     */
    this.verifySignature = function(pubKey) {
	var algName = this.getSignatureAlgorithmField();
	var hSigVal = this.getSignatureValueHex();
	var hTbsCert = _getTLVbyList(this.hex, 0, [0], "30");
	
	var sig = new KJUR.crypto.Signature({alg: algName});
	sig.init(pubKey);
	sig.updateHex(hTbsCert);
	return sig.verify(hSigVal);
    };

    // ===== parse extension ======================================
    /**
     * set array of X.509v3 and CSR extesion information such as extension OID, criticality and value index. (DEPRECATED)<br/>
     * @name parseExt
     * @memberOf X509#
     * @function
     * @param {String} hCSR - PEM string of certificate signing requrest(CSR) (OPTION)
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @deprecated jsrsasign 9.1.1 x509 2.0.1
     *
     * @description
     * This method will set an array of X.509v3 extension information having 
     * following parameters:
     * <ul>
     * <li>oid - extension OID (ex. 2.5.29.19)</li>
     * <li>critical - true or false</li>
     * <li>vidx - string index for extension value</li>
     * <br/>
     * When you want to parse extensionRequest of CSR,
     * argument 'hCSR' shall be specified.
     * <br/>
     * NOTE: CSR is supported from jsrsasign 8.0.20 x509 1.1.22.
     * <br/>
     * This method and X509.aExtInfo property
     * have been *deprecated* since jsrsasign 9.1.1.
     * All extension parser method such as X509.getExt* shall be
     * call with argument "hExtV" and "critical" explicitly.
     *
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     *
     * x.aExtInfo &rarr;
     * [ { oid: "2.5.29,19", critical: true, vidx: 2504 }, ... ]
     *
     * // to parse CSR
     * X = new X509()
     * x.parseExt("-----BEGIN CERTIFICATE REQUEST-----...");
     * x.aExtInfo &rarr;
     * [ { oid: "2.5.29,19", critical: true, vidx: 2504 }, ... ]
     */
    this.parseExt = function(hCSR) {
	var iExtSeq, aExtIdx, h;

	if (hCSR === undefined) {
	    h = this.hex;
	    if (this.version !== 3) return -1;
	    iExtSeq = _getIdxbyList(h, 0, [0, 7, 0], "30");
	    aExtIdx = _getChildIdx(h, iExtSeq);
	} else {
	    h = pemtohex(hCSR);
	    var idx1 = _getIdxbyList(h, 0, [0, 3, 0, 0], "06");

	    if (_getV(h, idx1) != "2a864886f70d01090e") {
		this.aExtInfo = new Array();
		return;
	    }

	    iExtSeq = _getIdxbyList(h, 0, [0, 3, 0, 1, 0], "30");
	    aExtIdx = _getChildIdx(h, iExtSeq);

	    this.hex = h;
	}
	    
	this.aExtInfo = new Array();
	for (var i = 0; i < aExtIdx.length; i++) {
	    var item = {};
	    item.critical = false;
	    var a = _getChildIdx(h, aExtIdx[i]);
	    var offset = 0;

	    if (a.length === 3) {
		item.critical = true;
		offset = 1;
	    }

	    item.oid = _ASN1HEX.hextooidstr(_getVbyList(h, aExtIdx[i], [0], "06"));
	    var octidx = _getIdxbyList(h, aExtIdx[i], [1 + offset]);
	    item.vidx = _getVidx(h, octidx);
	    this.aExtInfo.push(item);
	}
    };

    /**
     * get a X.509v3 extesion information such as extension OID, criticality and value index for specified oid or name.<br/>
     * @name getExtInfo
     * @memberOf X509#
     * @function
     * @param {String} oidOrName X.509 extension oid or name (ex. keyUsage or 2.5.29.19)
     * @return X.509 extension information such as extension OID or value indx (see {@link X509#parseExt})
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @description
     * This method will get an X.509v3 extension information JSON object
     * having extension OID, criticality and value idx for specified
     * extension OID or name.
     * If there is no such extension, this returns undefined.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     *
     * x.getExtInfo("keyUsage") &rarr; { oid: "2.5.29.15", critical: true, vidx: 1714 }
     * x.getExtInfo("unknownExt") &rarr; undefined
     */
    this.getExtInfo = function(oidOrName) {
	var a = this.aExtInfo;
	var oid = oidOrName;
	if (! oidOrName.match(/^[0-9.]+$/)) {
	    oid = KJUR.asn1.x509.OID.name2oid(oidOrName);
	}
	if (oid === '') return undefined;

	for (var i = 0; i < a.length; i++) {
	    if (a[i].oid === oid) return a[i];
	}
	return undefined;
    };

    /**
     * get extension value and critical flag value<br/>
     * @name getCriticalExtV
     * @memberOf X509#
     * @function
     * @param {string} extname name string of the extension
     * @param {string} hExtV hexadecimal string of extension
     * @param {boolean} critical flag
     * @return {Array} extension value hex and critical flag
     * @since jsrsasign 10.6.1 x509 2.1.1
     *
     * @description
     * This method is an utility method for all getExt* of extensions.
     *
     * @example
     * x = new X509(sCertPEM);
     * x.getCriticalExtV("inhibitAnyPolicy") &rarr ["020103", true] // get from X509 object
     * x.getCriticalExtV("inhibitAnyPolicy",
     *                   "020104",
     *                   true) &rarr ["020104", true] // by argument of method.
     */
    this.getCriticalExtV = function(extname, hExtV, critical) {
	if (hExtV != undefined) return [hExtV, critical];
	var info = this.getExtInfo(extname);
	if (info == undefined) return [null, null];
	return [_getTLV(this.hex, info.vidx), info.critical];
    };

    /**
     * get BasicConstraints extension value as object in the certificate
     * @name getExtBasicConstraints
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Array} JSON object of BasicConstraints parameter or undefined
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @see KJUR.asn1.x509.BasicConstraints
     * @description
     * This method will get basic constraints extension value as object with following paramters.
     * <ul>
     * <li>{Boolean}cA - CA flag whether CA or not</li>
     * <li>{Integer}pathLen - maximum intermediate certificate length</li>
     * <li>{Boolean}critical - critical flag</li>
     * </ul>
     * There are use cases for return values:
     * <ul>
     * <li>{cA:true,pathLen:3,critical:true} - cA flag is true and pathLen is 3</li>
     * <li>{cA:true,critical:true} - cA flag is true and no pathLen</li>
     * <li>{} - basic constraints has no value in case of end entity certificate</li>
     * <li>undefined - there is no basic constraints extension</li>
     * </ul>
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtBasicConstraints() &rarr; {cA:true,pathLen:3,critical:true}
     */
    this.getExtBasicConstraints = function(hExtV, critical) {
	if (hExtV === undefined && critical === undefined) {
	    var info = this.getExtInfo("basicConstraints");
	    if (info === undefined) return undefined;
	    hExtV = _getTLV(this.hex, info.vidx);
	    critical = info.critical;
	}

	var result = {extname:"basicConstraints"};
	if (critical) result.critical = true;

	if (hExtV === '3000') return result;
	if (hExtV === '30030101ff') {
	    result.cA = true;
	    return result;
	}
	if (hExtV.substr(0, 12) === '30060101ff02') {
	    var pathLexHex = _getV(hExtV, 10);
	    var pathLen = parseInt(pathLexHex, 16);
	    result.cA = true;
	    result.pathLen = pathLen;
	    return result;
	}
	throw new Error("hExtV parse error: " + hExtV);
    };

    /**
     * get NameConstraints extension value as object in the certificate<br/>
     * @name getExtNameConstraints
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Object} JSON object of NamConstraints parameter or undefined
     * @since jsrsasign 10.5.16 x509 2.0.16
     * @see KJUR.asn1.x509.NameConstraints
     * @see KJUR.asn1.x509.GeneralSubtree
     * @see KJUR.asn1.x509.GeneralName
     * @see X509#getGeneralSubtree
     * @see X509#getGeneralName
     *
     * @description
     * This method will get name constraints extension value as object with following paramters.
     * <ul>
     * <li>{Array}permit - array of {@link KJUR.asn1.x509.GeneralSubtree} parameter</li>
     * <li>{Array}exclude - array of {@link KJUR.asn1.x509.GeneralSubtree} parameter</li>
     * <li>{Boolean}critical - critical flag</li>
     * </ul>
     *
     * @example
     * x = new X509(sCertPEM);
     * x.getExtNameConstraints() &rarr; {
     *   critical: true,
     *   permit: [{dns: 'example.com'},{rfc822: 'john@example.com'}],
     *   exclude: [{dn: {...X500Name parameter...}}]
     * }
     */
    this.getExtNameConstraints = function(hExtV, critical) {
	var aExtVCritical = this.getCriticalExtV("nameConstraints", hExtV, critical);
	hExtV = aExtVCritical[0];
	critical = aExtVCritical[1];
	if (hExtV == null) return undefined;
	var result = {extname:"nameConstraints"};
	if (critical) result.critical = true;

	var aIdx = _getChildIdx(hExtV, 0);
	for (var i = 0; i < aIdx.length; i++) {
	    var aList = [];
	    var aIdx2 = _getChildIdx(hExtV, aIdx[i]);
	    for (var j = 0; j < aIdx2.length; j++) {
		var hSub = _getTLV(hExtV, aIdx2[j]);
		var p = this.getGeneralSubtree(hSub);
		aList.push(p);
	    }

	    var tag = hExtV.substr(aIdx[i], 2); 
	    if (tag == "a0") {
		result.permit = aList;
	    } else if (tag == "a1") {
		result.exclude = aList;
	    }
	}
	return result;
    };

    /**
     * get GeneralSubtree ASN.1 structure parameter as JSON object<br/>
     * @name getGeneralSubtree
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of GeneralSubtree
     * @return {Object} JSON object of GeneralSubtree parameters or undefined
     * @since jsrsasign 10.5.16 x509 2.0.16
     * @see KJUR.asn1.x509.GeneralSubtree
     * @see KJUR.asn1.x509.GeneralName
     * @see X509#getExtNameConstraints
     * @see X509#getGeneralName
     *
     * @description
     * This method will get GeneralSubtree parameters defined in
     * <a href="https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.10">
     * RFC 5280 4.2.1.10</a>.
     * <pre>
     * GeneralSubtree ::= SEQUENCE {
     *      base                    GeneralName,
     *      minimum         [0]     BaseDistance DEFAULT 0,
     *      maximum         [1]     BaseDistance OPTIONAL }
     * BaseDistance ::= INTEGER (0..MAX)
     * </pre>
     * Result of this method can be passed to
     * {@link KJUR.asn1.x509.GeneralSubtree} constructor.
     * 
     * @example
     * x = new X509(sPEM);
     * x.getGeneralSubtree("30...") &rarr; { dn: ...X500NameObject..., min: 1, max: 3 }
     * x.getGeneralSubtree("30...") &rarr; { dns: ".example.com" }
     */
    this.getGeneralSubtree = function(h) {
	var aIdx = _getChildIdx(h, 0);
	var len = aIdx.length;
	if (len < 1 || 2 < len) throw new Error("wrong num elements");
	var result = this.getGeneralName(_getTLV(h, aIdx[0]));

	for (var i = 1; i < len; i++) {
	    var tag = h.substr(aIdx[i], 2);
	    var hV = _getV(h, aIdx[i]);
	    var minmaxValue = parseInt(hV, 16);
	    if (tag == "80") result.min = minmaxValue;
	    if (tag == "81") result.max = minmaxValue;
	}
	return result;
    };

    /**
     * get KeyUsage extension value as JSON object
     * @memberOf X509#
     * @function
     * @name getExtKeyUsage
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Array} JSON object of KeyUsage parameter or undefined
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see KJUR.asn1.x509.KeyUsage
     * @see X509#getExtKeyUsageString
     * @description
     * This method parse keyUsage extension. When arguments are
     * not specified, its extension in X509 object will be parsed.
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.KeyUsage} constructor.
     * <br>
     * When hExtV and critical specified as arguments, return value
     * will be generated from them.
     * <pre>
     * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
     * KeyUsage ::= BIT STRING {
     *      digitalSignature        (0),
     *      nonRepudiation          (1),
     *      keyEncipherment         (2),
     *      dataEncipherment        (3),
     *      keyAgreement            (4),
     *      keyCertSign             (5),
     *      cRLSign                 (6),
     *      encipherOnly            (7),
     *      decipherOnly            (8) }     
     * </pre>
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtKeyUsage() &rarr;
     * {
     *   critial: true,
     *   names: ["digitalSignature", "decipherOnly"]
     * }
     *
     * x = new X509();
     * x.getExtKeyUsage("306230...") 
     * x.getExtKeyUsage("306230...", true) 
     */
    this.getExtKeyUsage = function(hExtV, critical) {
	var aExtVCritical = this.getCriticalExtV("keyUsage", hExtV, critical);
	hExtV = aExtVCritical[0];
	critical = aExtVCritical[1];
	if (hExtV == null) return undefined;
	var result = {extname:"keyUsage"};
	if (critical) result.critical = true;

	result.names = this.getExtKeyUsageString(hExtV).split(",");

	return result;
    };

    /**
     * get KeyUsage extension value as binary string in the certificate<br/>
     * @name getExtKeyUsageBin
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @return {String} binary string of key usage bits (ex. '101')
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @see X509#getExtKeyUsage
     * @description
     * This method will get key usage extension value
     * as binary string such like '101'.
     * Key usage bits definition is in the RFC 5280.
     * If there is no key usage extension in the certificate,
     * it returns empty string (i.e. '').
     * <br/>
     * NOTE: argument 'hExtV' supported since jsrsasign 9.0.0 x509 2.0.0.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtKeyUsageBin() &rarr; '101'
     * // 1 - digitalSignature
     * // 0 - nonRepudiation
     * // 1 - keyEncipherment
     */
    this.getExtKeyUsageBin = function(hExtV) {
	if (hExtV === undefined) {
	    var info = this.getExtInfo("keyUsage");
	    if (info === undefined) return '';
	    hExtV = _getTLV(this.hex, info.vidx);
	}
	
	if (hExtV.length != 8 && hExtV.length != 10)
	    throw new Error("malformed key usage value: " + hExtV);

	var s = "000000000000000" + parseInt(hExtV.substr(6), 16).toString(2);
	if (hExtV.length == 8) s = s.slice(-8);
	if (hExtV.length == 10) s = s.slice(-16);
	s = s.replace(/0+$/, '');
	if (s == '') s = '0';
	return s;
    };

    /**
     * get KeyUsage extension value as names in the certificate<br/>
     * @name getExtKeyUsageString
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @return {String} comma separated string of key usage
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @see X509#getExtKeyUsage
     * @description
     * This method will get key usage extension value
     * as comma separated string of usage names.
     * If there is no key usage extension in the certificate,
     * it returns empty string (i.e. '').
     * <br/>
     * NOTE: argument 'hExtV' supported since jsrsasign 9.0.0 x509 2.0.0.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtKeyUsageString() &rarr; "digitalSignature,keyEncipherment"
     */
    this.getExtKeyUsageString = function(hExtV) {
	var bKeyUsage = this.getExtKeyUsageBin(hExtV);
	var a = new Array();
	for (var i = 0; i < bKeyUsage.length; i++) {
	    if (bKeyUsage.substr(i, 1) == "1") a.push(X509.KEYUSAGE_NAME[i]);
	}
	return a.join(",");
    };

    /**
     * get subjectKeyIdentifier value as hexadecimal string in the certificate<br/>
     * @name getExtSubjectKeyIdentifier
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Array} JSON object of SubjectKeyIdentifier parameter or undefined
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @description
     * This method will get 
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.2">
     * SubjectKeyIdentifier extension</a> value as JSON object.
     * <br>
     * When hExtV and critical specified as arguments, return value
     * will be generated from them.
     * If there is no such extension in the certificate, it returns undefined.
     * <br>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.SubjectKeyIdentifier} constructor.
     * <pre>
     * id-ce-subjectKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 14 }
     * SubjectKeyIdentifier ::= KeyIdentifier
     * </pre>
     * <br>
     * CAUTION:
     * Returned JSON value format have been changed without 
     * backward compatibility since jsrsasign 9.0.0 x509 2.0.0.
     *
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtSubjectKeyIdentifier() &rarr; 
     * { kid: {hex: "1b3347ab..."}, critical: true };
     */
    this.getExtSubjectKeyIdentifier = function(hExtV, critical) {
	if (hExtV === undefined && critical === undefined) {
	    var info = this.getExtInfo("subjectKeyIdentifier");
	    if (info === undefined) return undefined;
	    hExtV = _getTLV(this.hex, info.vidx);
	    critical = info.critical;
	}

	var result = {extname:"subjectKeyIdentifier"};
	if (critical) result.critical = true;

	var hKID = _getV(hExtV, 0);
	result.kid = {hex: hKID};

	return result;
    };

    /**
     * get authorityKeyIdentifier value as JSON object in the certificate<br/>
     * @name getExtAuthorityKeyIdentifier
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Array} JSON object of AuthorityKeyIdentifier parameter or undefined
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @see KJUR.asn1.x509.AuthorityKeyIdentifier
     * @description
     * This method will get 
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.1">
     * AuthorityKeyIdentifier extension</a> value as JSON object.
     * <br>
     * When hExtV and critical specified as arguments, return value
     * will be generated from them.
     * If there is no such extension in the certificate, it returns undefined.
     * <br/>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.AuthorityKeyIdentifier} constructor.
     * <pre>
     *    id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 35 }
     *    AuthorityKeyIdentifier ::= SEQUENCE {
     *       keyIdentifier             [0] KeyIdentifier           OPTIONAL,
     *       authorityCertIssuer       [1] GeneralNames            OPTIONAL,
     *       authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }
     *    KeyIdentifier ::= OCTET STRING
     * </pre>
     * Constructor may have following parameters:
     * <ul>
     * <li>{Array}kid - JSON object of {@link KJUR.asn1.DEROctetString} parameters</li>
     * <li>{Array}issuer - JSON object of {@link KJUR.asn1.x509.X500Name} parameters</li>
     * <li>{Array}sn - JSON object of {@link KJUR.asn1.DERInteger} parameters</li>
     * <li>{Boolean}critical - critical flag</li>
     * </ul>
     * <br>
     * NOTE: The 'authorityCertIssuer' and 'authorityCertSerialNumber'
     * supported since jsrsasign 9.0.0 x509 2.0.0.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtAuthorityKeyIdentifier() &rarr; 
     * { kid: {hex: "1234abcd..."},
     *   issuer: {hex: "30..."},
     *   sn: {hex: "1234..."},
     *   critical: true}
     */
    this.getExtAuthorityKeyIdentifier = function(hExtV, critical) {
	if (hExtV === undefined && critical === undefined) {
	    var info = this.getExtInfo("authorityKeyIdentifier");
	    if (info === undefined) return undefined;
	    hExtV = _getTLV(this.hex, info.vidx);
	    critical = info.critical;
	}

	var result = {extname:"authorityKeyIdentifier"};
	if (critical) result.critical = true;

	var a = _getChildIdx(hExtV, 0);
	for (var i = 0; i < a.length; i++) {
	    var tag = hExtV.substr(a[i], 2);
	    if (tag === "80") {
		result.kid = {hex: _getV(hExtV, a[i])};
	    }
	    if (tag === "a1") {
		var hGNS = _getTLV(hExtV, a[i]);
		var gnsParam = this.getGeneralNames(hGNS);
		result.issuer = gnsParam[0]["dn"];
	    }
	    if (tag === "82") {
		result.sn = {hex: _getV(hExtV, a[i])};
	    }
	}
	return result;
    };

    /**
     * get extKeyUsage value as JSON object
     * @name getExtExtKeyUsage
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Array} JSON object of ExtKeyUsage parameter or undefined
     * @return {Object} JSONarray of extended key usage ID name or oid
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see KJUR.asn1.x509.ExtKeyUsage
     * @description
     * This method parse extKeyUsage extension. When arguments are
     * not specified, its extension in X509 object will be parsed.
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.ExtKeyUsage} constructor.
     * <br>
     * When hExtV and critical specified as arguments, return value
     * will be generated from them.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtExtKeyUsage() &rarr;
     * { array: ["clientAuth", "emailProtection", "1.3.6.1.4.1.311.10.3.4"], 
     *   critical: true},
     */
    this.getExtExtKeyUsage = function(hExtV, critical) {
	if (hExtV === undefined && critical === undefined) {
	    var info = this.getExtInfo("extKeyUsage");
	    if (info === undefined) return undefined;
	    hExtV = _getTLV(this.hex, info.vidx);
	    critical = info.critical;
	}

	var result = {extname:"extKeyUsage",array:[]};
	if (critical) result.critical = true;

	var a = _getChildIdx(hExtV, 0);

	for (var i = 0; i < a.length; i++) {
	    result.array.push(_oidname(_getV(hExtV, a[i])));
	}

	return result;
    };

    /**
     * get extKeyUsage value as array of name string in the certificate(DEPRECATED)<br/>
     * @name getExtExtKeyUsageName
     * @memberOf X509#
     * @function
     * @return {Object} array of extended key usage ID name or oid
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @deprecated since jsrsasign 9.0.0 x509 2.0.0
     * @description
     * This method will get extended key usage extension value
     * as array of name or OID string.
     * If there is this in the certificate, it returns undefined;
     * <br>
     * NOTE: Supported extended key usage ID names are defined in
     * name2oidList parameter in asn1x509.js file.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtExtKeyUsageName() &rarr; ["serverAuth", "clientAuth", "0.1.2.3.4.5"]
     */
    this.getExtExtKeyUsageName = function() {
	var info = this.getExtInfo("extKeyUsage");
	if (info === undefined) return info;

	var result = new Array();
	
	var h = _getTLV(this.hex, info.vidx);
	if (h === '') return result;

	var a = _getChildIdx(h, 0);
	for (var i = 0; i < a.length; i++) {
	    result.push(_oidname(_getV(h, a[i])));
	}

	return result;
    };

    /**
     * get subjectAltName value as array of string in the certificate
     * @name getExtSubjectAltName
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Array} JSON object of SubjectAltName parameters or undefined
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @see KJUR.asn1.x509.SubjectAltName
     * @see X509#getExtIssuerAltName
     * @description
     * This method will get subjectAltName value
     * as an array of JSON object which has properties defined
     * in {@link KJUR.asn1.x509.SubjectAltName}.
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.SubjectAltName} constructor.
     * If there is no this extension in the certificate,
     * it returns undefined.
     * <br>
     * When hExtV and critical specified as arguments, return value
     * will be generated from them.
     * <br>
     * CAUTION: return value of JSON object format have been changed
     * from jsrsasign 9.0.0 x509 2.0.0 without backword compatibility.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtSubjectAltName() &rarr; 
     * { array: [
     *     {uri: "http://example.com/"},
     *     {rfc822: "user1@example.com"},
     *     {dns: "example.com"}
     *   ],
     *   critical: true
     * }
     *
     * x.getExtSubjectAltName("3026...") &rarr;
     * { array: [{ip: "192.168.1.1"}] }
     */
    this.getExtSubjectAltName = function(hExtV, critical) {
	if (hExtV === undefined && critical === undefined) {
	    var info = this.getExtInfo("subjectAltName");
	    if (info === undefined) return undefined;
	    hExtV = _getTLV(this.hex, info.vidx);
	    critical = info.critical;
	}

	var result = {extname:"subjectAltName",array:[]};
	if (critical) result.critical = true;

	result.array = this.getGeneralNames(hExtV);

	return result;
    };

    /**
     * get issuerAltName value as array of string in the certificate
     * @name getExtIssuerAltName
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Array} JSON object of IssuerAltName parameters
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see KJUR.asn1.x509.IssuerAltName
     * @see X509#getExtSubjectAltName
     * @description
     * This method will get issuerAltName value
     * as an array of JSON object which has properties defined
     * in {@link KJUR.asn1.x509.IssuerAltName}.
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.IssuerAltName} constructor.
     * If there is no this extension in the certificate,
     * it returns undefined.
     * <br>
     * When hExtV and critical specified as arguments, return value
     * will be generated from them.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtIssuerAltName() &rarr; 
     * { array: [
     *     {uri: "http://example.com/"},
     *     {rfc822: "user1@example.com"},
     *     {dns: "example.com"}
     *   ],
     *   critical: true
     * }
     *
     * x.getExtIssuerAltName("3026...") &rarr;
     * { array: [{ip: "192.168.1.1"}] }
     */
    this.getExtIssuerAltName = function(hExtV, critical) {
	if (hExtV === undefined && critical === undefined) {
	    var info = this.getExtInfo("issuerAltName");
	    if (info === undefined) return undefined;
	    hExtV = _getTLV(this.hex, info.vidx);
	    critical = info.critical;
	}

	var result = {extname:"issuerAltName",array:[]};
	if (critical) result.critical = true;

	result.array = this.getGeneralNames(hExtV);

	return result;
    };

    /**
     * get GeneralNames ASN.1 structure parameter as JSON object
     * @name getGeneralNames
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of GeneralNames
     * @return {Array} array of GeneralNames parameters
     * @see KJUR.asn1.x509.GeneralNames
     * @see KJUR.asn1.x509.GeneralName
     * @see X509#getGeneralNames
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @description
     * This method will get GeneralNames parameters defined in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.6">
     * RFC 5280 4.2.1.6</a>.
     * <pre>
     * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
     * </pre>
     * Result of this method can be passed to
     * {@link KJUR.asn1.x509.GeneralNames} constructor.
     * @example
     * x = new X509();
     * x.getGeneralNames("3011860f687474703a2f2f6161612e636f6d2f")
     * &rarr; [{uri: "http://aaa.com/"}]
     *
     * x.getGeneralNames("301ea41c30...") &rarr;
     * [{ dn: {
     *     array: [
     *       [{type:"C", value:"JP", ds:"prn"}],
     *       [{type:"O", value:"T1", ds:"utf8"}]
     *     ],
     *     str: "/C=JP/O=T1" } }]
     */
    this.getGeneralNames = function(h) {
	var aIdx = _getChildIdx(h, 0);
	var result = [];
	for (var i = 0; i < aIdx.length; i++) {
	    var gnParam = this.getGeneralName(_getTLV(h, aIdx[i]));
	    if (gnParam !== undefined) result.push(gnParam);
	}
	return result;
    };

    /**
     * get GeneralName ASN.1 structure parameter as JSON object<br/>
     * @name getGeneralName
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of GeneralName
     * @return {Array} JSON object of GeneralName parameters or undefined
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see KJUR.asn1.x509.GeneralNames
     * @see KJUR.asn1.x509.GeneralName
     * @see KJUR.asn1.x509.OtherName
     * @see X509#getGeneralName
     * @see X509#getOtherName
     *
     * @description
     * This method will get GeneralName parameters defined in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.6">
     * RFC 5280 4.2.1.6</a>.
     * <pre>
     * GeneralName ::= CHOICE {
     *      otherName                       [0]     OtherName,
     *      rfc822Name                      [1]     IA5String,
     *      dNSName                         [2]     IA5String,
     *      x400Address                     [3]     ORAddress,
     *      directoryName                   [4]     Name,
     *      ediPartyName                    [5]     EDIPartyName,
     *      uniformResourceIdentifier       [6]     IA5String,
     *      iPAddress                       [7]     OCTET STRING,
     *      registeredID                    [8]     OBJECT IDENTIFIER }
     * </pre>
     * Result of this method can be passed to
     * {@link KJUR.asn1.x509.GeneralName} constructor.
     * @example
     * x = new X509();
     * x.getGeneralName("860f687474703a2f2f6161612e636f6d2f") 
     * &rarr; {uri: "http://aaa.com/"}
     * x.getGeneralName("a41c30...") &rarr;
     * { dn: {
     *     array: [
     *       [{type:"C", value:"JP", ds:"prn"}],
     *       [{type:"O", value:"T1", ds:"utf8"}]
     *     ],
     *     str: "/C=JP/O=T1" } }
     */
    this.getGeneralName = function(h) {
	var tag = h.substr(0, 2);
	var hValue = _getV(h, 0);
	var sValue = hextorstr(hValue);
	if (tag == "81") return {rfc822: sValue};
	if (tag == "82") return {dns: sValue};
	if (tag == "86") return {uri: sValue};
	if (tag == "87") return {ip: hextoip(hValue)};
	if (tag == "a4") return {dn: this.getX500Name(hValue)};
	if (tag == "a0") return {other: this.getOtherName(h)};
	return undefined;
    };

    /**
     * get subjectAltName value as array of string in the certificate (DEPRECATED)
     * @name getExtSubjectAltName2
     * @memberOf X509#
     * @function
     * @return {Object} array of alt name array
     * @since jsrsasign 8.0.1 x509 1.1.17
     * @deprecated jsrsasign 9.0.0 x509 2.0.0
     * @description
     * This method will get subject alt name extension value
     * as array of type and name.
     * If there is this in the certificate, it returns undefined;
     * Type of GeneralName will be shown as following:
     * <ul>
     * <li>"MAIL" - [1]rfc822Name</li>
     * <li>"DNS"  - [2]dNSName</li>
     * <li>"DN"   - [4]directoryName</li>
     * <li>"URI"  - [6]uniformResourceIdentifier</li>
     * <li>"IP"   - [7]iPAddress</li>
     * </ul>
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtSubjectAltName2() &rarr;
     * [["DNS",  "example.com"],
     *  ["DNS",  "example.org"],
     *  ["MAIL", "foo@example.com"],
     *  ["IP",   "192.168.1.1"],
     *  ["IP",   "2001:db8::2:1"],
     *  ["DN",   "/C=US/O=TEST1"]]
     */
    this.getExtSubjectAltName2 = function() {
	var gnValueHex, gnValueStr, gnTag;
	var info = this.getExtInfo("subjectAltName");
	if (info === undefined) return info;

	var result = new Array();
	var h = _getTLV(this.hex, info.vidx);

	var a = _getChildIdx(h, 0);
	for (var i = 0; i < a.length; i++) {
	    gnTag = h.substr(a[i], 2);
	    gnValueHex = _getV(h, a[i]);
	    
	    if (gnTag === "81") { // rfc822Name [1]
		gnValueStr = hextoutf8(gnValueHex);
		result.push(["MAIL", gnValueStr]);
	    }
	    if (gnTag === "82") { // dNSName [2]
		gnValueStr = hextoutf8(gnValueHex);
		result.push(["DNS", gnValueStr]);
	    }
	    if (gnTag === "84") { // directoryName [4]
		gnValueStr = X509.hex2dn(gnValueHex, 0);
		result.push(["DN", gnValueStr]);
	    }
	    if (gnTag === "86") { // uniformResourceIdentifier [6]
		gnValueStr = hextoutf8(gnValueHex);
		result.push(["URI", gnValueStr]);
	    }
	    if (gnTag === "87") { // iPAddress [7]
		gnValueStr = hextoip(gnValueHex);
		result.push(["IP", gnValueStr]);
	    }
	}
	return result;
    };

    /**
     * get CRLDistributionPoints extension value as JSON object
     * @name getExtCRLDistributionPoints
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Object} JSON object of CRLDistributionPoints parameters or undefined
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see KJUR.asn1.x509.CRLDistributionPoints
     * @see X509#getDistributionPoint
     * @see X509#getDistributionPointName
     * @see X509#getGeneralNames
     * @see X509#getGeneralName
     * @description
     * This method will get certificate policies value
     * as an array of JSON object which has properties defined
     * in {@link KJUR.asn1.x509.CRLDistributionPoints}.
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.CRLDistributionPoints} constructor.
     * If there is no this extension in the certificate,
     * it returns undefined.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtCRLDistributionPoints() &rarr; 
     * {array: [
     *   {dpname: {full: [{uri: "http://example.com/"}]}},
     *   {dpname: {full: [{uri: "ldap://example.com/"}]}}
     *  ],
     *  critical: true}
     */
    this.getExtCRLDistributionPoints = function(hExtV, critical) {
	if (hExtV === undefined && critical === undefined) {
	    var info = this.getExtInfo("cRLDistributionPoints");
	    if (info === undefined) return undefined;
	    hExtV = _getTLV(this.hex, info.vidx);
	    critical = info.critical;
	}

	var result = {extname:"cRLDistributionPoints",array:[]};
	if (critical) result.critical = true;

	var a = _getChildIdx(hExtV, 0);
	for (var i = 0; i < a.length; i++) {
	    var hTLV = _getTLV(hExtV, a[i]);
	    result.array.push(this.getDistributionPoint(hTLV));
	}

	return result;
    };

    /**
     * get DistributionPoint ASN.1 structure parameter as JSON object
     * @name getDistributionPoint
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of DistributionPoint
     * @return {Object} JSON object of DistributionPoint parameters
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see X509#getExtCRLDistributionPoints
     * @see X509#getDistributionPointName
     * @see X509#getGeneralNames
     * @see X509#getGeneralName
     * @description
     * This method will get DistributionPoint parameters.
     * Result of this method can be passed to
     * {@link KJUR.asn1.x509.DistributionPoint} constructor.
     * <br/>
     * NOTE: reasons[1] and CRLIssuer[2] field not supported
     * @example
     * x = new X509();
     * x.getDistributionPoint("30...") &rarr;
     * {dpname: {full: [{uri: "http://aaa.com/"}]}}
     */
    this.getDistributionPoint = function(h) {
	var result = {};
	var a = _getChildIdx(h, 0);
	for (var i = 0; i < a.length; i++) {
	    var tag = h.substr(a[i], 2);
	    var hTLV = _getTLV(h, a[i]);
	    if (tag == "a0") {
		result.dpname = this.getDistributionPointName(hTLV);
	    }
	}
	return result;
    };

    /**
     * get DistributionPointName ASN.1 structure parameter as JSON object
     * @name getDistributionPointName
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of DistributionPointName
     * @return {Object} JSON object of DistributionPointName parameters
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see X509#getExtCRLDistributionPoints
     * @see X509#getDistributionPoint
     * @see X509#getGeneralNames
     * @see X509#getGeneralName
     * @description
     * This method will get DistributionPointName parameters.
     * Result of this method can be passed to
     * {@link KJUR.asn1.x509.DistributionPointName} constructor.
     * <br/>
     * NOTE: nameRelativeToCRLIssuer[1] not supported
     * @example
     * x = new X509();
     * x.getDistributionPointName("a0...") &rarr;
     * {full: [{uri: "http://aaa.com/"}]}
     */
    this.getDistributionPointName = function(h) {
	var result = {};
	var a = _getChildIdx(h, 0);
	for (var i = 0; i < a.length; i++) {
	    var tag = h.substr(a[i], 2);
	    var hTLV = _getTLV(h, a[i]);
	    if (tag == "a0") {
		result.full = this.getGeneralNames(hTLV);
	    }
	}
	return result;
    };

    /**
     * get array of string for fullName URIs in cRLDistributionPoints(CDP) in the certificate (DEPRECATED)
     * @name getExtCRLDistributionPointsURI
     * @memberOf X509#
     * @function
     * @return {Object} array of fullName URIs of CDP of the certificate
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @description
     * This method will get all fullName URIs of cRLDistributionPoints extension
     * in the certificate as array of URI string.
     * If there is this in the certificate, it returns undefined;
     * <br>
     * NOTE: Currently this method supports only fullName URI so that
     * other parameters will not be returned.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtCRLDistributionPointsURI() &rarr;
     * ["http://example.com/aaa.crl", "http://example.org/aaa.crl"]
     */
    this.getExtCRLDistributionPointsURI = function() {
	var p = this.getExtCRLDistributionPoints();
	if (p == undefined) return p;
	var a = p.array;
	var result = [];
	for (var i = 0; i < a.length; i++) {
	    try {
		if (a[i].dpname.full[0].uri != undefined) {
		    result.push(a[i].dpname.full[0].uri);
		}
	    } catch(ex) {}
	}
	return result;
    };

    /**
     * get AuthorityInfoAccess extension value in the certificate as associative array
     * @name getExtAIAInfo
     * @memberOf X509#
     * @function
     * @return {Object} associative array of AIA extension properties
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @description
     * This method will get authority info access value
     * as associate array which has following properties:
     * <ul>
     * <li>ocsp - array of string for OCSP responder URL</li>
     * <li>caissuer - array of string for caIssuer value (i.e. CA certificates URL)</li>
     * </ul>
     * If there is this in the certificate, it returns undefined;
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtAIAInfo(hCert) &rarr; 
     * { ocsp:     ["http://ocsp.foo.com"],
     *   caissuer: ["http://rep.foo.com/aaa.p8m"] }
     */
    this.getExtAIAInfo = function() {
	var info = this.getExtInfo("authorityInfoAccess");
	if (info === undefined) return info;

	var result = { ocsp: [], caissuer: [] };
	var a = _getChildIdx(this.hex, info.vidx);
	for (var i = 0; i < a.length; i++) {
	    var hOID = _getVbyList(this.hex, a[i], [0], "06");
	    var hName = _getVbyList(this.hex, a[i], [1], "86");
	    if (hOID === "2b06010505073001") {
		result.ocsp.push(hextoutf8(hName));
	    }
	    if (hOID === "2b06010505073002") {
		result.caissuer.push(hextoutf8(hName));
	    }
	}

	return result;
    };

    /**
     * get AuthorityInfoAccess extension value as JSON object
     * @name getExtAuthorityInfoAccess
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Array} JSON object of AuthorityInfoAccess parameters or undefined
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see KJUR.asn1.x509.AuthorityInfoAccess
     * @description
     * This method parse authorityInfoAccess extension. When arguments are
     * not specified, its extension in X509 object will be parsed.
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.AuthorityInfoAccess} constructor.
     * <br>
     * When hExtV and critical specified as arguments, return value
     * will be generated from them.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtAuthorityInfoAccess() &rarr;
     * {
     *   critial: true, // 
     *   array: [{ocsp: http://ocsp.example.com/},
     *           {caissuer: https://repository.example.com/}]
     * }
     *
     * x = new X509();
     * x.getExtAuthorityInfoAccesss("306230...") 
     * x.getExtAuthorityInfoAccesss("306230...", true) 
     */
    this.getExtAuthorityInfoAccess = function(hExtV, critical) {
	if (hExtV === undefined && critical === undefined) {
	    var info = this.getExtInfo("authorityInfoAccess");
	    if (info === undefined) return undefined;
	    hExtV = _getTLV(this.hex, info.vidx);
	    critical = info.critical;
	}

	var result = {extname:"authorityInfoAccess",array:[]};
	if (critical) result.critical = true;

	var a = _getChildIdx(hExtV, 0);
	for (var i = 0; i < a.length; i++) {
	    var hMethod = _getVbyListEx(hExtV, a[i], [0], "06");
	    var hLoc = _getVbyList(hExtV, a[i], [1], "86");
	    var sLoc = hextoutf8(hLoc);
	    if (hMethod == "2b06010505073001") {
		result.array.push({ocsp: sLoc});
	    } else if (hMethod == "2b06010505073002") {
		result.array.push({caissuer: sLoc});
	    } else {
		throw new Error("unknown method: " + hMethod);
	    }
	}

	return result;
    }

    /**
     * get CertificatePolicies extension value as JSON object
     * @name getExtCertificatePolicies
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Object} JSON object of CertificatePolicies parameters or undefined
     * @since jsrsasign 7.2.0 x509 1.1.14
     * @description
     * This method will get certificate policies value
     * as an array of JSON object which has properties defined
     * in {@link KJUR.asn1.x509.CertificatePolicies}.
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.CertificatePolicies} constructor.
     * If there is no this extension in the certificate,
     * it returns undefined.
     * <br>
     * CAUTION: return value of JSON object format have been changed
     * from jsrsasign 9.0.0 without backword compatibility.
     * <br>
     * When hExtV and critical specified as arguments, return value
     * will be generated from them.
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // parseExt() will also be called internally.
     * x.getExtCertificatePolicies() &rarr; 
     * { array: [
     *   { policyoid: "1.2.3.4" }
     *   { policyoid: "1.2.3.5",
     *     array: [
     *       { cps: "https://example.com/" },
     *       { unotice: { exptext: { type: "bmp", str: "sample text" } } }
     *     ] 
     *   }
     * ]}
     */
    this.getExtCertificatePolicies = function(hExtV, critical) {
	if (hExtV === undefined && critical === undefined) {
	    var info = this.getExtInfo("certificatePolicies");
	    if (info === undefined) return undefined;
	    hExtV = _getTLV(this.hex, info.vidx);
	    critical = info.critical;
	}
	var result = {extname:"certificatePolicies",array:[]};
	if (critical) result.critical = true;

	var aIdxPI = _getChildIdx(hExtV, 0); // PolicyInformation list index
	for (var i = 0; i < aIdxPI.length; i++) {
	    var hPolicyInformation = _getTLV(hExtV, aIdxPI[i]);
	    var polinfo = this.getPolicyInformation(hPolicyInformation);
	    result.array.push(polinfo);
	}
	return result;
    }

    /**
     * get PolicyInformation ASN.1 structure parameter as JSON object
     * @name getPolicyInformation
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of PolicyInformation
     * @return {Object} JSON object of PolicyInformation parameters
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @description
     * This method will get PolicyInformation parameters defined in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">
     * RFC 5280 4.2.1.4</a>.
     * <pre>
     * PolicyInformation ::= SEQUENCE {
     *      policyIdentifier   CertPolicyId,
     *      policyQualifiers   SEQUENCE SIZE (1..MAX) OF
     *                              PolicyQualifierInfo OPTIONAL }
     * </pre>
     * Result of this method can be passed to
     * {@link KJUR.asn1.x509.PolicyInformation} constructor.
     * @example
     * x = new X509();
     * x.getPolicyInformation("30...") &rarr;
     * {
     *     policyoid: "2.16.840.1.114412.2.1",
     *     array: [{cps: "https://www.digicert.com/CPS"}]
     * }
     */
    this.getPolicyInformation = function(h) {
	var result = {};

	var hPOLICYOID = _getVbyList(h, 0, [0], "06");
	result.policyoid = _oidname(hPOLICYOID);
	
	var idxPQSEQ = _getIdxbyListEx(h, 0, [1], "30");
	if (idxPQSEQ != -1) {
	    result.array = [];
	    var aIdx = _getChildIdx(h, idxPQSEQ);
	    for (var j = 0; j < aIdx.length; j++) {
		var hPQI = _getTLV(h, aIdx[j]);
		var pqinfo = this.getPolicyQualifierInfo(hPQI);
		result.array.push(pqinfo);
	    }
	}

	return result;
    };

    /**
     * getOtherName ASN.1 structure parameter as JSON object<br/>
     * @name getOtherName
     * @memberOf X509#
     * @param {String} h hexadecimal string of GeneralName
     * @return {Array} associative array of OtherName
     * @since jsrsasign 10.5.3 x509 2.0.12
     * @see KJUR.asn1.x509.GeneralNames
     * @see KJUR.asn1.x509.GeneralName
     * @see KJUR.asn1.x509.OtherName
     * @see X509#getGeneralName
     * @see ASN1HEX#parse
     *
     * @description
     * This method will get OtherName parameters defined in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.6">
     * RFC 5280 4.2.1.6</a>.
     * <pre>
     * OtherName ::= SEQUENCE {
     *    type-id    OBJECT IDENTIFIER,
     *    value      [0] EXPLICIT ANY DEFINED BY type-id }
     * </pre>
     * The value of member "other" is converted by 
     * {@link ASN1HEX#parse}.
     *
     * @example
     * x = new X509();
     * x.getOtherName("30...") &rarr;
     * { oid: "1.2.3.4",
     *   value: {utf8str: {str: "aaa"}} }
     */
    this.getOtherName = function(h) {
        var result = {};
        var a = _getChildIdx(h, 0);
        var hOID = _getVbyList(h, a[0], [], "06");
        var hValue = _getVbyList(h, a[1], []);
	result.oid = _oidname(hOID);
	result.value = _ASN1HEX_parse(hValue);
        return result;
    };

    /**
     * get PolicyQualifierInfo ASN.1 structure parameter as JSON object
     * @name getPolicyQualifierInfo
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of PolicyQualifierInfo
     * @return {Object} JSON object of PolicyQualifierInfo parameters
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see X509#getExtCertificatePolicies
     * @see X509#getPolicyInformation
     * @description
     * This method will get 
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">
     * PolicyQualifierInfo</a> parameters.
     * <pre>
     * PolicyQualifierInfo ::= SEQUENCE {
     *      policyQualifierId  PolicyQualifierId,
     *      qualifier          ANY DEFINED BY policyQualifierId }
     * id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }
     * id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
     * id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }
     * PolicyQualifierId ::= OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )
     * Qualifier ::= CHOICE {
     *      cPSuri           CPSuri,
     *      userNotice       UserNotice }
     * CPSuri ::= IA5String
     * </pre>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.PolicyQualifierInfo} constructor.
     * @example
     * x = new X509();
     * x.getPolicyQualifierInfo("30...") 
     * &rarr; {unotice: {exptext: {type: 'utf8', str: 'aaa'}}}
     * x.getPolicyQualifierInfo("30...") 
     * &rarr; {cps: "https://repository.example.com/"}
     */
    this.getPolicyQualifierInfo = function(h) {
	var result = {};
	var hPQOID = _getVbyList(h, 0, [0], "06");
	if (hPQOID === "2b06010505070201") { // cps
	    var hCPSURI = _getVbyListEx(h, 0, [1], "16");
	    result.cps = hextorstr(hCPSURI);
	} else if (hPQOID === "2b06010505070202") { // unotice
	    var hUserNotice = _getTLVbyList(h, 0, [1], "30");
	    result.unotice = this.getUserNotice(hUserNotice);
	}
	return result;
    };

    /**
     * get UserNotice ASN.1 structure parameter as JSON object
     * @name getUserNotice
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of UserNotice
     * @return {Object} JSON object of UserNotice parameters
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see X509#getExtCertificatePolicies
     * @see X509#getPolicyInformation
     * @see X509#getPolicyQualifierInfo
     * @see KJUR.asn1.x509.UserNotice
     *
     * @description
     * This method will get 
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">
     * UserNotice</a> parameters.
     * <pre>
     * UserNotice ::= SEQUENCE {
     *      noticeRef        NoticeReference OPTIONAL,
     *      explicitText     DisplayText OPTIONAL }
     * NoticeReference ::= SEQUENCE {
     *      organization     DisplayText,
     *      noticeNumbers    SEQUENCE OF INTEGER }
     * </pre>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.UserNotice} constructor.
     * <br/>
     * NOTE: NoticeReference supported from jsrsasign 10.8.0.
     *
     * @example
     * x = new X509();
     * x.getUserNotice("30...") &rarr; { 
     *   noticeref: {
     *     org: {type: 'utf8', str: 'test org'},
     *     noticenum: [1]
     *   },
     *   exptext: {type: 'utf8', str: 'test text'}
     * }
     */
    this.getUserNotice = function(h) {
	var pASN1 = null;
	var result = {};
	try { 
	    pASN1 = _ASN1HEX.parse(h);
	    var pUnotice = this._asn1ToUnotice(pASN1);
	    return pUnotice;
	} catch(ex) {
	    return undefined;
	}
    };

    this._asn1ToUnotice = function(p) {
	try {
	    var result = {};
	    var a = aryval(p, "seq");
	    for (var i = 0; i < a.length; i++) {
		var pNoticeRef = this._asn1ToNoticeRef(a[i]);
		if (pNoticeRef != undefined) result.noticeref = pNoticeRef;
		var pExpText = this.asn1ToDisplayText(a[i]);
		if (pExpText != undefined) result.exptext = pExpText;
	    }
	    if (Object.keys(result).length > 0) return result;
	    return undefined;
	} catch(ex) {
	    return undefined;
	}
    }

    this._asn1ToNoticeRef = function(p) {
	try {
	    var result = {};
	    var a = aryval(p, "seq");
	    for (var i = 0; i < a.length; i++) {
		var pNoticeNum = this._asn1ToNoticeNum(a[i]);
		if (pNoticeNum != undefined) result.noticenum = pNoticeNum;
		var pOrg = this.asn1ToDisplayText(a[i]);
		if (pOrg != undefined) result.org = pOrg;
	    }
	    if (Object.keys(result).length > 0) return result;
	    return undefined;
	} catch(ex) {
	    return undefined;
	}
    }

    this._asn1ToNoticeNum = function(p) {
	try {
	    var a = aryval(p, "seq");
	    var result = [];
	    for (var i = 0; i < a.length; i++) {
		var item = a[i];
		result.push(parseInt(aryval(item, "int.hex"), 16));
	    }
	    return result;
	} catch(ex) {
	    return undefined;
	}
    }

    /**
     * get DisplayText ASN.1 structure parameter as JSON object
     * @name getDisplayText
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of DisplayText
     * @return {Object} JSON object of DisplayText parameters
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see X509#getExtCertificatePolicies
     * @see X509#getPolicyInformation
     * @description
     * This method will get 
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">
     * DisplayText</a> parameters.
     * <pre>
     * DisplayText ::= CHOICE {
     *      ia5String        IA5String      (SIZE (1..200)),
     *      visibleString    VisibleString  (SIZE (1..200)),
     *      bmpString        BMPString      (SIZE (1..200)),
     *      utf8String       UTF8String     (SIZE (1..200)) }     
     * </pre>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.DisplayText} constructor.
     * @example
     * x = new X509();
     * x.getDisplayText("0c03616161") &rarr {type: 'utf8', str: 'aaa'}
     * x.getDisplayText("1e03616161") &rarr {type: 'bmp',  str: 'aaa'}
     */
    this.getDisplayText = function(h) {
	var _DISPLAYTEXTTAG = {"0c": "utf8", "16": "ia5", "1a": "vis" , "1e": "bmp"};
	var result = {};
	result.type = _DISPLAYTEXTTAG[h.substr(0, 2)];
	result.str = hextorstr(_getV(h, 0));
	return result;
    };

    /**
     * convert ASN1Object parameter to DisplayText parameter
     * @name asn1ToDisplayText
     * @memberOf X509#
     * @function
     * @param {Object} pASN1 ASN1Object paramter for DisplayText
     * @return {Object} DisplayText paramter
     * @since jsrsasign 10.8.0 x509 2.1.3
     * @see X509#getDisplayText
     * @see KJUR.asn1.x509.DisplayText
     * @see KJUR.asn1.ASN1Util#newObject
     *
     * @description
     * This method converts from {@link KJUR.asn1.ASN1Util#newObject} paramter to
     * {@link KJUR.asn1.x509.DisplayText} paramter
     * for <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">
     * DisplayText</a> ASN.1 structure.
     * <pre>
     * DisplayText ::= CHOICE {
     *      ia5String        IA5String      (SIZE (1..200)),
     *      visibleString    VisibleString  (SIZE (1..200)),
     *      bmpString        BMPString      (SIZE (1..200)),
     *      utf8String       UTF8String     (SIZE (1..200)) }     
     * </pre>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.DisplayText} constructor.
     *
     * @example
     * x = new X509();
     * x.asn1ToDisplayText({utf8str: {str: "aaa"}}) &rarr {type: 'utf8', str: 'aaa'}
     * x.asn1ToDisplayText({bmpstr: {str: "aaa"}}) &rarr {type: 'bmp',  str: 'aaa'}
     */
    this.asn1ToDisplayText = function(pASN1) {
	if (pASN1.utf8str != undefined) return { type: "utf8", str: pASN1.utf8str.str };
	if (pASN1.ia5str != undefined)  return { type: "ia5", str: pASN1.ia5str.str };
	if (pASN1.visstr != undefined)  return { type: "vis", str: pASN1.visstr.str };
	if (pASN1.bmpstr != undefined)  return { type: "bmp", str: pASN1.bmpstr.str };
	if (pASN1.prnstr != undefined)  return { type: "prn", str: pASN1.prnstr.str };
	return undefined;
    }

    /**
     * get PolicyMappings extension value as JSON object<br/>
     * @name getExtPolicyMappings
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Object} JSON object of PolicyMappings parameters or undefined
     * @since jsrsasign 10.6.1 x509 2.1.1
     * @see KJUR.asn1.x509.PolicyMappings
     *
     * @description
     * This method will get certificate policies value
     * as an array of JSON object which has properties defined
     * in {@link KJUR.asn1.x509.PolicyMappings}.
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.PolicyMappings} constructor.
     * If there is no this extension in the certificate,
     * it returns undefined.
     * <br>
     * When hExtV and critical specified as arguments, return value
     * will be generated from them.
     * @example
     * x = new X509(sCertPEM);
     * x.getExtPolicyMappings() &rarr; 
     * { extname: "policyMappings",
     *   critical: true,
     *   array: [["1.2.3", "1.4.5"],["0.1.2", "anyPolicy"]]}
     */
    this.getExtPolicyMappings = function(hExtV, critical) {
	var aExtVCritical = this.getCriticalExtV("policyMappings", hExtV, critical);
	hExtV = aExtVCritical[0];
	critical = aExtVCritical[1];
	if (hExtV == null) return undefined;
	var result = {extname: "policyMappings"};
	if (critical) result.critical = true;

	try {
	    var p = _ASN1HEX_parse(hExtV);
	    //result._asn1 = p;
	    var aPair = p.seq;
	    var a = [];
	    for (var i = 0; i < aPair.length; i++) {
		var aOid = aPair[i].seq;
		a.push([aOid[0].oid, aOid[1].oid]);
	    }
	    result.array = a;
	} catch(ex) {
	    throw new _Error("malformed policyMappings");
	}

	return result;
    };

    /**
     * get PolicyConstraints extension value as JSON object<br/>
     * @name getExtPolicyConstraints
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Object} JSON object of PolicyConstraints parameters or undefined
     * @since jsrsasign 10.6.1 x509 2.1.1
     * @see KJUR.asn1.x509.PolicyConstraints
     *
     * @description
     * This method will get certificate policies value
     * as an array of JSON object which has properties defined
     * in {@link KJUR.asn1.x509.PolicyConstraints}.
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.PolicyConstraints} constructor.
     * If there is no this extension in the certificate,
     * it returns undefined.
     * <br>
     * When hExtV and critical specified as arguments, return value
     * will be generated from them.
     * @example
     * x = new X509(sCertPEM);
     * x.getExtPolicyConstraints() &rarr; 
     * { extname: "policyConstraints",
     *   critical: true,
     *   reqexp: 3,
     *   inhibit: 3 }
     */
    this.getExtPolicyConstraints = function(hExtV, critical) {
	var aExtVCritical = this.getCriticalExtV("policyConstraints", hExtV, critical);
	hExtV = aExtVCritical[0];
	critical = aExtVCritical[1];
	if (hExtV == null) return undefined;
	var result = {extname: "policyConstraints"};
	if (critical) result.critical = true;

	var p = _ASN1HEX_parse(hExtV);
	try {
	    var aItem = p.seq;
	    for (var i = 0; i < aItem.length; i++) {
		var pTag = aItem[i].tag;
		if (pTag.explicit != false) continue;
		if (pTag.tag == "80") result.reqexp = parseInt(pTag.hex, 16);
		if (pTag.tag == "81") result.inhibit = parseInt(pTag.hex, 16);
	    }
	} catch(ex) {
	    return new _Error("malformed policyConstraints value");
	}
	return result;
    };

    /**
     * get InhibitAnyPolicy extension value as JSON object<br/>
     * @name getExtInhibitAnyPolicy
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value (OPTIONAL)
     * @param {Boolean} critical flag (OPTIONAL)
     * @return {Object} JSON object of InhibitAnyPolicy parameters or undefined
     * @since jsrsasign 10.6.1 x509 2.1.1
     * @see KJUR.asn1.x509.InhibitAnyPolicy
     *
     * @description
     * This method will get certificate policies value
     * as an array of JSON object which has properties defined
     * in {@link KJUR.asn1.x509.InhibitAnyPolicy}.
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.InhibitAnyPolicy} constructor.
     * If there is no this extension in the certificate,
     * it returns undefined.
     * <br>
     * When hExtV and critical specified as arguments, return value
     * will be generated from them.
     * @example
     * x = new X509(sCertPEM);
     * x.getExtInhibitAnyPolicy() &rarr; 
     * { extname: "policyConstraints",
     *   critical: true,
     *   skip: 3 }
     *
     * x.getExtInhibitAnyPolicy("020103", true) &rarr; same as above
     */
    this.getExtInhibitAnyPolicy = function(hExtV, critical) {
	var aExtVCritical = this.getCriticalExtV("inhibitAnyPolicy", hExtV, critical);
	hExtV = aExtVCritical[0];
	critical = aExtVCritical[1];
	if (hExtV == null) return undefined;
	var result = {extname: "inhibitAnyPolicy"};
	if (critical) result.critical = true;

	var skip = _getInt(hExtV, 0);
	if (skip == -1) return new _Error("wrong value");
	result.skip = skip;
	return result;
    };

    /**
     * parse cRLNumber CRL extension as JSON object<br/>
     * @name getExtCRLNumber
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value
     * @param {Boolean} critical flag
     * @since jsrsasign 9.1.1 x509 2.0.1
     * @see KJUR.asn1.x509.CRLNumber
     * @see X509#getExtParamArray
     * @description
     * This method parses
     * CRLNumber CRL extension value defined in
     * <a href="https://tools.ietf.org/html/rfc5280#section-5.2.3">
     * RFC 5280 5.2.3</a> as JSON object.
     * <pre>
     * id-ce-cRLNumber OBJECT IDENTIFIER ::= { id-ce 20 }
     * CRLNumber ::= INTEGER (0..MAX)
     * </pre>
     * <br/>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.CRLNumber} constructor.
     * @example
     * crl = X509CRL("-----BEGIN X509 CRL...");
     * ... get hExtV and critical flag ...
     * crl.getExtCRLNumber("02...", false) &rarr;
     * {extname: "cRLNumber", num: {hex: "12af"}}
     */
    this.getExtCRLNumber = function(hExtV, critical) {
	var result = {extname:"cRLNumber"};
	if (critical) result.critical = true;

	if (hExtV.substr(0, 2) == "02") {
	    result.num = {hex: _getV(hExtV, 0)};
	    return result;
	}
	throw new _Error("hExtV parse error: " + hExtV);
    };

    /**
     * parse cRLReason CRL entry extension as JSON object<br/>
     * @name getExtCRLReason
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value
     * @param {Boolean} critical flag
     * @since jsrsasign 9.1.1 x509 2.0.1
     * @see KJUR.asn1.x509.CRLReason
     * @see X509#getExtParamArray
     * @description
     * This method parses
     * CRLReason CRL entry extension value defined in
     * <a href="https://tools.ietf.org/html/rfc5280#section-5.3.1">
     * RFC 5280 5.3.1</a> as JSON object.
     * <pre>
     * id-ce-cRLReasons OBJECT IDENTIFIER ::= { id-ce 21 }
     * -- reasonCode ::= { CRLReason }
     * CRLReason ::= ENUMERATED {
     *      unspecified             (0),
     *      keyCompromise           (1),
     *      cACompromise            (2),
     *      affiliationChanged      (3),
     *      superseded              (4),
     *      cessationOfOperation    (5),
     *      certificateHold         (6),
     *      removeFromCRL           (8),
     *      privilegeWithdrawn      (9),
     *      aACompromise           (10) }
     * </pre>
     * <br/>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.CRLReason} constructor.
     * @example
     * crl = X509CRL("-----BEGIN X509 CRL...");
     * ... get hExtV and critical flag ...
     * crl.getExtCRLReason("02...", false) &rarr;
     * {extname: "cRLReason", code: 3}
     */
    this.getExtCRLReason = function(hExtV, critical) {
	var result = {extname:"cRLReason"};
	if (critical) result.critical = true;

	if (hExtV.substr(0, 2) == "0a") {
	    result.code = parseInt(_getV(hExtV, 0), 16);
	    return result;
	}
	throw new Error("hExtV parse error: " + hExtV);
    };

    /**
     * parse OCSPNonce OCSP extension as JSON object<br/>
     * @name getExtOcspNonce
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value
     * @param {Boolean} critical flag
     * @return {Array} JSON object of parsed OCSPNonce extension
     * @since jsrsasign 9.1.6 x509 2.0.3
     * @see KJUR.asn1.x509.OCSPNonce
     * @see X509#getExtParamArray
     * @see X509#getExtParam
     * @description
     * This method parses
     * Nonce OCSP extension value defined in
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.4.1">
     * RFC 6960 4.4.1</a> as JSON object.
     * <pre>
     * id-pkix-ocsp           OBJECT IDENTIFIER ::= { id-ad-ocsp }
     * id-pkix-ocsp-nonce     OBJECT IDENTIFIER ::= { id-pkix-ocsp 2 }
     * Nonce ::= OCTET STRING
     * </pre>
     * <br/>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.OCSPNonce} constructor.
     * @example
     * x = new X509();
     * x.getExtOcspNonce(<<extn hex value >>) &rarr;
     * { extname: "ocspNonce", hex: "1a2b..." }
     */
    this.getExtOcspNonce = function(hExtV, critical) {
	var result = {extname:"ocspNonce"};
	if (critical) result.critical = true;

	var hNonce = _getV(hExtV, 0);
	result.hex = hNonce;

	return result;
    };

    /**
     * parse OCSPNoCheck OCSP extension as JSON object<br/>
     * @name getExtOcspNoCheck
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value
     * @param {Boolean} critical flag
     * @return {Array} JSON object of parsed OCSPNoCheck extension
     * @since jsrsasign 9.1.6 x509 2.0.3
     * @see KJUR.asn1.x509.OCSPNoCheck
     * @see X509#getExtParamArray
     * @see X509#getExtParam
     * @description
     * This method parses
     * OCSPNoCheck extension value defined in
     * <a href="https://tools.ietf.org/html/rfc6960#section-4.2.2.2.1">
     * RFC 6960 4.2.2.2.1</a> as JSON object.
     * <pre>
     * id-pkix-ocsp-nocheck OBJECT IDENTIFIER ::= { id-pkix-ocsp 5 }
     * </pre>
     * <br/>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.OCSPNoCheck} constructor.
     * @example
     * x = new X509();
     * x.getExtOcspNoCheck(<<extn hex value >>) &rarr;
     * { extname: "ocspNoCheck" }
     */
    this.getExtOcspNoCheck = function(hExtV, critical) {
	var result = {extname:"ocspNoCheck"};
	if (critical) result.critical = true;

	return result;
    };

    /**
     * parse AdobeTimeStamp extension as JSON object<br/>
     * @name getExtAdobeTimeStamp
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value
     * @param {Boolean} critical flag
     * @return {Array} JSON object of parsed AdobeTimeStamp extension
     * @since jsrsasign 10.0.1 x509 2.0.5
     * @see KJUR.asn1.x509.AdobeTimeStamp
     * @see X509#getExtParamArray
     * @see X509#getExtParam
     * @description
     * This method parses
     * X.509v3 AdobeTimeStamp private extension value defined in the
     * <a href="https://www.adobe.com/devnet-docs/acrobatetk/tools/DigSigDC/oids.html">
     * Adobe site</a> as JSON object.
     * This extension provides the URL location for time stamp service.
     * <pre>
     * adbe- OBJECT IDENTIFIER ::=  { adbe(1.2.840.113583) acrobat(1) security(1) x509Ext(9) 1 }
     *  ::= SEQUENCE {
     *     version INTEGER  { v1(1) }, -- extension version
     *     location GeneralName (In v1 GeneralName can be only uniformResourceIdentifier)
     *     requiresAuth        boolean (default false), OPTIONAL }
     * </pre>
     * <br/>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.AdobeTimeStamp} constructor.
     * <br/>
     * NOTE: This extesion doesn't seem to have official name. This may be called as "pdfTimeStamp".
     * @example
     * x.getExtAdobeTimeStamp(<<extn hex value >>) &rarr;
     * { extname: "adobeTimeStamp", uri: "http://tsa.example.com/" reqauth: true }
     */
    this.getExtAdobeTimeStamp = function(hExtV, critical) {
	if (hExtV === undefined && critical === undefined) {
	    var info = this.getExtInfo("adobeTimeStamp");
	    if (info === undefined) return undefined;
	    hExtV = _getTLV(this.hex, info.vidx);
	    critical = info.critical;
	}

	var result = {extname:"adobeTimeStamp"};
	if (critical) result.critical = true;

	var a = _getChildIdx(hExtV, 0);
	if (a.length > 1) {
	    var hGN = _getTLV(hExtV, a[1])
	    var gnParam = this.getGeneralName(hGN);
	    if (gnParam.uri != undefined) {
		result.uri = gnParam.uri;
	    }
	}
	if (a.length > 2) {
	    var hBool = _getTLV(hExtV, a[2]);
	    if (hBool == "0101ff") result.reqauth = true;
	    if (hBool == "010100") result.reqauth = false;
	}

	return result;
    };

    /**
     * parse SubjectDirectoryAttributes extension as JSON object<br/>
     * @name getExtSubjectDirectoryAttributes
     * @memberOf X509#
     * @function
     * @param {String} hExtV hexadecimal string of extension value
     * @param {Boolean} critical flag
     * @return {Array} JSON object of parsed SubjectDirectoryAttributes extension
     * @since jsrsasign 10.8.4 x509 2.1.4
     * @see KJUR.asn1.x509.SubjectDirectoryAttributes
     * @see X509#getExtParamArray
     * @see X509#getExtParam
     *
     * @description
     * This method parses
     * SubjectDirectoryAttributes extension value defined in the
     * defined in <a href="https://tools.ietf.org/html/rfc3739#section-3.3.2">
     * RFC 3739 Qualified Certificate Profile section 3.3.2</a> as JSON object.
     * <pre>
     * SubjectDirectoryAttributes ::= Attributes
     * Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
     * Attribute ::= SEQUENCE {
     *   type AttributeType 
     *   values SET OF AttributeValue }
     * AttributeType ::= OBJECT IDENTIFIER
     * AttributeValue ::= ANY DEFINED BY AttributeType
     * </pre>
     * <br/>
     * Result of this method can be passed to 
     * {@link KJUR.asn1.x509.SubjectDirectoryAttributes} constructor.
     *
     * @example
     * x.getExtSubjectDirectoryAttributes(<<extn hex value >>) &rarr;
     * { "extname": "SubjectDirectoryAttributes",
     *   "array": [
     *     { "attr": "gender", "array": [{"prnstr": {"str": "female"}}] },
     *     { "attr": "1.2.3.4.5", "array": [{"prnstr": {"str": "aaa"}}, {"utf8str": {"str": "bbb"}}] }
     *   ] }
     */
    this.getExtSubjectDirectoryAttributes = function(hExtV, critical) {
	if (hExtV === undefined && critical === undefined) {
	    var info = this.getExtInfo("subjectDirectoryAttributes");
	    if (info === undefined) return undefined;
	    hExtV = _getTLV(this.hex, info.vidx);
	    critical = info.critical;
	}

	var result = { extname: "subjectDirectoryAttributes" };
	if (critical) result.critical = true;
	try {
	    var pASN1 = _ASN1HEX_parse(hExtV);
	    var aValue = [];
	    for (var i = 0; i < pASN1.seq.length; i++) {
		var aASN1Attribute = pASN1.seq[i];
		var attrType = aryval(aASN1Attribute, "seq.0.oid");
		var attrValue = aryval(aASN1Attribute, "seq.1.set");
		if (attrType == undefined || attrValue == undefined) throw "error";
		aValue.push({ attr: attrType, array: attrValue });
	    }
	    result.array = aValue;
	    return result;
	} catch(ex) {
	    throw new Error("malformed subjectDirectoryAttributes extension value");
	}
    }

    // ===== BEGIN X500Name related =====================================
    /*
     * convert ASN.1 parsed object to attrTypeAndValue assoc array<br/>
     * @name _convATV
     * @param p associative array of parsed attrTypeAndValue object
     * @return attrTypeAndValue associative array
     * @since jsrsasign 10.5.12 x509 2.0.14
     * @example
     * _convATV({seq: [...]} &rarr: {type:"C",value:"JP",ds:"prn"}
     */
    var _convATV = function(p) {
	var result = {};
	try {
	    var name = p.seq[0].oid;
	    var oid = KJUR.asn1.x509.OID.name2oid(name);
	    result.type = KJUR.asn1.x509.OID.oid2atype(oid);
	    var item1 = p.seq[1];
	    if (item1.utf8str != undefined) {
		result.ds = "utf8";
		result.value = item1.utf8str.str;
	    } else if (item1.numstr != undefined) {
		result.ds = "num";
		result.value = item1.numstr.str;
	    } else if (item1.telstr != undefined) {
		result.ds = "tel";
		result.value = item1.telstr.str;
	    } else if (item1.prnstr != undefined) {
		result.ds = "prn";
		result.value = item1.prnstr.str;
	    } else if (item1.ia5str != undefined) {
		result.ds = "ia5";
		result.value = item1.ia5str.str;
	    } else if (item1.visstr != undefined) {
		result.ds = "vis";
		result.value = item1.visstr.str;
	    } else if (item1.bmpstr != undefined) {
		result.ds = "bmp";
		result.value = item1.bmpstr.str;
            } else if (item1.bitstr != undefined) {
                result.ds = "bit";
                result.value = item1.bitstr.hex;
	    } else {
		throw "error";
	    }
	    return result;
	} catch(ex) {
	    throw new Error("improper ASN.1 parsed AttrTypeAndValue");
	}
    };

    /*
     * convert ASN.1 parsed object to RDN array<br/>
     * @name _convRDN
     * @param p associative array of parsed RDN object
     * @return RDN array
     * @since jsrsasign 10.5.12 x509 2.0.14
     * @example
     * _convRDN({set: [...]} &rarr: [{type:"C",value:"JP",ds:"prn"}]
     */
    var _convRDN = function(p) {
	try {
	    return p.set.map(function(pATV){return _convATV(pATV)});
	} catch(ex) {
	    throw new Error("improper ASN.1 parsed RDN: " + ex);
	}
    };

    /*
     * convert ASN.1 parsed object to X500Name array<br/>
     * @name _convX500Name
     * @param p associative array of parsed X500Name array object
     * @return RDN array
     * @since jsrsasign 10.5.12 x509 2.0.14
     * @example
     * _convX500Name({seq: [...]} &rarr: [[{type:"C",value:"JP",ds:"prn"}]]
     */
    var _convX500Name = function(p) {
	try {
	    return p.seq.map(function(pRDN){return _convRDN(pRDN)});
	} catch(ex) {
	    throw new Error("improper ASN.1 parsed X500Name: " + ex);
	}
    };

    this.getX500NameRule = function(aDN) {
	var isPRNRule = true;
	var isUTF8Rule = true;
	var isMixedRule = false;
	var logfull = "";
	var logcheck = "";
	var lasttag = null;

	var a = [];
	for (var i = 0; i < aDN.length; i++) {
	    var aRDN = aDN[i];
	    for (var j = 0; j < aRDN.length; j++) {
		a.push(aRDN[j]);
	    }
	}

	for (var i = 0; i < a.length; i++) {
	    var item = a[i];
	    var tag = item.ds;
	    var value = item.value;
	    var type = item.type;
	    logfull += ":" + tag;
	    
	    if (tag != "prn" && tag != "utf8" && tag != "ia5") {
		return "mixed";
	    }
	    if (tag == "ia5") {
		if (type != "CN") {
		    return "mixed";
		} else {
		    if (! KJUR.lang.String.isMail(value)) {
			return "mixed";
		    } else {
			continue;
		    }
		}
	    }
	    if (type == "C") {
		if (tag == "prn") {
		    continue;
		} else {
		    return "mixed";
		}
	    }
	    logcheck += ":" + tag;
	    if (lasttag == null) {
		lasttag = tag;
	    } else {
		if (lasttag !== tag) return "mixed";
	    }
	}
	if (lasttag == null) {
	    return "prn";
	} else {
	    return lasttag;
	}
    };

    /**
     * get AttributeTypeAndValue ASN.1 structure parameter as JSON object<br/>
     * @name getAttrTypeAndValue
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of AttributeTypeAndValue
     * @return {Object} JSON object of AttributeTypeAndValue parameters
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see X509#getX500Name
     * @see X509#getRDN
     * @description
     * This method will get AttributeTypeAndValue parameters defined in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.4">
     * RFC 5280 4.1.2.4</a>.
     * <pre>
     * AttributeTypeAndValue ::= SEQUENCE {
     *   type     AttributeType,
     *   value    AttributeValue }
     * AttributeType ::= OBJECT IDENTIFIER
     * AttributeValue ::= ANY -- DEFINED BY AttributeType
     * </pre>
     * <ul>
     * <li>{String}type - AttributeType name or OID(ex. C,O,CN)</li>
     * <li>{String}value - raw string of ASN.1 value of AttributeValue</li>
     * <li>{String}ds - DirectoryString type of AttributeValue</li>
     * </ul>
     * "ds" has one of following value:
     * <ul>
     * <li>utf8 - (0x0c) UTF8String</li>
     * <li>num  - (0x12) NumericString</li>
     * <li>prn  - (0x13) PrintableString</li>
     * <li>tel  - (0x14) TeletexString</li>
     * <li>ia5  - (0x16) IA5String</li>
     * <li>vis  - (0x1a) VisibleString</li>
     * <li>bmp  - (0x1e) BMPString</li>
     * </ul>
     * @example
     * x = new X509();
     * x.getAttrTypeAndValue("30...") &rarr;
     * {type:"CN",value:"john.smith@example.com",ds:"ia5"} or
     * {type:"O",value:"Sample Corp.",ds:"prn"}
     */
    // unv  - (0x1c??) UniversalString ... for future
    this.getAttrTypeAndValue = function(h) {
	var p = _ASN1HEX_parse(h);
	return _convATV(p);
    };

    /**
     * get RelativeDistinguishedName ASN.1 structure parameter array<br/>
     * @name getRDN
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of RDN
     * @return {Array} array of AttrTypeAndValue parameters
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see X509#getX500Name
     * @see X509#getRDN
     * @see X509#getAttrTypeAndValue
     * @description
     * This method will get RelativeDistinguishedName parameters defined in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.4">
     * RFC 5280 4.1.2.4</a>.
     * <pre>
     * RelativeDistinguishedName ::=
     *   SET SIZE (1..MAX) OF AttributeTypeAndValue
     * </pre>
     * @example
     * x = new X509();
     * x.getRDN("31...") &rarr;
     * [{type:"C",value:"US",ds:"prn"}] or
     * [{type:"O",value:"Sample Corp.",ds:"prn"}] or
     * [{type:"CN",value:"john.smith@example.com",ds:"ia5"}]
     */
    this.getRDN = function(h) {
	var p = _ASN1HEX_parse(h);
	return _convRDN(p);
    };

    /**
     * get X.500 Name ASN.1 structure parameter array<br/>
     * @name getX500NameArray
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of Name
     * @return {Array} array of RDN parameter array
     * @since jsrsasign 10.0.6 x509 2.0.9
     * @see X509#getX500Name
     * @see X509#getRDN
     * @see X509#getAttrTypeAndValue
     * @description
     * This method will get Name parameter defined in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.4">
     * RFC 5280 4.1.2.4</a>.
     * <pre>
     * Name ::= CHOICE { -- only one possibility for now --
     *   rdnSequence  RDNSequence }
     * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
     * </pre>
     * @example
     * x = new X509();
     * x.getX500NameArray("30...") &rarr;
     * [[{type:"C",value:"US",ds:"prn"}],
     *  [{type:"O",value:"Sample Corp.",ds:"utf8"}],
     *  [{type:"CN",value:"john.smith@example.com",ds:"ia5"}]]
     */
    this.getX500NameArray = function(h) {
	var p = _ASN1HEX_parse(h);
	return _convX500Name(p);
    };

    /**
     * get Name ASN.1 structure parameter array<br/>
     * @name getX500Name
     * @memberOf X509#
     * @function
     * @param {String} h hexadecimal string of Name
     * @param {boolean} flagCanon flag to conclude canonicalized name (DEFAULT false)
     * @param {boolean} flagHex flag to conclude hexadecimal string (DEFAULT false)
     * @return {Array} array of RDN parameter array
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see X509#getX500NameArray
     * @see X509#getRDN
     * @see X509#getAttrTypeAndValue
     * @see X509#c14nRDNArray
     * @see KJUR.asn1.x509.X500Name
     * @see KJUR.asn1.x509.GeneralName
     * @see KJUR.asn1.x509.GeneralNames
     *
     * @description
     * This method will get Name parameter defined in
     * <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.4">
     * RFC 5280 4.1.2.4</a>.
     * <pre>
     * Name ::= CHOICE { -- only one possibility for now --
     *   rdnSequence  RDNSequence }
     * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
     * </pre>
     * <br>
     * NOTE: From jsrsasign 10.6.0, flagHex and flagCanon has been 
     * supported to conclude a canonicalized name for caseIgnoreMatch
     * desribed in <a href="https://tools.ietf.org/html/rfc4518">
     * RFC 4518</a>.
     *
     * @example
     * x = new X509();
     * x.getX500Name("30...") &rarr;
     * { array: [
     *     [{type:"C",value:"US",ds:"prn"}],
     *     [{type:"O",value:"Sample Corp.",ds:"utf8"}],
     *     [{type:"CN",value:"john.smith@example.com",ds:"ia5"}]
     *   ],
     *   str: "/C=US/O=Sample Corp./CN=john.smith@example.com",
     *   hex: "30..." }
     *
     * x.getX500Name("30...", true) &rarr;
     * { array: [
     *     [{type:"C",value:"US",ds:"prn"}],
     *     [{type:"O",value:"Sample    Corp.",ds:"utf8"}]
     *   ],
     *   str: "/C=US/O=Sample    Corp.",
     *   canon: "/c=us/o=sample corp.",
     *   hex: "30..." }
     */
    this.getX500Name = function(h, flagCanon, flagHex) {
	var a = this.getX500NameArray(h);
	var s = this.dnarraytostr(a);
	var result = { str: s };

	result.array = a;
	if (flagHex == true) result.hex = h;
	if (flagCanon == true) result.canon = this.c14nRDNArray(a);
	return result;
    };

    // ===== END X500Name related =====================================

    // ===== BEGIN read certificate =====================================
    /**
     * read PEM formatted X.509 certificate from string.<br/>
     * @name readCertPEM
     * @memberOf X509#
     * @function
     * @param {String} sCertPEM string for PEM formatted X.509 certificate
     * @example
     * x = new X509();
     * x.readCertPEM(sCertPEM); // read certificate
     */
    this.readCertPEM = function(sCertPEM) {
        this.readCertHex(_pemtohex(sCertPEM));
    };

    /**
     * read a hexadecimal string of X.509 certificate<br/>
     * @name readCertHex
     * @memberOf X509#
     * @function
     * @param {String} sCertHex hexadecimal string of X.509 certificate
     * @since jsrsasign 7.1.4 x509 1.1.13
     * @description
     * NOTE: {@link X509#parseExt} will called internally since jsrsasign 7.2.0.
     * @example
     * x = new X509();
     * x.readCertHex("3082..."); // read certificate
     */
    this.readCertHex = function(sCertHex) {
        this.hex = sCertHex;
	this.getVersion(); // set version parameter

	try {
	    _getIdxbyList(this.hex, 0, [0, 7], "a3"); // has [3] v3ext
	    this.parseExt();
	} catch(ex) {};
    };

    // ===== END read certificate =====================================

    /**
     * get JSON object of certificate parameters<br/>
     * @name getParam
     * @memberOf X509#
     * @function
     * @param {Object} option optional setting for return object
     * @return {Object} JSON object of certificate parameters
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see KJUR.asn1.x509.X509Util.newCertPEM
     *
     * @description
     * This method returns a JSON object of the certificate
     * parameters. Return value can be passed to
     * {@link KJUR.asn1.x509.X509Util.newCertPEM}.
     * <br/>
     * NOTE1: From jsrsasign 10.5.16, optional argument can be applied.
     * It can have following members:
     * <ul>
     * <li>tbshex - (boolean) tbshex member with hex value of 
     * tbsCertificate will be added if true (DEFAULT undefined)</li>
     * <li>nodnarray - (boolean) array member for subject and
     * issuer will be deleted to simplify it if true (DEFAULT undefined)<li>
     * <li>dncanon - (boolean) add canon member to subject and issuer for DN StringPrep if true(DEFAULT undefined)</li>
     * <li>dnhex - (boolean) add hex member to subject and issuer if true(DEFAULT undefined)</li>
     * </ul>
     * <br/>
     * NOTE2: From jsrsasign 10.6.0, member "dncanon" and "dnhex" supported
     * in the "option" argument.
     *
     * @example
     * x = new X509();
     * x.readCertPEM("-----BEGIN CERTIFICATE...");
     * x.getParam() &rarr;
     * {version:3,
     *  serial:{hex:"12ab"},
     *  sigalg:"SHA256withRSA",
     *  issuer: {array:[[{type:'CN',value:'CA1',ds:'prn'}]],str:"/O=CA1"},
     *  notbefore:"160403023700Z",
     *  notafter:"160702023700Z",
     *  subject: {array:[[{type:'CN',value:'Test1',ds:'prn'}]],str:"/CN=Test1"},
     *  sbjpubkey:"-----BEGIN PUBLIC KEY...",
     *  ext:[
     *   {extname:"keyUsage",critical:true,names:["digitalSignature"]},
     *   {extname:"basicConstraints",critical:true},
     *   {extname:"subjectKeyIdentifier",kid:{hex:"f2eb..."}},
     *   {extname:"authorityKeyIdentifier",kid:{hex:"12ab..."}},
     *   {extname:"authorityInfoAccess",array:[{ocsp:"http://ocsp.example.com/"}]},
     *   {extname:"certificatePolicies",array:[{policyoid:"2.23.140.1.2.1"}]}
     *  ],
     *  sighex:"0b76...8"
     * };
     *
     * x.getParam({tbshex: true}) &rarr; { ... , tbshex: "30..." }
     * x.getParam({nodnarray: true}) &rarr; {issuer: {str: "/C=JP"}, ...}
     * x.getParam({dncanon: true}) &rarr; {... {issuer: {canon: "/c=jp/o=..."} ...} ...}
     * x.getParam({dnhex: true}) &rarr; {... {issuer: {hex: "30..."} ...} ...}
     */
    this.getParam = function(option) {
	var result = {};
	if (option == undefined) option = {};

	result.version = this.getVersion();
	result.serial = {hex: this.getSerialNumberHex()};
	result.sigalg = this.getSignatureAlgorithmField();
	result.issuer = this.getIssuer(option.dncanon, option.dnhex);
	result.notbefore = this.getNotBefore();
	result.notafter = this.getNotAfter();
	result.subject = this.getSubject(option.dncanon, option.dnhex);
	result.sbjpubkey = hextopem(this.getPublicKeyHex(), "PUBLIC KEY");
	if (this.aExtInfo != undefined &&
	    this.aExtInfo.length > 0) {
	    result.ext = this.getExtParamArray();
	}
	result.sighex = this.getSignatureValueHex();

	// for options
	if (option.tbshex == true) {
	    result.tbshex = _getTLVbyList(this.hex, 0, [0]);
	}
	if (option.nodnarray == true) {
	    delete result.issuer.array;
	    delete result.subject.array;
	}

	return result;
    };

    /** 
     * get array of certificate extension parameter JSON object<br/>
     * @name getExtParamArray
     * @memberOf X509#
     * @function
     * @param {String} hExtSeq hexadecimal string of SEQUENCE of Extension
     * @return {Array} array of certificate extension parameter JSON object
     * @since jsrsasign 9.0.0 x509 2.0.0
     * @see KJUR.asn1.x509.X509Util.newCertPEM
     * @see X509#getParam
     * @see X509#getExtParam
     * @see X509CRL#getParam
     * @see KJUR.asn1.csr.CSRUtil.getParam
     *
     * @description
     * This method returns an array of certificate extension
     * parameters. 
     * <br/>
     * NOTE: Argument "hExtSeq" have been supported since jsrsasign 9.1.1.
     *
     * @example
     * x = new X509();
     * x.readCertPEM("-----BEGIN CERTIFICATE...");
     * x.getExtParamArray() &rarr;
     * [ {extname:"keyUsage",critical:true,names:["digitalSignature"]},
     *   {extname:"basicConstraints",critical:true},
     *   {extname:"subjectKeyIdentifier",kid:{hex:"f2eb..."}},
     *   {extname:"authorityKeyIdentifier",kid:{hex:"12ab..."}},
     *   {extname:"authorityInfoAccess",array:[{ocsp:"http://ocsp.example.com/"}]},
     *   {extname:"certificatePolicies",array:[{policyoid:"2.23.140.1.2.1"}]}]
     */
    this.getExtParamArray = function(hExtSeq) {
	if (hExtSeq == undefined) {
	    // for X.509v3 certificate
	    var idx1 = _getIdxbyListEx(this.hex, 0, [0, "[3]"]);
	    if (idx1 != -1) {
		hExtSeq = _getTLVbyListEx(this.hex, 0, [0, "[3]", 0], "30");
	    }
	}
	var result = [];
	var aIdx = _getChildIdx(hExtSeq, 0);

	for (var i = 0; i < aIdx.length; i++) {
	    var hExt = _getTLV(hExtSeq, aIdx[i]);
	    var extParam = this.getExtParam(hExt);
	    if (extParam != null) result.push(extParam);
	}

	return result;
    };

    /** 
     * get a extension parameter JSON object<br/>
     * @name getExtParam
     * @memberOf X509#
     * @function
     * @param {String} hExt hexadecimal string of Extension
     * @return {Array} Extension parameter JSON object
     * @since jsrsasign 9.1.1 x509 2.0.1
     * @see KJUR.asn1.x509.X509Util.newCertPEM
     * @see X509#getParam
     * @see X509#getExtParamArray
     * @see X509CRL#getParam
     * @see KJUR.asn1.csr.CSRUtil.getParam
     *
     * @description
     * This method returns a extension parameters as JSON object. 
     *
     * @example
     * x = new X509();
     * ...
     * x.getExtParam("30...") &rarr;
     * {extname:"keyUsage",critical:true,names:["digitalSignature"]}
     */
    this.getExtParam = function(hExt) {
	var result = {};
	var aIdx = _getChildIdx(hExt, 0);
	var aIdxLen = aIdx.length;
	if (aIdxLen != 2 && aIdxLen != 3)
	    throw new Error("wrong number elements in Extension: " + 
			    aIdxLen + " " + hExt);

	var oid = _hextooidstr(_getVbyList(hExt, 0, [0], "06"));

	var critical = false;
	if (aIdxLen == 3 && _getTLVbyList(hExt, 0, [1]) == "0101ff")
	    critical = true;

	var hExtV = _getTLVbyList(hExt, 0, [aIdxLen - 1, 0]);

	var extParam = undefined;
	if (oid == "2.5.29.14") {
	    extParam = this.getExtSubjectKeyIdentifier(hExtV, critical);
	} else if (oid == "2.5.29.15") {
	    extParam = this.getExtKeyUsage(hExtV, critical);
	} else if (oid == "2.5.29.17") {
	    extParam = this.getExtSubjectAltName(hExtV, critical);
	} else if (oid == "2.5.29.18") {
	    extParam = this.getExtIssuerAltName(hExtV, critical);
	} else if (oid == "2.5.29.19") {
	    extParam = this.getExtBasicConstraints(hExtV, critical);
	} else if (oid == "2.5.29.30") {
	    extParam = this.getExtNameConstraints(hExtV, critical);
	} else if (oid == "2.5.29.31") {
	    extParam = this.getExtCRLDistributionPoints(hExtV, critical);
	} else if (oid == "2.5.29.32") {
	    extParam = this.getExtCertificatePolicies(hExtV, critical);
	} else if (oid == "2.5.29.33") {
	    extParam = this.getExtPolicyMappings(hExtV, critical);
	} else if (oid == "2.5.29.35") {
	    extParam = this.getExtAuthorityKeyIdentifier(hExtV, critical);
	} else if (oid == "2.5.29.36") {
	    extParam = this.getExtPolicyConstraints(hExtV, critical);
	} else if (oid == "2.5.29.37") {
	    extParam = this.getExtExtKeyUsage(hExtV, critical);
	} else if (oid == "2.5.29.54") {
	    extParam = this.getExtInhibitAnyPolicy(hExtV, critical);
	} else if (oid == "1.3.6.1.5.5.7.1.1") {
	    extParam = this.getExtAuthorityInfoAccess(hExtV, critical);
	} else if (oid == "2.5.29.20") {
	    extParam = this.getExtCRLNumber(hExtV, critical);
	} else if (oid == "2.5.29.21") {
	    extParam = this.getExtCRLReason(hExtV, critical);
	} else if (oid == "2.5.29.9") {
	    extParam = this.getExtSubjectDirectoryAttributes(hExtV, critical);
	} else if (oid == "1.3.6.1.5.5.7.48.1.2") {
	    extParam = this.getExtOcspNonce(hExtV, critical);
	} else if (oid == "1.3.6.1.5.5.7.48.1.5") {
	    extParam = this.getExtOcspNoCheck(hExtV, critical);
	} else if (oid == "1.2.840.113583.1.1.9.1") {
	    extParam = this.getExtAdobeTimeStamp(hExtV, critical);
	} else if (X509.EXT_PARSER[oid] != undefined) {
	    extParam = X509.EXT_PARSER[oid](oid, critical, hExtV);
	}
	if (extParam != undefined) return extParam;

	// for private or unsupported extension
	var privateParam = { extname: oid, extn: hExtV };
	try {
	    privateParam.extn = _ASN1HEX_parse(hExtV);
	} catch(ex) {}
	if (critical) privateParam.critical = true;
	return privateParam;
    };

    /**
     * find extension parameter in array<br/>
     * @name findExt
     * @memberOf X509#
     * @function
     * @param {Array} aExt array of extension parameters
     * @param {String} extname extension name
     * @return {Array} extension parameter in the array or null
     * @since jsrsasign 10.0.3 x509 2.0.7
     * @see X509#getParam
     *
     * @description
     * This method returns an extension parameter for
     * specified extension name in the array.
     * This method is useful to update extension parameter value.
     * When there is no such extension with the extname,
     * this returns "null".
     *
     * @example
     * // (1) 
     * x = new X509(CERTPEM);
     * params = x.getParam();
     * pSKID = x.findExt(params.ext, "subjectKeyIdentifier");
     * pSKID.kid = "1234abced..."; // skid in the params is updated.
     *   // then params was updated
     *
     * // (2) another example
     * aExt = [
     *   {extname:"keyUsage",critical:true,names:["digitalSignature"]},
     *   {extname:"basicConstraints",critical:true},
     *   {extname:"subjectKeyIdentifier",kid:{hex:"f2eb..."}},
     *   {extname:"authorityKeyIdentifier",kid:{hex:"12ab..."}},
     *   {extname:"authorityInfoAccess",array:[{ocsp:"http://ocsp.example.com/"}]},
     *   {extname:"certificatePolicies",array:[{policyoid:"2.23.140.1.2.1"}]}
     * ];
     * var x = new X509();
     * x.findExt(aExt, "authorityKeyInfoAccess").array[0].ocsp = "http://aaa.com";
     * pKU = x.findExt(aExt, "keyUsage");
     * delete pKU["critical"]; // clear criticla flag
     * pKU.names = ["keyCertSign", "cRLSign"];
     *   // then aExt was updated
     */
    this.findExt = function(aExt, extname) {
	for (var i = 0; i < aExt.length; i++) {
	    if (aExt[i].extname == extname) return aExt[i];
	}
	return null;

    };

    /**
     * update CRLDistributionPoints Full URI in parameter<br/>
     * @name updateCDPFullURI
     * @memberOf X509#
     * @function
     * @param {Array} aExt array of extension parameters
     * @param {String} newURI string of new uri
     * @since jsrsasign 10.0.4 x509 2.0.8
     * @see X509#findExt
     * @see KJUR.asn1.x509.CRLDistributionPoints
     *
     * @description
     * This method updates Full URI of CRLDistributionPoints extension
     * in the extension parameter array if it exists.
     *
     * @example
     * aExt = [
     *   {extname:"authorityKeyIdentifier",kid:{hex:"12ab..."}},
     *   {extname:"cRLDistributionPoints",
     *    array:[{dpname:{full:[{uri:"http://example.com/a.crl"}]}}]},
     * ];
     * x = new X509();
     * x.updateCDPFullURI(aExt, "http://crl2.example.new/b.crl");
     */
    this.updateExtCDPFullURI = function(aExt, newURI) {
	var pExt = this.findExt(aExt, "cRLDistributionPoints");
	if (pExt == null) return;
	if (pExt.array == undefined) return;
	var aDP = pExt.array;
	for (var i = 0; i < aDP.length; i++) {
	    if (aDP[i].dpname == undefined) continue;
	    if (aDP[i].dpname.full == undefined) continue;
	    var aURI = aDP[i].dpname.full;
	    for (var j = 0; j < aURI.length; j++) {
		var pURI = aURI[i];
		if (pURI.uri == undefined) continue;
		pURI.uri = newURI;
	    }
	}
    };

    /**
     * update authorityInfoAccess ocsp in parameter<br/>
     * @name updateAIAOCSP
     * @memberOf X509#
     * @function
     * @param {Array} aExt array of extension parameters
     * @param {String} newURI string of new uri
     * @since jsrsasign 10.0.4 x509 2.0.8
     * @see X509#findExt
     * @see KJUR.asn1.x509.AuthorityInfoAccess
     *
     * @description
     * This method updates "ocsp" accessMethod URI of 
     * AuthorityInfoAccess extension
     * in the extension parameter array if it exists.
     *
     * @example
     * aExt = [
     *   {extname:"authorityKeyIdentifier",kid:{hex:"12ab..."}},
     *   {extname:"authoriyInfoAccess",
     *    array:[
     *      {ocsp: "http://ocsp1.example.com"},
     *      {caissuer: "http://example.com/a.crt"}
     *    ]}
     * ];
     * x = new X509();
     * x.updateAIAOCSP(aExt, "http://ocsp2.example.net");
     */
    this.updateExtAIAOCSP = function(aExt, newURI) {
	var pExt = this.findExt(aExt, "authorityInfoAccess");
	if (pExt == null) return;
	if (pExt.array == undefined) return;
	var a = pExt.array;
	for (var i = 0; i < a.length; i++) {
	    if (a[i].ocsp != undefined) a[i].ocsp = newURI;
	}
    };

    /**
     * update authorityInfoAccess caIssuer in parameter<br/>
     * @name updateAIACAIssuer
     * @memberOf X509#
     * @function
     * @param {Array} aExt array of extension parameters
     * @param {String} newURI string of new uri
     * @since jsrsasign 10.0.4 x509 2.0.8
     * @see X509#findExt
     * @see KJUR.asn1.x509.AuthorityInfoAccess
     *
     * @description
     * This method updates "caIssuer" accessMethod URI of 
     * AuthorityInfoAccess extension
     * in the extension parameter array if it exists.
     *
     * @example
     * aExt = [
     *   {extname:"authorityKeyIdentifier",kid:{hex:"12ab..."}},
     *   {extname:"authoriyInfoAccess",
     *    array:[
     *      {ocsp: "http://ocsp1.example.com"},
     *      {caissuer: "http://example.com/a.crt"}
     *    ]}
     * ];
     * x = new X509();
     * x.updateAIACAIssuer(aExt, "http://example.net/b.crt");
     */
    this.updateExtAIACAIssuer = function(aExt, newURI) {
	var pExt = this.findExt(aExt, "authorityInfoAccess");
	if (pExt == null) return;
	if (pExt.array == undefined) return;
	var a = pExt.array;
	for (var i = 0; i < a.length; i++) {
	    if (a[i].caissuer != undefined) a[i].caissuer = newURI;
	}
    };

    /**
     * convert array for X500 distinguish name to distinguish name string<br/>
     * @name dnarraytostr
     * @memberOf X509#
     * @function
     * @param {Array} aDN array for X500 distinguish name
     * @return {String} distinguish name
     * @since jsrsasign 10.0.6 x509 2.0.8
     * @see X509#getX500Name
     * @see X509#getX500NameArray
     * @see KJUR.asn1.x509.X500Name
     *
     * @description
     * This method converts from an array representation of 
     * X.500 distinguished name to X.500 name string.
     * This supports multi-valued RDN.
     * 
     * @example
     * var x = new X509();
     * x.dnarraytostr(
     *   [[{type:"C",value:"JP",ds:"prn"}],
     *   [{type:"O",value:"T1",ds:"prn"}]]) &rarr; "/C=JP/O=T1"
     * x.dnarraytostr(
     *   [[{type:"C",value:"JP",ds:"prn"}],
     *   [{type:"O",value:"T1",ds:"prn"}
     *    {type:"CN",value:"Bob",ds:"prn"}]]) &rarr; "/C=JP/O=T1+CN=Bob"
     */
    this.dnarraytostr = function(aDN) {
	function rdnarraytostr(aRDN) {
	    return aRDN.map(function(x){return atvtostr(x).replace(/\+/,"\\+");}).join("+");
	};

	function atvtostr(pATV) {
	    return pATV.type + "=" + pATV.value;
	};

	return "/" + aDN.map(function(x){return rdnarraytostr(x).replace(/\//, "\\/");}).join("/");
    };

    /**
     * set canonicalized DN to a DN parameter<br/>
     * @name setCanonicalizedDN
     * @memberOf X509#
     * @function
     * @param {object} pDN DN parameter associative array
     * @since jsrsasign 10.6.0 x509 2.1.0
     * 
     * @description
     * This method canonicalizes a DN string as following:
     * <ul>
     * <li>convert to lower case</li>
     * <li>convert from all multiple spaces to a space</li>
     * </ul>
     * 
     * @example
     * var x = new X509();
     * var pDN = {
     *   array: [
     *     [{type:'C',value:'JP',ds:'prn'}],
     *     [{type:'O',value:'Test    1',ds:'prn'}] ],
     *   str: "/C=JP/O=Test    1" };
     * x.setCanonicalizedDN(pDN);

     * // pDN will become following
     * pDN = {
     *   array: [
     *     [{type:'C',value:'JP',ds:'prn'}],
     *     [{type:'O',value:'Test    1',ds:'prn'}] ],
     *   str: "/C=JP/O=Test    1",
     *   canon: "/c=jp/o=test 1" };
     */
    this.setCanonicalizedDN = function(pDN) {
	var aRDN;
	if (pDN.str != undefined && pDN.array == undefined) {
	    var dDN = new KJUR.asn1.x509.X500Name({str: pDN.str});
	    var hDN = dDN.tohex();
	    aRDN = this.getX500NameArray(hDN);
	} else {
	    aRDN = pDN.array;
	}
	if (pDN.canon == undefined) {
	    pDN.canon = this.c14nRDNArray(aRDN);
	}
    };

    /**
     * simple canonicalization(c14n) for RDN array<br/>
     * @name c14nRDNArray
     * @memberOf X509#
     * @function
     * @param {array} aRDN array of RDN parameters
     * @return {string} canonicalized distinguish name (ex. "/c=jp/o=test ca")
     * @since jsrsasign 10.6.0 x509 2.1.0
     * 
     * @description
     * This method canonicalizes a DN string according to
     * <a href="https://datatracker.ietf.org/doc/html/rfc4518#appendix-B">
     * "RFC 4518 StringPrep Appendix B Substring Matching"</a> as following:
     * <ul>
     * <li>convert to lower case</li>
     * <li>convert from all sequence of spaces to a space</li>
     * <li>remove leading and trailing spaces</li>
     * </ul>
     * 
     * @example
     * var x = new X509();
     * x.c14nRDNArray([
     *   [{type:"C", value:"JP", ds: "prn"}],
     *   [{type:"O", value:"    Test    1234     ", ds: "utf8"}],
     *   [{type:"OU", value:"HR   45", ds: "utf8"}]
     * ]) &rarr; "/c=jp/o=test 1234/ou=hr 45"
     */
    this.c14nRDNArray = function(aRDN) {
	var a = [];
	for (var i = 0; i < aRDN.length; i++) {
	    var aAVA = aRDN[i];
	    var a2 = [];
	    for (var j = 0; j < aAVA.length; j++) {
		var pAVA = aAVA[j];
		var value = pAVA.value;
		value = value.replace(/^\s*/, '');
		value = value.replace(/\s*$/, '');
		value = value.replace(/\s+/g, ' ');
		value = value.toLowerCase();
		a2.push(pAVA.type.toLowerCase() + "=" + value);
	    }
	    a.push(a2.join("+"));
	}
	return "/" + a.join("/");
    };

    /**
     * get certificate information as string.<br/>
     * @name getInfo
     * @memberOf X509#
     * @function
     * @return {String} certificate information string
     * @since jsrsasign 5.0.10 x509 1.1.8
     * @example
     * x = new X509();
     * x.readCertPEM(certPEM);
     * console.log(x.getInfo());
     * // this shows as following
     * Basic Fields
     *   serial number: 02ac5c266a0b409b8f0b79f2ae462577
     *   signature algorithm: SHA1withRSA
     *   issuer: /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert High Assurance EV Root CA
     *   notBefore: 061110000000Z
     *   notAfter: 311110000000Z
     *   subject: /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert High Assurance EV Root CA
     *   subject public key info:
     *     key algorithm: RSA
     *     n=c6cce573e6fbd4bb...
     *     e=10001
     * X509v3 Extensions:
     *   keyUsage CRITICAL:
     *     digitalSignature,keyCertSign,cRLSign
     *   basicConstraints CRITICAL:
     *     cA=true
     *   subjectKeyIdentifier :
     *     b13ec36903f8bf4701d498261a0802ef63642bc3
     *   authorityKeyIdentifier :
     *     kid=b13ec36903f8bf4701d498261a0802ef63642bc3
     * signature algorithm: SHA1withRSA
     * signature: 1c1a0697dcd79c9f...
     */
    this.getInfo = function() {
	var _getSubjectAltNameStr = function(params) {
	    var s = "";
	    var indent = "    ";
	    var NL = "\n";
	    var a = params.array;
	    for (var i = 0; i < a.length; i++) {
		var pGN = a[i];
		if (pGN.dn != undefined)	s += indent + "dn: " + pGN.dn.str + NL;
		if (pGN.ip != undefined)	s += indent + "ip: " + pGN.ip + NL;
		if (pGN.rfc822 != undefined)	s += indent + "rfc822: " + pGN.rfc822 + NL;
		if (pGN.dns != undefined)	s += indent + "dns: " + pGN.dns + NL;
		if (pGN.uri != undefined)	s += indent + "uri: " + pGN.uri + NL;
		if (pGN.other != undefined) {
		    var oidname = pGN.other.oid;
		    var value = JSON.stringify(pGN.other.value).replace(/\"/g, '');
		    s += indent + "other: " + oidname + "=" + value + NL;
		}
	    }
	    s = s.replace(/\n$/, '');
	    return s;
	};
	var _getCertificatePoliciesStr = function(params) {
	    var s = "";
	    var a = params.array;
	    for (var i = 0; i < a.length; i++) {
		var pi = a[i];
		s += "    policy oid: " + pi.policyoid + "\n";
		if (pi.array === undefined) continue;
		for (var j = 0; j < pi.array.length; j++) {
		    var pqi = pi.array[j];
		    if (pqi.cps !== undefined) {
			s += "    cps: " + pqi.cps + "\n";
		    }
		}
	    }
	    return s;
	};
	var _getCRLDistributionPointsStr = function(params) {
	    var s = "";
	    var a = params.array;
	    for (var i = 0; i < a.length; i++) {
		var dp = a[i];
		try {
		    if (dp.dpname.full[0].uri !== undefined)
			s += "    " + dp.dpname.full[0].uri + "\n";
		} catch(ex) {};
		try {
		    if (dp.dname.full[0].dn.hex !== undefined)
			s += "    " + X509.hex2dn(dp.dpname.full[0].dn.hex) + "\n";
		} catch(ex) {};
	    }
	    return s;
	}
	var _getAuthorityInfoAccessStr = function(params) {
	    var s = "";
	    var a = params.array;
	    for (var i = 0; i < a.length; i++) {
		var ad = a[i];

		if (ad.caissuer !== undefined)
		    s += "    caissuer: " + ad.caissuer + "\n";
		if (ad.ocsp !== undefined)
		    s += "    ocsp: " + ad.ocsp + "\n";
	    }
	    return s;
	};
	var _X509 = X509;
	var s, pubkey, aExt;
	s  = "Basic Fields\n";
        s += "  serial number: " + this.getSerialNumberHex() + "\n";
	s += "  signature algorithm: " + this.getSignatureAlgorithmField() + "\n";
	s += "  issuer: " + this.getIssuerString() + "\n";
	s += "  notBefore: " + this.getNotBefore() + "\n";
	s += "  notAfter: " + this.getNotAfter() + "\n";
	s += "  subject: " + this.getSubjectString() + "\n";
	s += "  subject public key info: " + "\n";

	// subject public key info
	pubkey = this.getPublicKey();
	s += "    key algorithm: " + pubkey.type + "\n";

	if (pubkey.type === "RSA") {
	    s += "    n=" + hextoposhex(pubkey.n.toString(16)).substr(0, 16) + "...\n";
	    s += "    e=" + hextoposhex(pubkey.e.toString(16)) + "\n";
	}

	// X.509v3 Extensions
        aExt = this.aExtInfo;

	if (aExt !== undefined && aExt !== null) {
            s += "X509v3 Extensions:\n";
	    
            for (var i = 0; i < aExt.length; i++) {
		var info = aExt[i];

		// show extension name and critical flag
		var extName = KJUR.asn1.x509.OID.oid2name(info["oid"]);
		if (extName === '') extName = info["oid"];

		var critical = '';
		if (info["critical"] === true) critical = "CRITICAL";

		s += "  " + extName + " " + critical + ":\n";

		// show extension value if supported
		if (extName === "basicConstraints") {
		    var bc = this.getExtBasicConstraints();
		    if (bc.cA === undefined) {
			s += "    {}\n";
		    } else {
			s += "    cA=true";
			if (bc.pathLen !== undefined)
			    s += ", pathLen=" + bc.pathLen;
			s += "\n";
		    }
		} else if (extName == "policyMappings") {
		    var a = this.getExtPolicyMappings().array;
		    var sMap = a.map(function(item){
			var aPolicy = item;
			return aPolicy[0] + ":" + aPolicy[1];
		    }).join(", ");
		    s += "    " + sMap + "\n";
		} else if (extName == "policyConstraints") {
		    var p = this.getExtPolicyConstraints();
		    s += "    ";
		    if (p.reqexp != undefined) s += " reqexp=" + p.reqexp;
		    if (p.inhibit != undefined) s += " inhibit=" + p.inhibit;
		    s += "\n";
		} else if (extName == "inhibitAnyPolicy") {
		    var p = this.getExtInhibitAnyPolicy();
		    s += "    skip=" + p.skip + "\n";
		} else if (extName == "keyUsage") {
		    s += "    " + this.getExtKeyUsageString() + "\n";
		} else if (extName == "subjectKeyIdentifier") {
		    s += "    " + this.getExtSubjectKeyIdentifier().kid.hex + "\n";
		} else if (extName == "authorityKeyIdentifier") {
		    var akid = this.getExtAuthorityKeyIdentifier();
		    if (akid.kid !== undefined)
			s += "    kid=" + akid.kid.hex + "\n";
		} else if (extName == "extKeyUsage") {
		    var eku = this.getExtExtKeyUsage().array;
		    s += "    " + eku.join(", ") + "\n";
		} else if (extName == "subjectAltName") {
		    var san = _getSubjectAltNameStr(this.getExtSubjectAltName());
		    s += san + "\n";
		} else if (extName == "cRLDistributionPoints") {
		    var cdp = this.getExtCRLDistributionPoints();
		    s += _getCRLDistributionPointsStr(cdp);
		} else if (extName == "authorityInfoAccess") {
		    var aia = this.getExtAuthorityInfoAccess();
		    s += _getAuthorityInfoAccessStr(aia);
		} else if (extName == "certificatePolicies") {
		    s += _getCertificatePoliciesStr(this.getExtCertificatePolicies());
		}
	    }
        }

	s += "signature algorithm: " + this.getSignatureAlgorithmName() + "\n";
	s += "signature: " + this.getSignatureValueHex().substr(0, 16) + "...\n";
	return s;
    };

    if (typeof params == "string") {
	if (params.indexOf("-----BEGIN") != -1) {
	    this.readCertPEM(params);
	} else if (KJUR.lang.String.isHex(params)) {
	    this.readCertHex(params);
	}
    }
};
// ----- END of X509 class -----

/**
 * additional definition for X.509 extension parsers<br/>
 * @see X509.registExtParser
 */
X509.EXT_PARSER = {
};

/**
 * define X.509 extension parser for specified OID<br/>
 * @name registExtParser
 * @memberOf X509
 * @function
 * @param {string} oid extension OID string (ex. "1.2.3.4")
 * @param {function} func registering func extension value parsing function
 * @return unspecified
 * @since jsrsasign 10.7.0 x509 2.1.2
 * 
 * @description
 * <p>
 * This static method specifies a X.509 extension value parsing function
 * for specified an extension OID.
 * </p>
 * <p>
 * Extension parser function must have following three arguments:
 * <ul>
 * <li>{string} oid - OID for extension (ex. "1.2.3.4")</li>
 * <li>{boolean} critical - critical flag of extension</li>
 * <li>{string} hExtV - hexadecimal string of extension value</li>
 * </ul>
 * The funcition must return an associative array for the extension
 * when hExtV can be parsed properly. Otherwise it must return
 * value "undefined".
 * </p>
 *
 * @example
 * function _extparser1(oid, critical, hExtV) {
 *   try {
 *     var result = { extname: oid, value: ASN1HEX.parse(hExtV).utf8str.str };
 *     if (critical) result.critical = true;
 *     return result;
 *   } catch(ex) {
 *     return undefined;
 *   }
 * }
 * X509.registExtParser("1.2.3.4", _extparser1);
 */
X509.registExtParser = function(oid, func) {
    X509.EXT_PARSER[oid] = func;
};

/**
 * get distinguished name string in OpenSSL online format from hexadecimal string of ASN.1 DER X.500 name<br/>
 * @name hex2dn
 * @memberOf X509
 * @function
 * @param {String} hex hexadecimal string of ASN.1 DER distinguished name
 * @param {Integer} idx index of hexadecimal string (DEFAULT=0)
 * @return {String} OpenSSL online format distinguished name
 * @description
 * This static method converts from a hexadecimal string of 
 * distinguished name (DN)
 * specified by 'hex' and 'idx' to OpenSSL oneline string representation (ex. /C=US/O=a).
 * @example
 * X509.hex2dn("3031310b3...") &rarr; /C=US/O=a/CN=b2+OU=b1
 */
X509.hex2dn = function(hex, idx) {
    if (idx === undefined) idx = 0;
    var x = new X509();
    var hDN = ASN1HEX.getTLV(hex, idx);
    var pDN = x.getX500Name(hex);
    return pDN.str;
};

/**
 * get relative distinguished name string in OpenSSL online format from hexadecimal string of ASN.1 DER RDN<br/>
 * @name hex2rdn
 * @memberOf X509
 * @function
 * @param {String} hex hexadecimal string of ASN.1 DER concludes relative distinguished name
 * @param {Integer} idx index of hexadecimal string (DEFAULT=0)
 * @return {String} OpenSSL online format relative distinguished name
 * @description
 * This static method converts from a hexadecimal string of 
 * relative distinguished name (RDN)
 * specified by 'hex' and 'idx' to LDAP string representation (ex. O=test+CN=test).<br/>
 * NOTE: Multi-valued RDN is supported since jsnrsasign 6.2.2 x509 1.1.10.
 * @example
 * X509.hex2rdn("310a3008060355040a0c0161") &rarr; O=a
 * X509.hex2rdn("31143008060355040a0c01613008060355040a0c0162") &rarr; O=a+O=b
 */
X509.hex2rdn = function(hex, idx) {
    if (idx === undefined) idx = 0;
    if (hex.substr(idx, 2) !== "31") throw new Error("malformed RDN");

    var a = new Array();

    var aIdx = ASN1HEX.getChildIdx(hex, idx);
    for (var i = 0; i < aIdx.length; i++) {
	a.push(X509.hex2attrTypeValue(hex, aIdx[i]));
    }

    a = a.map(function(s) { return s.replace("+", "\\+"); });
    return a.join("+");
};

/**
 * get string from hexadecimal string of ASN.1 DER AttributeTypeAndValue<br/>
 * @name hex2attrTypeValue
 * @memberOf X509
 * @function
 * @param {String} hex hexadecimal string of ASN.1 DER concludes AttributeTypeAndValue
 * @param {Integer} idx index of hexadecimal string (DEFAULT=0)
 * @return {String} string representation of AttributeTypeAndValue (ex. C=US)
 * @description
 * This static method converts from a hexadecimal string of AttributeTypeAndValue
 * specified by 'hex' and 'idx' to LDAP string representation (ex. C=US).
 * @example
 * X509.hex2attrTypeValue("3008060355040a0c0161") &rarr; O=a
 * X509.hex2attrTypeValue("300806035504060c0161") &rarr; C=a
 * X509.hex2attrTypeValue("...3008060355040a0c0161...", 128) &rarr; O=a
 */
X509.hex2attrTypeValue = function(hex, idx) {
    var _ASN1HEX = ASN1HEX;
    var _getV = _ASN1HEX.getV;

    if (idx === undefined) idx = 0;
    if (hex.substr(idx, 2) !== "30") 
	throw new Error("malformed attribute type and value");

    var aIdx = _ASN1HEX.getChildIdx(hex, idx);
    if (aIdx.length !== 2 || hex.substr(aIdx[0], 2) !== "06")
	"malformed attribute type and value";

    var oidHex = _getV(hex, aIdx[0]);
    var oidInt = KJUR.asn1.ASN1Util.oidHexToInt(oidHex);
    var atype = KJUR.asn1.x509.OID.oid2atype(oidInt);

    var hV = _getV(hex, aIdx[1]);
    var rawV = hextorstr(hV);

    return atype + "=" + rawV;
};

/**
 * get RSA/DSA/ECDSA public key object from X.509 certificate hexadecimal string<br/>
 * @name getPublicKeyFromCertHex
 * @memberOf X509
 * @function
 * @param {String} h hexadecimal string of X.509 certificate for RSA/ECDSA/DSA public key
 * @return returns RSAKey/KJUR.crypto.{ECDSA,DSA} object of public key
 * @since jsrasign 7.1.0 x509 1.1.11
 */
X509.getPublicKeyFromCertHex = function(h) {
    var x = new X509();
    x.readCertHex(h);
    return x.getPublicKey();
};

/**
 * get RSA/DSA/ECDSA public key object from PEM certificate string
 * @name getPublicKeyFromCertPEM
 * @memberOf X509
 * @function
 * @param {String} sCertPEM PEM formatted RSA/ECDSA/DSA X.509 certificate
 * @return returns RSAKey/KJUR.crypto.{ECDSA,DSA} object of public key
 * @since x509 1.1.1
 * @description
 * NOTE: DSA is also supported since x509 1.1.2.
 */
X509.getPublicKeyFromCertPEM = function(sCertPEM) {
    var x = new X509();
    x.readCertPEM(sCertPEM);
    return x.getPublicKey();
};

/**
 * get public key information from PEM certificate
 * @name getPublicKeyInfoPropOfCertPEM
 * @memberOf X509
 * @function
 * @param {String} sCertPEM string of PEM formatted certificate
 * @return {Hash} hash of information for public key
 * @since x509 1.1.1
 * @description
 * Resulted associative array has following properties:<br/>
 * <ul>
 * <li>algoid - hexadecimal string of OID of asymmetric key algorithm</li>
 * <li>algparam - hexadecimal string of OID of ECC curve name or null</li>
 * <li>keyhex - hexadecimal string of key in the certificate</li>
 * </ul>
 * NOTE: X509v1 certificate is also supported since x509.js 1.1.9.
 */
X509.getPublicKeyInfoPropOfCertPEM = function(sCertPEM) {
    var _ASN1HEX = ASN1HEX;
    var _getVbyList = _ASN1HEX.getVbyList;

    var result = {};
    var x, hSPKI, pubkey;
    result.algparam = null;

    x = new X509();
    x.readCertPEM(sCertPEM);

    hSPKI = x.getPublicKeyHex();
    result.keyhex = _getVbyList(hSPKI, 0, [1], "03").substr(2);
    result.algoid = _getVbyList(hSPKI, 0, [0, 0], "06");

    if (result.algoid === "2a8648ce3d0201") { // ecPublicKey
	result.algparam = _getVbyList(hSPKI, 0, [0, 1], "06");
    };

    return result;
};

/* ======================================================================
 *   Specific V3 Extensions
 * ====================================================================== */

X509.KEYUSAGE_NAME = [
    "digitalSignature",
    "nonRepudiation",
    "keyEncipherment",
    "dataEncipherment",
    "keyAgreement",
    "keyCertSign",
    "cRLSign",
    "encipherOnly",
    "decipherOnly"
];

/* jws-3.3.12 (c) 2013-2022 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * jws.js - JSON Web Signature(JWS) and JSON Web Token(JWT) Class
 *
 * Copyright (c) 2010-2022 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license/
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name jws-3.3.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.5.25 jws 3.3.12 (2022-Jun-23)
 * @since jsjws 1.0, jsrsasign 4.8.0
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

if (typeof KJUR == "undefined" || !KJUR) KJUR = {};

/**
 * kjur's JSON Web Signature/Token(JWS/JWT) library name space
 * <p>
 * This namespace privides following JWS/JWS related classes.
 * <ul>
 * <li>{@link KJUR.jws.JWS} - JSON Web Signature/Token(JWS/JWT) class</li>
 * <li>{@link KJUR.jws.JWSJS} - JWS JSON Serialization(JWSJS) class</li>
 * <li>{@link KJUR.jws.IntDate} - UNIX origin time utility class</li>
 * </ul>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * </p>
 * @name KJUR.jws
 * @namespace
 */
if (typeof KJUR.jws == "undefined" || !KJUR.jws) KJUR.jws = {};

/**
 * JSON Web Signature(JWS) class.<br/>
 * @name KJUR.jws.JWS
 * @class JSON Web Signature(JWS) class
 * @see <a href="https://kjur.github.io/jsjws/">'jwjws'(JWS JavaScript Library) home page https://kjur.github.io/jsjws/</a>
 * @see <a href="https://kjur.github.io/jsrsasigns/">'jwrsasign'(RSA Sign JavaScript Library) home page https://kjur.github.io/jsrsasign/</a>
 * @see <a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-14">IETF I-D JSON Web Algorithms (JWA)</a>
 * @since jsjws 1.0
 * @description
 * This class provides JSON Web Signature(JWS)/JSON Web Token(JWT) signing and validation.
 *
 * <h4>METHOD SUMMARY</h4>
 * Here is major methods of {@link KJUR.jws.JWS} class.
 * <ul>
 * <li><b>SIGN</b><br/>
 * <li>{@link KJUR.jws.JWS.sign} - sign JWS</li>
 * </li>
 * <li><b>VERIFY</b><br/>
 * <li>{@link KJUR.jws.JWS.verify} - verify JWS signature</li>
 * <li>{@link KJUR.jws.JWS.verifyJWT} - verify properties of JWT token at specified time</li>
 * </li>
 * <li><b>UTILITY</b><br/>
 * <li>{@link KJUR.jws.JWS.getJWKthumbprint} - get RFC 7638 JWK thumbprint</li>
 * <li>{@link KJUR.jws.JWS.isSafeJSONString} - check whether safe JSON string or not</li>
 * <li>{@link KJUR.jws.JWS.readSafeJSONString} - read safe JSON string only</li>
 * </li>
 * </ul> 
 *
 * <h4>SUPPORTED SIGNATURE ALGORITHMS</h4>
 * Here is supported algorithm names for {@link KJUR.jws.JWS.sign} and
 * {@link KJUR.jws.JWS.verify} methods.
 * <table>
 * <tr><th>alg value</th><th>spec requirement</th><th>jsjws support</th></tr>
 * <tr><td>HS256</td><td>REQUIRED</td><td>SUPPORTED</td></tr>
 * <tr><td>HS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>HS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>RS256</td><td>RECOMMENDED</td><td>SUPPORTED</td></tr>
 * <tr><td>RS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>RS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>ES256</td><td>RECOMMENDED+</td><td>SUPPORTED</td></tr>
 * <tr><td>ES384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>ES512</td><td>OPTIONAL</td><td>-</td></tr>
 * <tr><td>PS256</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>PS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>PS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>none</td><td>REQUIRED</td><td>SUPPORTED(signature generation only)</td></tr>
 * </table>
 * <dl>
 * <dt><b>NOTE1</b>
 * <dd>HS384 is supported since jsjws 3.0.2 with jsrsasign 4.1.4.
 * <dt><b>NOTE2</b>
 * <dd>Some deprecated methods have been removed since jws 3.3 of jsrsasign 4.10.0.
 * Removed methods are following:
 * <ul>
 * <li>JWS.verifyJWSByNE</li>
 * <li>JWS.verifyJWSByKey</li>
 * <li>JWS.generateJWSByNED</li>
 * <li>JWS.generateJWSByKey</li>
 * <li>JWS.generateJWSByP1PrvKey</li>
 * </ul>
 * </dl>
 * <b>EXAMPLE</b><br/>
 * @example
 * // JWS signing 
 * sJWS = KJUR.jws.JWS.sign(null, '{"alg":"HS256", "cty":"JWT"}', '{"age": 21}', {"utf8": "password"});
 * // JWS validation
 * isValid = KJUR.jws.JWS.verify('eyJjdHkiOiJKV1QiLCJhbGc...', {"utf8": "password"});
 * // JWT validation
 * isValid = KJUR.jws.JWS.verifyJWT('eyJh...', {"utf8": "password"}, {
 *   alg: ['HS256', 'HS384'],
 *   iss: ['http://foo.com']
 * });
 */
KJUR.jws.JWS = function() {
    var _KJUR = KJUR,
	_KJUR_jws_JWS = _KJUR.jws.JWS,
	_isSafeJSONString = _KJUR_jws_JWS.isSafeJSONString;

    // === utility =============================================================

    /**
     * parse JWS string and set public property 'parsedJWS' dictionary.<br/>
     * @name parseJWS
     * @memberOf KJUR.jws.JWS
     * @function
     * @param {String} sJWS JWS signature string to be parsed.
     * @throws if sJWS is not comma separated string such like "Header.Payload.Signature".
     * @throws if JWS Header is a malformed JSON string.
     * @since jws 1.1
     */
    this.parseJWS = function(sJWS, sigValNotNeeded) {
	if ((this.parsedJWS !== undefined) &&
	    (sigValNotNeeded || (this.parsedJWS.sigvalH !== undefined))) {
	    return;
	}
	var matchResult = sJWS.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);
	if (matchResult == null) {
	    throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
	}
	var b6Head = matchResult[1];
	var b6Payload = matchResult[2];
	var b6SigVal = matchResult[3];
	var sSI = b6Head + "." + b6Payload;
	this.parsedJWS = {};
	this.parsedJWS.headB64U = b6Head;
	this.parsedJWS.payloadB64U = b6Payload;
	this.parsedJWS.sigvalB64U = b6SigVal;
	this.parsedJWS.si = sSI;

	if (!sigValNotNeeded) {
	    var hSigVal = b64utohex(b6SigVal);
	    var biSigVal = parseBigInt(hSigVal, 16);
	    this.parsedJWS.sigvalH = hSigVal;
	    this.parsedJWS.sigvalBI = biSigVal;
	}

	var sHead = b64utoutf8(b6Head);
	var sPayload = b64utoutf8(b6Payload);
	this.parsedJWS.headS = sHead;
	this.parsedJWS.payloadS = sPayload;

	if (! _isSafeJSONString(sHead, this.parsedJWS, 'headP'))
	    throw "malformed JSON string for JWS Head: " + sHead;
    };
};

// === major static method ========================================================

/**
 * generate JWS signature by specified key<br/>
 * @name sign
 * @memberOf KJUR.jws.JWS
 * @function
 * @static
 * @param {String} alg JWS algorithm name to sign and force set to sHead or null 
 * @param {String} spHead string or object of JWS Header
 * @param {String} spPayload string or object of JWS Payload
 * @param {String} key string of private key or mac key object to sign
 * @param {String} pass (OPTION)passcode to use encrypted asymmetric private key 
 * @return {String} JWS signature string
 * @since jws 3.0.0
 * @see <a href="https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html">jsrsasign KJUR.crypto.Signature method</a>
 * @see <a href="https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Mac.html">jsrsasign KJUR.crypto.Mac method</a>
 * @description
 * This method supports following algorithms.
 * <table>
 * <tr><th>alg value</th><th>spec requirement</th><th>jsjws support</th></tr>
 * <tr><td>HS256</td><td>REQUIRED</td><td>SUPPORTED</td></tr>
 * <tr><td>HS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>HS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>RS256</td><td>RECOMMENDED</td><td>SUPPORTED</td></tr>
 * <tr><td>RS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>RS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>ES256</td><td>RECOMMENDED+</td><td>SUPPORTED</td></tr>
 * <tr><td>ES384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>ES512</td><td>OPTIONAL</td><td>-</td></tr>
 * <tr><td>PS256</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>PS384</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>PS512</td><td>OPTIONAL</td><td>SUPPORTED</td></tr>
 * <tr><td>none</td><td>REQUIRED</td><td>SUPPORTED(signature generation only)</td></tr>
 * </table>
 * <dl>
 * <dt>NOTE1:
 * <dd>salt length of RSAPSS signature is the same as the hash algorithm length
 * because of <a href="http://www.ietf.org/mail-archive/web/jose/current/msg02901.html">IETF JOSE ML discussion</a>.
 * <dt>NOTE2:
 * <dd>To support HS384, patched version of CryptoJS is used.
 * <a href="https://code.google.com/p/crypto-js/issues/detail?id=84">See here for detail</a>.
 * <dt>NOTE3:
 * From jsrsasign 4.10.0 jws 3.3.0, Way to provide password
 * for HS* algorithm is changed. The 'key' attribute value is
 * passed to {@link KJUR.crypto.Mac.setPassword} so please see
 * {@link KJUR.crypto.Mac.setPassword} for detail.
 * As for backword compatibility, if key is a string, has even length and
 * 0..9, A-F or a-f characters, key string is treated as a hexadecimal
 * otherwise it is treated as a raw string.
 * <dd>
 * </dl>
 * <b>EXAMPLE</b><br/>
 * @example
 * // sign HS256 signature with password "aaa" implicitly handled as string
 * sJWS = KJUR.jws.JWS.sign(null, {alg: "HS256", cty: "JWT"}, {age: 21}, "aaa");
 * // sign HS256 signature with password "6161" implicitly handled as hex
 * sJWS = KJUR.jws.JWS.sign(null, {alg: "HS256", cty: "JWT"}, {age: 21}, "6161");
 * // sign HS256 signature with base64 password
 * sJWS = KJUR.jws.JWS.sign(null, {alg: "HS256"}, {age: 21}, {b64: "Mi/8..a="});
 * // sign RS256 signature with PKCS#8 PEM RSA private key
 * sJWS = KJUR.jws.JWS.sign(null, {alg: "RS256"}, {age: 21}, "-----BEGIN PRIVATE KEY...");
 * // sign RS256 signature with PKCS#8 PEM ECC private key with passcode
 * sJWS = KJUR.jws.JWS.sign(null, {alg: "ES256"}, {age: 21}, 
 *                          "-----BEGIN PRIVATE KEY...", "keypass");
 * // header and payload can be passed by both string and object
 * sJWS = KJUR.jws.JWS.sign(null, '{alg:"HS256",cty:"JWT"}', '{age:21}', "aaa");
 */
KJUR.jws.JWS.sign = function(alg, spHeader, spPayload, key, pass) {
    var _KJUR = KJUR,
	_KJUR_jws = _KJUR.jws,
	_KJUR_jws_JWS = _KJUR_jws.JWS,
	_readSafeJSONString = _KJUR_jws_JWS.readSafeJSONString,
	_isSafeJSONString = _KJUR_jws_JWS.isSafeJSONString,
	_KJUR_crypto = _KJUR.crypto,
	_ECDSA = _KJUR_crypto.ECDSA,
	_Mac = _KJUR_crypto.Mac,
	_Signature = _KJUR_crypto.Signature,
	_JSON = JSON;

    var sHeader, pHeader, sPayload;

    // 1. check signatureInput(Header, Payload) is string or object
    if (typeof spHeader != 'string' && typeof spHeader != 'object')
	throw "spHeader must be JSON string or object: " + spHeader;

    if (typeof spHeader == 'object') {
	pHeader = spHeader;
	sHeader = _JSON.stringify(pHeader);
    }

    if (typeof spHeader == 'string') {
	sHeader = spHeader;
	if (! _isSafeJSONString(sHeader))
	    throw "JWS Head is not safe JSON string: " + sHeader;
	pHeader = _readSafeJSONString(sHeader);

    }

    sPayload = spPayload;
    if (typeof spPayload == 'object') sPayload = _JSON.stringify(spPayload);

    // 2. use alg if defined in sHeader
    if ((alg == '' || alg == null) &&
	pHeader['alg'] !== undefined) {
	alg = pHeader['alg'];
    }

    // 3. update sHeader to add alg if alg undefined
    if ((alg != '' && alg != null) &&
	pHeader['alg'] === undefined) {
	pHeader['alg'] = alg;
	sHeader = _JSON.stringify(pHeader);
    }

    // 4. check explicit algorithm doesn't match with JWS header.
    if (alg !== pHeader.alg)
	throw "alg and sHeader.alg doesn't match: " + alg + "!=" + pHeader.alg;

    // 5. set signature algorithm like SHA1withRSA
    var sigAlg = null;
    if (_KJUR_jws_JWS.jwsalg2sigalg[alg] === undefined) {
	throw "unsupported alg name: " + alg;
    } else {
	sigAlg = _KJUR_jws_JWS.jwsalg2sigalg[alg];
    }
    
    var uHeader = utf8tob64u(sHeader);
    var uPayload = utf8tob64u(sPayload);
    var uSignatureInput = uHeader + "." + uPayload
    // 6. sign
    var hSig = "";
    if (sigAlg.substr(0, 4) == "Hmac") {
	if (key === undefined)
	    throw "mac key shall be specified for HS* alg";
	//alert("sigAlg=" + sigAlg);
	var mac = new _Mac({'alg': sigAlg, 'prov': 'cryptojs', 'pass': key});
	mac.updateString(uSignatureInput);
	hSig = mac.doFinal();
    } else if (sigAlg.indexOf("withECDSA") != -1) {
	var sig = new _Signature({'alg': sigAlg});
	sig.init(key, pass);
	sig.updateString(uSignatureInput);
	var hASN1Sig = sig.sign();
	hSig = KJUR.crypto.ECDSA.asn1SigToConcatSig(hASN1Sig);
    } else if (sigAlg != "none") {
	var sig = new _Signature({'alg': sigAlg});
	sig.init(key, pass);
	sig.updateString(uSignatureInput);
	hSig = sig.sign();
    }

    var uSig = hextob64u(hSig);
    return uSignatureInput + "." + uSig;
};

/**
 * verify JWS signature by specified key or certificate<br/>
 * @name verify
 * @memberOf KJUR.jws.JWS
 * @function
 * @static
 * @param {String} sJWS string of JWS signature to verify
 * @param {Object} key string of public key, certificate or key object to verify
 * @param {String} acceptAlgs array of algorithm name strings (OPTION)
 * @return {Boolean} true if the signature is valid otherwise false including no signature case or without head and payload
 * @since jws 3.0.0
 * @see <a href="https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html">jsrsasign KJUR.crypto.Signature method</a>
 * @see <a href="https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Mac.html">jsrsasign KJUR.crypto.Mac method</a>
 * @description
 * <p>
 * This method verifies a JSON Web Signature Compact Serialization string by the validation 
 * algorithm as described in 
 * <a href="http://self-issued.info/docs/draft-jones-json-web-signature-04.html#anchor5">
 * the section 5 of Internet Draft draft-jones-json-web-signature-04.</a>
 * </p>
 * <p>
 * Since 3.2.0 strict key checking has been provided against a JWS algorithm
 * in a JWS header.
 * <ul>
 * <li>In case 'alg' is 'HS*' in the JWS header,
 * 'key' shall be hexadecimal string for Hmac{256,384,512} shared secret key.
 * Otherwise it raise an error.</li>
 * <li>In case 'alg' is 'RS*' or 'PS*' in the JWS header,
 * 'key' shall be a RSAKey object or a PEM string of
 * X.509 RSA public key certificate or PKCS#8 RSA public key.
 * Otherwise it raise an error.</li>
 * <li>In case 'alg' is 'ES*' in the JWS header,
 * 'key' shall be a KJUR.crypto.ECDSA object or a PEM string of
 * X.509 ECC public key certificate or PKCS#8 ECC public key.
 * Otherwise it raise an error.</li>
 * <li>In case 'alg' is 'none' in the JWS header,
 * validation not supported after jsjws 3.1.0.</li>
 * </ul>
 * </p>
 * <p>
 * NOTE1: The argument 'acceptAlgs' is supported since 3.2.0.
 * Strongly recommended to provide acceptAlgs to mitigate
 * signature replacement attacks.<br/>
 * </p>
 * <p>
 * NOTE2: From jsrsasign 4.9.0 jws 3.2.5, Way to provide password
 * for HS* algorithm is changed. The 'key' attribute value is
 * passed to {@link KJUR.crypto.Mac.setPassword} so please see
 * {@link KJUR.crypto.Mac.setPassword} for detail.
 * As for backword compatibility, if key is a string, has even length and
 * 0..9, A-F or a-f characters, key string is treated as a hexadecimal
 * otherwise it is treated as a raw string.
 * </p>
 * @example
 * // 1) verify a RS256 JWS signature by a certificate string.
 * isValid = KJUR.jws.JWS.verify('eyJh...', '-----BEGIN...', ['RS256']);
 * 
 * // 2) verify a HS256 JWS signature by a certificate string.
 * isValid = KJUR.jws.JWS.verify('eyJh...', {hex: '6f62ad...'}, ['HS256']);
 * isValid = KJUR.jws.JWS.verify('eyJh...', {b64: 'Mi/ab8...a=='}, ['HS256']);
 * isValid = KJUR.jws.JWS.verify('eyJh...', {utf8: 'Secret'}, ['HS256']);
 * isValid = KJUR.jws.JWS.verify('eyJh...', '6f62ad', ['HS256']); // implicit hex
 * isValid = KJUR.jws.JWS.verify('eyJh...', '6f62ada', ['HS256']); // implicit raw string
 *
 * // 3) verify a ES256 JWS signature by a KJUR.crypto.ECDSA key object.
 * var pubkey = KEYUTIL.getKey('-----BEGIN CERT...');
 * var isValid = KJUR.jws.JWS.verify('eyJh...', pubkey);
 */
KJUR.jws.JWS.verify = function(sJWS, key, acceptAlgs) {
    var _KJUR = KJUR,
	_KJUR_jws = _KJUR.jws,
	_KJUR_jws_JWS = _KJUR_jws.JWS,
	_readSafeJSONString = _KJUR_jws_JWS.readSafeJSONString,
	_KJUR_crypto = _KJUR.crypto,
	_ECDSA = _KJUR_crypto.ECDSA,
	_Mac = _KJUR_crypto.Mac,
	_Signature = _KJUR_crypto.Signature,
	_RSAKey;
    
    if (typeof RSAKey !== undefined) _RSAKey = RSAKey;

    // 0. checking dot concatinatd Base64URL encoded string
    if (! isBase64URLDot(sJWS)) return false;

    var a = sJWS.split(".");
    if (a.length !== 3) return false;

    var uHeader = a[0];
    var uPayload = a[1];
    var uSignatureInput = uHeader + "." + uPayload;
    var hSig = b64utohex(a[2]);

    // 1. parse JWS header
    var pHeader = _readSafeJSONString(b64utoutf8(a[0]));
    var alg = null;
    var algType = null; // HS|RS|PS|ES|no
    if (pHeader.alg === undefined) {
	throw "algorithm not specified in header";
    } else {
	alg = pHeader.alg;
	algType = alg.substr(0, 2);
    }

    // 2. check whether alg is acceptable algorithms
    if (acceptAlgs != null &&
        Object.prototype.toString.call(acceptAlgs) === '[object Array]' &&
        acceptAlgs.length > 0) {
	var acceptAlgStr = ":" + acceptAlgs.join(":") + ":";
	if (acceptAlgStr.indexOf(":" + alg + ":") == -1) {
	    throw "algorithm '" + alg + "' not accepted in the list";
	}
    }

    // 3. check whether key is a proper key for alg.
    if (alg != "none" && key === null) {
	throw "key shall be specified to verify.";
    }

    // 3.1. There is no key check for HS* because Mac will check it.
    //      since jsrsasign 5.0.0.

    // 3.2. convert key object if key is a public key or cert PEM string
    if (typeof key == "string" &&
	key.indexOf("-----BEGIN ") != -1) {
	key = KEYUTIL.getKey(key);
    }

    // 3.3. check whether key is RSAKey obj if alg is RS* or PS*.
    if (algType == "RS" || algType == "PS") {
	if (!(key instanceof _RSAKey)) {
	    throw "key shall be a RSAKey obj for RS* and PS* algs";
	}
    }

    // 3.4. check whether key is ECDSA obj if alg is ES*.
    if (algType == "ES") {
	if (!(key instanceof _ECDSA)) {
	    throw "key shall be a ECDSA obj for ES* algs";
	}
    }

    // 3.5. check when alg is 'none'
    if (alg == "none") {
    }

    // 4. check whether alg is supported alg in jsjws.
    var sigAlg = null;
    if (_KJUR_jws_JWS.jwsalg2sigalg[pHeader.alg] === undefined) {
	throw "unsupported alg name: " + alg;
    } else {
	sigAlg = _KJUR_jws_JWS.jwsalg2sigalg[alg];
    }

    // 5. verify
    if (sigAlg == "none") {
        throw "not supported";
    } else if (sigAlg.substr(0, 4) == "Hmac") {
	var hSig2 = null;
	if (key === undefined)
	    throw "hexadecimal key shall be specified for HMAC";
	//try {
	    var mac = new _Mac({'alg': sigAlg, 'pass': key});
	    mac.updateString(uSignatureInput);
	    hSig2 = mac.doFinal();
	//} catch(ex) {};
	return hSig == hSig2;
    } else if (sigAlg.indexOf("withECDSA") != -1) {
	var hASN1Sig = null;
        try {
	    hASN1Sig = _ECDSA.concatSigToASN1Sig(hSig);
	} catch (ex) {
	    return false;
	}
	var sig = new _Signature({'alg': sigAlg});
	sig.init(key)
	sig.updateString(uSignatureInput);
	return sig.verify(hASN1Sig);
    } else {
	var sig = new _Signature({'alg': sigAlg});
	sig.init(key)
	sig.updateString(uSignatureInput);
	return sig.verify(hSig);
    }
};

/**
 * parse header and payload of JWS signature<br/>
 * @name parse
 * @memberOf KJUR.jws.JWS
 * @function
 * @static
 * @param {String} sJWS string of JWS signature to parse
 * @return {Array} associative array of parsed header and payload. See below.
 * @throws if sJWS is malformed JWS signature
 * @since jws 3.3.3
 * @description
 * This method parses JWS signature string. 
 * Resulted associative array has following properties:
 * <ul>
 * <li>headerObj - JSON object of header</li>
 * <li>payloadObj - JSON object of payload if payload is JSON string otherwise undefined</li>
 * <li>headerPP - pretty printed JSON header by stringify</li>
 * <li>payloadPP - pretty printed JSON payload by stringify if payload is JSON otherwise Base64URL decoded raw string of payload</li>
 * <li>sigHex - hexadecimal string of signature</li>
 * </ul>
 * @example
 * KJUR.jws.JWS.parse(sJWS) ->
 * { 
 *   headerObj: {"alg": "RS256", "typ": "JWS"},
 *   payloadObj: {"product": "orange", "quantity": 100},
 *   headerPP: 
 *   '{
 *     "alg": "RS256",
 *     "typ": "JWS"
 *   }',
 *   payloadPP: 
 *   '{
 *     "product": "orange",
 *     "quantity": 100
 *   }',
 *   sigHex: "91f3cd..." 
 * }
 */
KJUR.jws.JWS.parse = function(sJWS) {
    var a = sJWS.split(".");
    var result = {};
    var uHeader, uPayload, uSig;
    if (a.length != 2 && a.length != 3)
	throw "malformed sJWS: wrong number of '.' splitted elements";

    uHeader = a[0];
    uPayload = a[1];
    if (a.length == 3) uSig = a[2]; 

    result.headerObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(uHeader));
    result.payloadObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(uPayload));

    result.headerPP = JSON.stringify(result.headerObj, null, "  ");
    if (result.payloadObj == null) {
	result.payloadPP = b64utoutf8(uPayload);
    } else {
	result.payloadPP = JSON.stringify(result.payloadObj, null, "  ");
    }

    if (uSig !== undefined) {
	result.sigHex = b64utohex(uSig);
    }

    return result;
};

/**
 * @name verifyJWT
 * @memberOf KJUR.jws.JWS
 * @function
 * @static
 * @param {String} sJWT string of JSON Web Token(JWT) to verify
 * @param {Object} key string of public key, certificate or key object to verify
 * @param {Array} acceptField associative array of acceptable fields (OPTION)
 * @return {Boolean} true if the JWT token is valid otherwise false
 * @since jws 3.2.3 jsrsasign 4.8.0
 *
 * @description
 * This method verifies a
 * <a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a> 
 * JSON Web Token(JWT).
 * It will verify following:
 * <ul>
 * <li>Header.alg
 * <ul>
 * <li>alg is specified in JWT header.</li>
 * <li>alg is included in acceptField.alg array. (MANDATORY)</li>
 * <li>alg is proper for key.</li>
 * </ul>
 * </li>
 * <li>Payload.iss (issuer) - Payload.iss is included in acceptField.iss array if specified. (OPTION)</li>
 * <li>Payload.sub (subject) - Payload.sub is included in acceptField.sub array if specified. (OPTION)</li>
 * <li>Payload.aud (audience) - Payload.aud is included in acceptField.aud array or 
 *     the same as value if specified. (OPTION)</li>
 * <li>Time validity
 * <ul>
 * <li>
 * If acceptField.verifyAt as number of UNIX origin time is specifed for validation time, 
 * this method will verify at the time for it, otherwise current time will be used to verify.
 * </li>
 * <li>
 * Clock of JWT generator or verifier can be fast or slow. If these clocks are
 * very different, JWT validation may fail. To avoid such case, 'jsrsasign' supports
 * 'acceptField.gracePeriod' parameter which specifies acceptable time difference
 * of those clocks in seconds. So if you want to accept slow or fast in 2 hours,
 * you can specify <code>acceptField.gracePeriod = 2 * 60 * 60;</code>.
 * "gracePeriod" is zero by default.
 * "gracePeriod" is supported since jsrsasign 5.0.12.
 * </li>
 * <li>Payload.exp (expire) - Validation time is smaller than Payload.exp + gracePeriod.</li>
 * <li>Payload.nbf (not before) - Validation time is greater than Payload.nbf - gracePeriod.</li>
 * <li>Payload.iat (issued at) - Validation time is greater than Payload.iat - gracePeriod.</li>
 * </ul>
 * </li>
 * <li>Payload.jti (JWT id) - Payload.jti is included in acceptField.jti if specified. (OPTION)</li>
 * <li>JWS signature of JWS is valid for specified key.</li>
 * </ul>
 *
 * <h4>acceptField parameters</h4>
 * Here is available acceptField argument parameters:
 * <ul>
 * <li>alg - array of acceptable signature algorithm names (ex. ["HS256", "HS384"])</li>
 * <li>iss - array of acceptable issuer names (ex. ['http://foo.com'])</li>
 * <li>sub - array of acceptable subject names (ex. ['mailto:john@foo.com'])</li>
 * <li>aud - array of acceptable audience name (ex. ['http://foo.com'])</li>
 * <li>jti - string of acceptable JWT ID (OPTION) (ex. 'id1234')</li>
 * <li>
 * verifyAt - time to verify 'nbf', 'iat' and 'exp' in UNIX seconds 
 * (OPTION) (ex. 1377663900).  
 * If this is not specified, current time of verifier will be used. 
 * {@link KJUR.jws.IntDate} may be useful to specify it.
 * </li>
 * <li>gracePeriod - acceptable time difference between signer and verifier
 * in seconds (ex. 3600). If this is not specified, zero will be used.</li>
 * </ul>
 *
 * @example
 * // simple validation for HS256
 * isValid = KJUR.jws.JWS.verifyJWT("eyJhbG...", "616161", {alg: ["HS256"]}),
 *
 * // full validation for RS or PS
 * pubkey = KEYUTIL.getKey('-----BEGIN CERT...');
 * isValid = KJUR.jws.JWS.verifyJWT('eyJh...', pubkey, {
 *   alg: ['RS256', 'RS512', 'PS256', 'PS512'],
 *   iss: ['http://foo.com'],
 *   sub: ['mailto:john@foo.com', 'mailto:alice@foo.com'],
 *   verifyAt: KJUR.jws.IntDate.get('20150520235959Z'),
 *   aud: ['http://foo.com'], // aud: 'http://foo.com' is fine too.
 *   jti: 'id123456',
 *   gracePeriod: 1 * 60 * 60 // accept 1 hour slow or fast
 * });
 */
KJUR.jws.JWS.verifyJWT = function(sJWT, key, acceptField) {
    var _KJUR = KJUR,
	_KJUR_jws = _KJUR.jws,
	_KJUR_jws_JWS = _KJUR_jws.JWS,
	_readSafeJSONString = _KJUR_jws_JWS.readSafeJSONString,
	_inArray = _KJUR_jws_JWS.inArray,
	_includedArray = _KJUR_jws_JWS.includedArray;

    // 0. checking dot concatinatd Base64URL encoded string
    if (! isBase64URLDot(sJWT)) return false;

    // 1. parse JWT
    var a = sJWT.split(".");
    if (a.length != 3) return false;
    var uHeader = a[0];
    var uPayload = a[1];
    var uSignatureInput = uHeader + "." + uPayload;
    var hSig = b64utohex(a[2]);

    // 2. parse JWS header
    var pHeader = _readSafeJSONString(b64utoutf8(uHeader));

    // 3. parse JWS payload
    var pPayload = _readSafeJSONString(b64utoutf8(uPayload));

    // 4. algorithm ('alg' in header) check
    if (pHeader.alg === undefined) return false;
    if (acceptField.alg === undefined)
	throw "acceptField.alg shall be specified";
    if (! _inArray(pHeader.alg, acceptField.alg)) return false;

    // 5. issuer ('iss' in payload) check
    if (pPayload.iss !== undefined && typeof acceptField.iss === "object") {
	if (! _inArray(pPayload.iss, acceptField.iss)) return false;
    }

    // 6. subject ('sub' in payload) check
    if (pPayload.sub !== undefined && typeof acceptField.sub === "object") {
	if (! _inArray(pPayload.sub, acceptField.sub)) return false;
    }

    // 7. audience ('aud' in payload) check
    if (pPayload.aud !== undefined && typeof acceptField.aud === "object") {
	if (typeof pPayload.aud == "string") {
	    if (! _inArray(pPayload.aud, acceptField.aud))
		return false;
	} else if (typeof pPayload.aud == "object") {
	    if (! _includedArray(pPayload.aud, acceptField.aud))
		return false;
	}
    }

    // 8. time validity 
    //   (nbf - gracePeriod < now < exp + gracePeriod) && (iat - gracePeriod < now)
    var now = _KJUR_jws.IntDate.getNow();
    if (acceptField.verifyAt !== undefined && typeof acceptField.verifyAt === "number") {
	now = acceptField.verifyAt;
    }
    if (acceptField.gracePeriod === undefined || 
        typeof acceptField.gracePeriod !== "number") {
	acceptField.gracePeriod = 0;
    }

    // 8.1 expired time 'exp' check
    if (pPayload.exp !== undefined && typeof pPayload.exp == "number") {
	if (pPayload.exp + acceptField.gracePeriod < now) return false;
    }

    // 8.2 not before time 'nbf' check
    if (pPayload.nbf !== undefined && typeof pPayload.nbf == "number") {
	if (now < pPayload.nbf - acceptField.gracePeriod) return false;
    }
    
    // 8.3 issued at time 'iat' check
    if (pPayload.iat !== undefined && typeof pPayload.iat == "number") {
	if (now < pPayload.iat - acceptField.gracePeriod) return false;
    }

    // 9 JWT id 'jti' check
    if (pPayload.jti !== undefined && acceptField.jti !== undefined) {
      if (pPayload.jti !== acceptField.jti) return false;
    }

    // 10 JWS signature check
    if (! _KJUR_jws_JWS.verify(sJWT, key, acceptField.alg)) return false;

    // 11 passed all check
    return true;
};

/**
 * check whether array is included by another array
 * @name includedArray
 * @memberOf KJUR.jws.JWS
 * @function
 * @static
 * @param {Array} a1 check whether set a1 is included by a2
 * @param {Array} a2 check whether set a1 is included by a2
 * @return {Boolean} check whether set a1 is included by a2
 * @since jws 3.2.3
 * This method verifies whether an array is included by another array.
 * It doesn't care about item ordering in a array.
 * @example
 * KJUR.jws.JWS.includedArray(['b'], ['b', 'c', 'a']) => true
 * KJUR.jws.JWS.includedArray(['a', 'b'], ['b', 'c', 'a']) => true
 * KJUR.jws.JWS.includedArray(['a', 'b'], ['b', 'c']) => false
 */
KJUR.jws.JWS.includedArray = function(a1, a2) {
    var _inArray = KJUR.jws.JWS.inArray;
    if (a1 === null) return false;
    if (typeof a1 !== "object") return false;
    if (typeof a1.length !== "number") return false;

    for (var i = 0; i < a1.length; i++) {
	if (! _inArray(a1[i], a2)) return false;
    }
    return true;
};

/**
 * check whether item is included by array
 * @name inArray
 * @memberOf KJUR.jws.JWS
 * @function
 * @static
 * @param {String} item check whether item is included by array
 * @param {Array} a check whether item is included by array
 * @return {Boolean} check whether item is included by array
 * @since jws 3.2.3
 * This method verifies whether an item is included by an array.
 * It doesn't care about item ordering in an array.
 * @example
 * KJUR.jws.JWS.inArray('b', ['b', 'c', 'a']) => true
 * KJUR.jws.JWS.inArray('a', ['b', 'c', 'a']) => true
 * KJUR.jws.JWS.inArray('a', ['b', 'c']) => false
 */
KJUR.jws.JWS.inArray = function(item, a) {
    if (a === null) return false;
    if (typeof a !== "object") return false;
    if (typeof a.length !== "number") return false;
    for (var i = 0; i < a.length; i++) {
	if (a[i] == item) return true;
    }
    return false;
};

/**
 * static associative array of general signature algorithm name from JWS algorithm name
 * @since jws 3.0.0
 */
KJUR.jws.JWS.jwsalg2sigalg = {
    "HS256":	"HmacSHA256",
    "HS384":	"HmacSHA384",
    "HS512":	"HmacSHA512",
    "RS256":	"SHA256withRSA",
    "RS384":	"SHA384withRSA",
    "RS512":	"SHA512withRSA",
    "ES256":	"SHA256withECDSA",
    "ES384":	"SHA384withECDSA",
    "ES512":	"SHA512withECDSA",
    "PS256":	"SHA256withRSAandMGF1",
    "PS384":	"SHA384withRSAandMGF1",
    "PS512":	"SHA512withRSAandMGF1",
    "none":	"none",
};

// === utility static method ==================================================

/**
 * check whether a String "s" is a safe JSON string or not.<br/>
 * If a String "s" is a malformed JSON string or an other object type
 * this returns 0, otherwise this returns 1.
 * @name isSafeJSONString
 * @memberOf KJUR.jws.JWS
 * @function
 * @static
 * @param {String} s JSON string
 * @return {Number} 1 or 0
 */
KJUR.jws.JWS.isSafeJSONString = function(s, h, p) {
    var o = null;
    try {
	o = jsonParse(s);
	if (typeof o != "object") return 0;
	if (o.constructor === Array) return 0;
	if (h) h[p] = o;
	return 1;
    } catch (ex) {
	return 0;
    }
};

/**
 * read a String "s" as JSON object if it is safe.<br/>
 * If a String "s" is a malformed JSON string or not JSON string,
 * this returns null, otherwise returns JSON object.
 * @name readSafeJSONString
 * @memberOf KJUR.jws.JWS
 * @function
 * @static
 * @param {String} s JSON string
 * @return {Object} JSON object or null
 * @since 1.1.1
 */
KJUR.jws.JWS.readSafeJSONString = function(s) {
    var o = null;
    try {
	o = jsonParse(s);
	if (typeof o != "object") return null;
	if (o.constructor === Array) return null;
	return o;
    } catch (ex) {
	return null;
    }
};

/**
 * get Encoed Signature Value from JWS string.<br/>
 * @name getEncodedSignatureValueFromJWS
 * @memberOf KJUR.jws.JWS
 * @function
 * @static
 * @param {String} sJWS JWS signature string to be verified
 * @return {String} string of Encoded Signature Value 
 * @throws if sJWS is not comma separated string such like "Header.Payload.Signature".
 */
KJUR.jws.JWS.getEncodedSignatureValueFromJWS = function(sJWS) {
    var matchResult = sJWS.match(/^[^.]+\.[^.]+\.([^.]+)$/);
    if (matchResult == null) {
	throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
    }
    return matchResult[1];
};

/**
 * get RFC 7638 JWK thumbprint from JWK object
 * @name getJWKthumbprint
 * @memberOf KJUR.jws.JWS
 * @function
 * @static
 * @param {Object} o JWK object to be calculated thumbprint
 * @return {String} Base64 URL encoded JWK thumbprint value
 * @since jsrsasign 5.0.2 jws 3.3.2
 * @description
 * This method calculates JWK thmubprint for specified JWK object
 * as described in 
 * <a href="https://tools.ietf.org/html/rfc7638">RFC 7638</a>.
 * It supports all type of "kty". (i.e. "RSA", "EC" and "oct"
 * (for symmetric key))
 * Working sample is 
 * <a href="https://kjur.github.io/jsrsasign/sample/tool_jwktp.html">here</a>.
 * @example
 * jwk = {"kty":"RSA", "n":"0vx...", "e":"AQAB", ...};
 * thumbprint = KJUR.jws.JWS.getJWKthumbprint(jwk);
 */
KJUR.jws.JWS.getJWKthumbprint = function(o) {
    if (o.kty !== "RSA" &&
	o.kty !== "EC" &&
	o.kty !== "oct")
	throw "unsupported algorithm for JWK Thumprint";

    // 1. get canonically ordered json string
    var s = '{';
    if (o.kty === "RSA") {
	if (typeof o.n != "string" || typeof o.e != "string")
	    throw "wrong n and e value for RSA key";
	s += '"' + 'e' + '":"' + o.e + '",';
	s += '"' + 'kty' + '":"' + o.kty + '",';
	s += '"' + 'n' + '":"' + o.n + '"}';
    } else if (o.kty === "EC") {
	if (typeof o.crv != "string" || 
	    typeof o.x != "string" ||
	    typeof o.y != "string")
	    throw "wrong crv, x and y value for EC key";
	s += '"' + 'crv' + '":"' + o.crv + '",';
	s += '"' + 'kty' + '":"' + o.kty + '",';
	s += '"' + 'x' + '":"' + o.x + '",';
	s += '"' + 'y' + '":"' + o.y + '"}';
    } else if (o.kty === "oct") {
	if (typeof o.k != "string")
	    throw "wrong k value for oct(symmetric) key";
	s += '"' + 'kty' + '":"' + o.kty + '",';
	s += '"' + 'k' + '":"' + o.k + '"}';
    }
    //alert(s);

    // 2. get thumb print
    var hJWK = rstrtohex(s);
    var hash = KJUR.crypto.Util.hashHex(hJWK, "sha256");
    var hashB64U = hextob64u(hash);

    return hashB64U;
};

/**
 * IntDate class for time representation for JSON Web Token(JWT)
 * @class KJUR.jws.IntDate class
 * @name KJUR.jws.IntDate
 * @since jws 3.0.1
 * @description
 * Utility class for IntDate which is integer representation of UNIX origin time
 * used in JSON Web Token(JWT).
 */
KJUR.jws.IntDate = {};

/**
 * get UNIX origin time from by string
 * @name get
 * @memberOf KJUR.jws.IntDate
 * @function
 * @static
 * @param {String} s string of time representation
 * @return {Integer} UNIX origin time in seconds for argument 's'
 * @since jws 3.0.1
 * @throws "unsupported format: s" when malformed format
 * @description
 * This method will accept following representation of time.
 * <ul>
 * <li>now - current time</li>
 * <li>now + 1hour - after 1 hour from now</li>
 * <li>now + 1day - after 1 day from now</li>
 * <li>now + 1month - after 30 days from now</li>
 * <li>now + 1year - after 365 days from now</li>
 * <li>YYYYmmDDHHMMSSZ - UTC time (ex. 20130828235959Z)</li>
 * <li>number - UNIX origin time (seconds from 1970-01-01 00:00:00) (ex. 1377714748)</li>
 * </ul>
 */
KJUR.jws.IntDate.get = function(s) {
    var _KJUR_jws_IntDate = KJUR.jws.IntDate,
	_getNow = _KJUR_jws_IntDate.getNow,
	_getZulu = _KJUR_jws_IntDate.getZulu;

    if (s == "now") {
	return _getNow();
    } else if (s == "now + 1hour") {
	return _getNow() + 60 * 60;
    } else if (s == "now + 1day") {
	return _getNow() + 60 * 60 * 24;
    } else if (s == "now + 1month") {
	return _getNow() + 60 * 60 * 24 * 30;
    } else if (s == "now + 1year") {
	return _getNow() + 60 * 60 * 24 * 365;
    } else if (s.match(/Z$/)) {
	return _getZulu(s);
    } else if (s.match(/^[0-9]+$/)) {
	return parseInt(s);
    }
    throw "unsupported format: " + s;
};

/**
 * get UNIX origin time from Zulu time representation string
 * @name getZulu
 * @memberOf KJUR.jws.IntDate
 * @function
 * @static
 * @param {String} s string of Zulu time representation (ex. 20151012125959Z)
 * @return {Integer} UNIX origin time in seconds for argument 's'
 * @since jws 3.0.1
 * @throws "unsupported format: s" when malformed format
 * @description
 * This method provides UNIX origin time from Zulu time.
 * Following representations are supported:
 * <ul>
 * <li>YYYYMMDDHHmmSSZ - GeneralizedTime format</li>
 * <li>YYMMDDHHmmSSZ - UTCTime format. If YY is greater or equal to 
 * 50 then it represents 19YY otherwise 20YY.</li>
 * </ul>
 * @example
 * KJUR.jws.IntDate.getZulu("20151012125959Z") => 1478...
 * KJUR.jws.IntDate.getZulu("151012125959Z") => 1478...
 */
KJUR.jws.IntDate.getZulu = function(s) {
    return zulutosec(s);
};

/**
 * get UNIX origin time of current time
 * @name getNow
 * @memberOf KJUR.jws.IntDate
 * @function
 * @static
 * @return {Integer} UNIX origin time for current time
 * @since jws 3.0.1
 * @description
 * This method provides UNIX origin time for current time
 * @example
 * KJUR.jws.IntDate.getNow() => 1478...
 */
KJUR.jws.IntDate.getNow = function() {
    var d = ~~(new Date() / 1000);
    return d;
};

/**
 * get UTC time string from UNIX origin time value
 * @name intDate2UTCString
 * @memberOf KJUR.jws.IntDate
 * @function
 * @static
 * @param {Integer} intDate UNIX origin time value (ex. 1478...)
 * @return {String} UTC time string
 * @since jws 3.0.1
 * @description
 * This method provides UTC time string for UNIX origin time value.
 * @example
 * KJUR.jws.IntDate.intDate2UTCString(1478...) => "2015 Oct ..."
 */
KJUR.jws.IntDate.intDate2UTCString = function(intDate) {
    var d = new Date(intDate * 1000);
    return d.toUTCString();
};

/**
 * get UTC time string from UNIX origin time value
 * @name intDate2Zulu
 * @memberOf KJUR.jws.IntDate
 * @function
 * @static
 * @param {Integer} intDate UNIX origin time value (ex. 1478...)
 * @return {String} Zulu time string
 * @since jws 3.0.1
 * @description
 * This method provides Zulu time string for UNIX origin time value.
 * @example
 * KJUR.jws.IntDate.intDate2UTCString(1478...) => "20151012...Z"
 */
KJUR.jws.IntDate.intDate2Zulu = function(intDate) {
    var d = new Date(intDate * 1000),
	year = ("0000" + d.getUTCFullYear()).slice(-4),
	mon =  ("00" + (d.getUTCMonth() + 1)).slice(-2),
	day =  ("00" + d.getUTCDate()).slice(-2),
	hour = ("00" + d.getUTCHours()).slice(-2),
	min =  ("00" + d.getUTCMinutes()).slice(-2),
        sec =  ("00" + d.getUTCSeconds()).slice(-2);
    return year + mon + day + hour + min + sec + "Z";
};


/* jwsjs-2.2.1 (c) 2010-2018 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * jwsjs.js - JSON Web Signature JSON Serialization (JWSJS) Class
 *
 * Copyright (c) 2010-2018 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license/
 *
 * The above copyright and license notice shall be 
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name jwsjs-2.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 8.0.0 jwsjs 2.2.1 (2018-Mar-24)
 * @since jsjws 1.2, jsrsasign 4.8.0
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.jws == "undefined" || !KJUR.jws) KJUR.jws = {};

/**
 * JSON Web Signature JSON Serialization (JWSJS) class.<br/>
 * @class JSON Web Signature JSON Serialization (JWSJS) class
 * @name KJUR.jws.JWSJS
 * @property {array of String} aHeader array of Encoded JWS Headers
 * @property {String} sPayload Encoded JWS payload
 * @property {array of String} aSignature array of Encoded JWS signature value
 * @author Kenji Urushima
 * @version 2.1.0 (2016 Sep 6)
 * @see <a href="https://kjur.github.io/jsjws/">old jwjws home page https://kjur.github.io/jsjws/</a>
 * @see <a href="https://kjur.github.io/jsrsasigns/">'jwrsasign'(RSA Sign JavaScript Library) home page https://kjur.github.io/jsrsasign/</a>
 * @see <a href="http://tools.ietf.org/html/draft-jones-json-web-signature-json-serialization-01">IETF I-D JSON Web Signature JSON Serialization (JWS-JS) specification</a>
 *
 * @description
 * This class generates and verfies "JSON Web Signature JSON Serialization (JWSJS)" of
 * <a href="http://tools.ietf.org/html/draft-jones-json-web-signature-json-serialization-01">
 * IETF Internet Draft</a>. Here is major methods of this class:
 * <ul>
 * <li>{@link KJUR.jws.JWSJS#readJWSJS} - initialize with string or JSON object of JWSJS.</li>
 * <li>{@link KJUR.jws.JWSJS#initWithJWS} - initialize with JWS as first signature.</li>
 * <li>{@link KJUR.jws.JWSJS#addSignature} - append signature to JWSJS object.</li>
 * <li>{@link KJUR.jws.JWSJS#verifyAll} - verify all signatures in JWSJS object.</li>
 * <li>{@link KJUR.jws.JWSJS#getJSON} - get result of JWSJS object as JSON object.</li>
 * </ul>
 *
 * @example
 * // initialize
 * jwsjs1 = new KJUR.jws.JWSJS();
 * jwsjs1.readJWSJS("{headers: [...], payload: "eyJ...", signatures: [...]}");
 * 
 * // add PS256 signature with RSA private key object
 * prvKeyObj = KEYUTIL.getKey("-----BEGIN PRIVATE KEY...");
 * jwsjs1.addSignature("PS256", {alg: "PS256"}, prvKeyObj);
 * // add HS256 signature with HMAC password "secret"
 * jwsjs1.addSignature(null, {alg: "HS256"}, {utf8: "secret"});
 * 
 * // get result finally
 * jwsjsObj1 = jwsjs1.getJSON();
 *
 * // verify all signatures
 * isValid = jwsjs1.verifyAll([["-----BEGIN CERT...", ["RS256"]],
 *                             [{utf8: "secret"}, ["HS256"]]]); 
 * 
 */
KJUR.jws.JWSJS = function() {
    var _KJUR = KJUR,
	_KJUR_jws = _KJUR.jws,
	_KJUR_jws_JWS = _KJUR_jws.JWS,
	_readSafeJSONString = _KJUR_jws_JWS.readSafeJSONString;

    this.aHeader = [];
    this.sPayload = "";
    this.aSignature = [];

    // == initialize ==========================================================
    /**
     * (re-)initialize this object.<br/>
     * @name init
     * @memberOf KJUR.jws.JWSJS#
     * @function
     */
    this.init = function() {
	this.aHeader = [];
	this.sPayload = undefined;
	this.aSignature = [];
    };

    /**
     * (re-)initialize and set first signature with JWS.<br/>
     * @name initWithJWS
     * @memberOf KJUR.jws.JWSJS#
     * @param {String} sJWS JWS signature to set
     * @function
     * @example
     * jwsjs1 = new KJUR.jws.JWSJWS();
     * jwsjs1.initWithJWS("eyJ...");
     */
    this.initWithJWS = function(sJWS) {
	this.init();

	var a = sJWS.split(".");
	if (a.length != 3)
	    throw "malformed input JWS";

	this.aHeader.push(a[0]);
	this.sPayload = a[1];
	this.aSignature.push(a[2]);
    };

    // == add signature =======================================================
    /**
     * add a signature to existing JWS-JS by algorithm, header and key.<br/>
     * @name addSignature
     * @memberOf KJUR.jws.JWSJS#
     * @function
     * @param {String} alg JWS algorithm. If null, alg in header will be used.
     * @param {Object} spHead string or object of JWS Header to add.
     * @param {Object} key JWS key to sign. key object, PEM private key or HMAC key
     * @param {String} pass optional password for encrypted PEM private key
     * @throw if signature append failed.
     * @example
     * // initialize
     * jwsjs1 = new KJUR.jws.JWSJS();
     * jwsjs1.readJWSJS("{headers: [...], payload: "eyJ...", signatures: [...]}");
     *
     * // add PS256 signature with RSA private key object
     * prvKeyObj = KEYUTIL.getKey("-----BEGIN PRIVATE KEY...");
     * jwsjs1.addSignature("PS256", {alg: "PS256"}, prvKeyObj);
     *
     * // add HS256 signature with HMAC password "secret"
     * jwsjs1.addSignature(null, {alg: "HS256"}, {utf8: "secret"});
     *
     * // get result finally
     * jwsjsObj1 = jwsjs1.getJSON();
     */
    this.addSignature = function(alg, spHead, key, pass) {
	if (this.sPayload === undefined || this.sPayload === null)
	    throw "there's no JSON-JS signature to add.";

	var sigLen = this.aHeader.length;
	if (this.aHeader.length != this.aSignature.length)
	    throw "aHeader.length != aSignature.length";

	try {
	    var sJWS = KJUR.jws.JWS.sign(alg, spHead, this.sPayload, key, pass);
	    var a = sJWS.split(".");
	    var sHeader2 = a[0];
	    var sSignature2 = a[2];
	    this.aHeader.push(a[0]);
	    this.aSignature.push(a[2]);
	} catch(ex) {
	    if (this.aHeader.length > sigLen) this.aHeader.pop();
	    if (this.aSignature.length > sigLen) this.aSignature.pop();
	    throw "addSignature failed: " + ex;
	}
    };

    // == verify signature ====================================================
    /**
     * verify all signature of JWS-JS object by array of key and acceptAlgs.<br/>
     * @name verifyAll
     * @memberOf KJUR.jws.JWSJS#
     * @function
     * @param {array of key and acceptAlgs} aKeyAlg a array of key and acceptAlgs
     * @return true if all signatures are valid otherwise false
     * @since jwsjs 2.1.0 jsrsasign 5.1.0
     * @example
     * jwsjs1 = new KJUR.jws.JWSJS();
     * jwsjs1.readJWSJS("{headers: [...], payload: "eyJ...", signatures: [...]}");
     * isValid = jwsjs1.verifyAll([["-----BEGIN CERT...", ["RS256"]],
     *                             [{utf8: "secret"}, ["HS256"]]]); 
     */
    this.verifyAll = function(aKeyAlg) {
	if (this.aHeader.length !== aKeyAlg.length ||
	    this.aSignature.length !== aKeyAlg.length)
	    return false;

	for (var i = 0; i < aKeyAlg.length; i++) {
	    var keyAlg = aKeyAlg[i];
	    if (keyAlg.length  !== 2) return false;
	    var result = this.verifyNth(i, keyAlg[0], keyAlg[1]);
	    if (result === false) return false;
	}
	return true;
    };

    /**
     * verify Nth signature of JWS-JS object by key and acceptAlgs.<br/>
     * @name verifyNth
     * @memberOf KJUR.jws.JWSJS#
     * @function
     * @param {Integer} idx nth index of JWS-JS signature to verify
     * @param {Object} key key to verify
     * @param {array of String} acceptAlgs array of acceptable signature algorithms
     * @return true if signature is valid otherwise false
     * @since jwsjs 2.1.0 jsrsasign 5.1.0
     * @example
     * jwsjs1 = new KJUR.jws.JWSJS();
     * jwsjs1.readJWSJS("{headers: [...], payload: "eyJ...", signatures: [...]}");
     * isValid1 = jwsjs1.verifyNth(0, "-----BEGIN CERT...", ["RS256"]);
     * isValid2 = jwsjs1.verifyNth(1, {utf8: "secret"}, ["HS256"]);
     */
    this.verifyNth = function(idx, key, acceptAlgs) {
	if (this.aHeader.length <= idx || this.aSignature.length <= idx)
	    return false;
	var sHeader = this.aHeader[idx];
	var sSignature = this.aSignature[idx];
	var sJWS = sHeader + "." + this.sPayload + "." + sSignature;
	var result = false;
	try {
	    result = _KJUR_jws_JWS.verify(sJWS, key, acceptAlgs);
	} catch (ex) {
	    return false;
	}
	return result;
    };

    /**
     * read JWS-JS string or object<br/>
     * @name readJWSJS
     * @memberOf KJUR.jws.JWSJS#
     * @function
     * @param {Object} spJWSJS string or JSON object of JWS-JS to load.
     * @throw if sJWSJS is malformed or not JSON string.
     * @description
     * NOTE: Loading from JSON object is suppored from 
     * jsjws 2.1.0 jsrsasign 5.1.0 (2016-Sep-06).
     * @example
     * // load JWSJS from string
     * jwsjs1 = new KJUR.jws.JWSJS();
     * jwsjs1.readJWSJS("{headers: [...], payload: "eyJ...", signatures: [...]}");
     *
     * // load JWSJS from JSON object
     * jwsjs1 = new KJUR.jws.JWSJS();
     * jwsjs1.readJWSJS({headers: [...], payload: "eyJ...", signatures: [...]});
     */
    this.readJWSJS = function(spJWSJS) {
	if (typeof spJWSJS === "string") {
	    var oJWSJS = _readSafeJSONString(spJWSJS);
	    if (oJWSJS == null) throw "argument is not safe JSON object string";

	    this.aHeader = oJWSJS.headers;
	    this.sPayload = oJWSJS.payload;
	    this.aSignature = oJWSJS.signatures;
	} else {
	    try {
		if (spJWSJS.headers.length > 0) {
		    this.aHeader = spJWSJS.headers;
		} else {
		    throw "malformed header";
		}
		if (typeof spJWSJS.payload === "string") {
		    this.sPayload = spJWSJS.payload;
		} else {
		    throw "malformed signatures";
		}
		if (spJWSJS.signatures.length > 0) {
		    this.aSignature = spJWSJS.signatures;
		} else {
		    throw "malformed signatures";
		}
	    } catch (ex) {
		throw "malformed JWS-JS JSON object: " + ex;
	    }
	}
    };

    // == utility =============================================================
    /**
     * get JSON object for this JWS-JS object.<br/>
     * @name getJSON
     * @memberOf KJUR.jws.JWSJS#
     * @function
     * @example
     * jwsj1 = new KJUR.jws.JWSJS();
     * // do some jwsj1 operation then get result by getJSON()
     * jwsjsObj1 = jwsjs1.getJSON();
     * // jwsjsObj1 &rarr; { headers: [...], payload: "ey...", signatures: [...] }
     */
    this.getJSON = function() {
	return { "headers": this.aHeader,
		 "payload": this.sPayload,
		 "signatures": this.aSignature }; 
    };

    /**
     * check if this JWS-JS object is empty.<br/>
     * @name isEmpty
     * @memberOf KJUR.jws.JWSJS#
     * @function
     * @return 1 if there is no signatures in this object, otherwise 0.
     */
    this.isEmpty = function() {
	if (this.aHeader.length == 0) return 1; 
	return 0;
    };
};


/* x509crl.js (c) 2012-2022 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
/*
 * x509crl.js - X509CRL class to parse X.509 CRL
 *
 * Copyright (c) 2010-2022 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * https://kjur.github.io/jsrsasign/license
 *
 * The above copyright and license notice shall be
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name x509crl.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version jsrsasign 10.5.16 x509crl 1.0.5 (2022-Apr-08)
 * @since jsrsasign 10.1.0
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * hexadecimal X.509 CRL ASN.1 parser class.<br/>
 * @class hexadecimal X.509 CRL ASN.1 parser class
 * @param {String} params X.509 CRL PEM string or hexadecimal string
 * @property {String} hex hexadecimal string of X.509 CRL ASN.1 data
 * @property {Integer} posSigAlg index of SignatureAlgorithm field in TBSCertList position depends on CRL version field
 * @property {Integer} posRevCert index of revokedCertificates field in TBSCertList depends on CRL version and nextUpdate field
 * @author Kenji Urushima
 * @version 1.0.0 (2020-Aug-26)
 * @see X509
 * @see <a href="https://kjur.github.io/jsrsasigns/">jsrsasign home page https://kjur.github.io/jsrsasign/</a>
 *
 * @description
 * This class parses X.509 CRL. Following methods are provided to
 * get field value:<br/>
 * <b>BASIC FIELD</b><br/>
 * <ul>
 * <li>version - {@link X509CRL#getVersion}</li>
 * <li>signatureAlgorithm - {@link X509CRL#getSignatureAlgorithmField}</li>
 * <li>issuer - {@link X509CRL#getIssuer}</li>
 * <li>issuer - {@link X509CRL#getIssuerHex}</li>
 * <li>thisUpdate - {@link X509CRL#getThisUpdate}</li>
 * <li>nextUpdate - {@link X509CRL#getNextUpdate}</li>
 * <li>revokedCertificates - {@link X509CRL#getRevCertArray}</li>
 * <li>revokedCertificate - {@link X509CRL#getRevCert}</li>
 * <li>signature - {@link X509CRL#getSignatureValueHex}</li>
 * </ul>
 * <b>UTILITIES</b><br/>
 * <ul>
 * <li>{@link X509CRL#getParam} - get all parameters</li>
 * </ul>
 *
 * @example
 * // constructor
 * crl = new X509CRL("-----BEGIN X509 CRL...");
 * crl = new X509CRL("3082...");
 */
var X509CRL = function(params) {
    var _KJUR = KJUR,
	_isHex = _KJUR.lang.String.isHex,
	_ASN1HEX = ASN1HEX,
	_getV = _ASN1HEX.getV,
	_getTLV = _ASN1HEX.getTLV,
	_getVbyList = _ASN1HEX.getVbyList,
	_getTLVbyList = _ASN1HEX.getTLVbyList,
	_getTLVbyListEx = _ASN1HEX.getTLVbyListEx,
	_getIdxbyList = _ASN1HEX.getIdxbyList,
	_getIdxbyListEx = _ASN1HEX.getIdxbyListEx,
	_getChildIdx = _ASN1HEX.getChildIdx,
	_x509obj = new X509();
    
    this.hex = null;
    this.posSigAlg = null;
    this.posRevCert = null;
    this.parsed = null;

    /*
     * set field position of SignatureAlgorithm and revokedCertificates<br/>
     * @description
     * This method will set "posSigAlg" and "posRevCert" properties.
     */
    this._setPos = function() {
	// for sigAlg
	var idx = _getIdxbyList(this.hex, 0, [0, 0]);
	var tag = this.hex.substr(idx, 2);
	if (tag == "02") {
	    this.posSigAlg = 1;
	} else if (tag == "30") {
	    this.posSigAlg = 0;
	} else {
	    throw new Error("malformed 1st item of TBSCertList: " + tag);
	}

	// for revCerts
	var idx2 = _getIdxbyList(this.hex, 0, [0, this.posSigAlg + 3]);
	var tag2 = this.hex.substr(idx2, 2);
	if (tag2 == "17" || tag2 == "18") {
	    var idx3, tag3;
	    idx3 = _getIdxbyList(this.hex, 0, [0, this.posSigAlg + 4]);
	    this.posRevCert = null;
	    if (idx3 != -1) {
		tag3 = this.hex.substr(idx3, 2);
		if (tag3 == "30") {
		    this.posRevCert = this.posSigAlg + 4;
		}
	    }
	} else if (tag2 == "30") { // found revCert
	    this.posRevCert = this.posSigAlg + 3;
	} else if (tag2 == "a0") { // no nextUpdate and revCert
	    this.posRevCert = null;
	} else {
	    throw new Error("malformed nextUpdate or revCert tag: " + tag2);
	}
    };

    /**
     * get X.509 CRL format version<br/>
     * @name getVersion
     * @memberOf X509CRL#
     * @function
     * @return {Number} version field value (generally 2) or null
     * @description
     * This method returns a version field value TBSCertList.
     * This returns null if there is no such field.
     * @example
     * crl = new X509CRL("-----BEGIN X509 CRL...");
     * crl.getVersion() &rarr; 2
     */
    this.getVersion = function() {
	if (this.posSigAlg == 0) return null;
	return parseInt(_getVbyList(this.hex, 0, [0, 0], "02"), 16) + 1;
    }

    /**
     * get signature algorithm name in basic field
     * @name getSignatureAlgorithmField
     * @memberOf X509CRL#
     * @function
     * @return {String} signature algorithm name (ex. SHA1withRSA, SHA256withECDSA, SHA512withRSAandMGF1)
     * @see X509#getSignatureAlgorithmField
     * @see KJUR.asn1.x509.AlgirithmIdentifier
     * 
     * @description
     * This method will get a name of signature algorithm in CRL.
     *
     * @example
     * crl = new X509CRL("-----BEGIN X509 CRL...");
     * crl.getSignatureAlgorithmField() &rarr; "SHA256withRSAandMGF1"
     */
    this.getSignatureAlgorithmField = function() {
	var hTLV = _getTLVbyList(this.hex, 0, [0, this.posSigAlg], "30");
	return _x509obj.getAlgorithmIdentifierName(hTLV);
    };

    /**
     * get JSON object of issuer field<br/>
     * @name getIssuer
     * @memberOf X509CRL#
     * @function
     * @return {Array} JSON object of issuer field
     * @see X509#getIssuer
     * @see X509#getX500Name
     * @see KJUR.asn1.x509.X500Name
     *
     * @description
     * This method returns parsed issuer field value as
     * JSON object.
     *
     * @example
     * crl = new X509CRL("-----BEGIN X509 CRL...");
     * x.getIssuer() &rarr;
     * { array: [[{type:'C',value:'JP',ds:'prn'}],...],
     *   str: "/C=JP/..." }
     */
    this.getIssuer = function() {
	return _x509obj.getX500Name(this.getIssuerHex());
    };

    /**
     * get hexadecimal string of issuer field TLV of certificate.<br/>
     * @name getIssuerHex
     * @memberOf X509CRL#
     * @function
     * @return {string} hexadecial string of issuer DN ASN.1
     * @see X509CRL#getIssuer
     * @since jsrsasign 10.5.5 x509crl 1.0.3
     *
     * @description
     * This method returns ASN.1 DER hexadecimal string of
     * issuer field.
     *
     * @example
     * crl = new X509CRL("-----BEGIN X509 CRL...");
     * x.getIssuerHex() &rarr; "30..."
     */
    this.getIssuerHex = function() {
	return _getTLVbyList(this.hex, 0, [0, this.posSigAlg + 1], "30");
    };

    /**
     * get JSON object of thisUpdate field<br/>
     * @name getThisUpdate
     * @memberOf X509CRL#
     * @function
     * @return {String} string of thisUpdate field (ex. "YYMMDDHHmmSSZ")
     * @see X509#getNotBefore
     * @see X509CRL#getNextUpdate
     * @see KJUR.asn1.x509.Time
     *
     * @description
     * This method returns parsed thisUpdate field value as
     * string.
     *
     * @example
     * crl = new X509CRL("-----BEGIN X509 CRL...");
     * x.getThisUpdate() &rarr; "200825235959Z"
     */
    this.getThisUpdate = function() {
	var hThisUpdate = _getVbyList(this.hex, 0, [0, this.posSigAlg + 2]);
	return result = hextorstr(hThisUpdate);
    };

    /**
     * get JSON object of nextUpdate field<br/>
     * @name getNextUpdate
     * @memberOf X509CRL#
     * @function
     * @return {String} string of nextUpdate field or null
     * @see X509#getNotBefore
     * @see X509CRL#getThisUpdate
     * @see KJUR.asn1.x509.Time
     *
     * @description
     * This method returns parsed nextUpdate field value as
     * string. "nextUpdate" is OPTIONAL field so 
     * when nextUpdate field doesn't exists, this returns null.
     *
     * @example
     * crl = new X509CRL("-----BEGIN X509 CRL...");
     * crl.getNextUpdate() &rarr; "200825235959Z"
     */
    this.getNextUpdate = function() {
	var idx = _getIdxbyList(this.hex, 0, [0, this.posSigAlg + 3]);
	var tag = this.hex.substr(idx, 2);
	if (tag != "17" && tag != "18") return null;
	return hextorstr(_getV(this.hex, idx));
    };

    /**
     * get array for revokedCertificates field<br/>
     * @name getRevCertArray
     * @memberOf X509CRL#
     * @function
     * @return {Array} array of revokedCertificate parameter or null
     * @see X509CRL#getRevCert
     *
     * @description
     * This method returns parsed revokedCertificates field value as
     * array of revokedCertificate parameter.
     * If the field doesn't exists, it returns null.
     *
     * @example
     * crl = new X509CRL("-----BEGIN X509 CRL...");
     * crl.getRevCertArray() &rarr;
     * [{sn:"123a", date:"208025235959Z", ext: [{extname:"cRLReason",code:3}]},
     *  {sn:"123b", date:"208026235959Z", ext: [{extname:"cRLReason",code:0}]}]
     */
    this.getRevCertArray = function() {
	if (this.posRevCert == null) return null;
	var a = [];
	var idx = _getIdxbyList(this.hex, 0, [0, this.posRevCert]);
	var aIdx = _getChildIdx(this.hex, idx);
	for (var i = 0; i < aIdx.length; i++) {
	    var hRevCert = _getTLV(this.hex, aIdx[i]);
	    a.push(this.getRevCert(hRevCert));
	}
	return a;
    };

    /**
     * get revokedCertificate JSON parameter<br/>
     * @name getRevCert
     * @memberOf X509CRL#
     * @function
     * @return {Array} JSON object for revokedCertificate parameter
     * @see X509CRL#getRevCertArray
     *
     * @description
     * This method returns parsed revokedCertificate parameter
     * as JSON object.
     *
     * @example
     * crl = new X509CRL();
     * crl.getRevCertArray("30...") &rarr;
     * {sn:"123a", date:"208025235959Z", ext: [{extname:"cRLReason",code:3}]}
     */
    this.getRevCert = function(hRevCert) {
	var param = {};
	var aIdx = _getChildIdx(hRevCert, 0);

	param.sn = {hex: _getVbyList(hRevCert, 0, [0], "02")};
	param.date = hextorstr(_getVbyList(hRevCert, 0, [1]));
	if (aIdx.length == 3) {
	    param.ext = 
		_x509obj.getExtParamArray(_getTLVbyList(hRevCert, 0, [2]));
	}

	return param;
    };

    /**
     * get revokedCertificate associative array for checking certificate<br/>
     * @name findRevCert
     * @memberOf X509CRL#
     * @function
     * @param {string} PEM or hexadecimal string of certificate to be revocation-checked
     * @return {object} JSON object for revokedCertificate or null
     * @see X509CRL#getParam
     * @see X509CRL#findRevCertBySN
     * @since jsrsasign 10.5.5 x509crl 1.0.3
     *
     * @description
     * This method will find revokedCertificate entry as JSON object
     * for a specified certificate. <br/>
     * When the serial number is not found in the entry, this returns null.<br/>
     * Before finding, {@link X509CRL#getParam} is called internally
     * to parse CRL.<br/>
     * NOTE: This method will just find an entry for a serial number.
     * You need to check whether CRL is proper one or not
     * for checking certificate such as signature validation or
     * name checking.
     *
     * @example
     * crl = new X509CRL(PEMCRL);
     *
     * crl.findRevCert(PEMCERT-REVOKED) &rarr; 
     * {sn:"123a", date:"208025235959Z", ext: [{extname:"cRLReason",code:3}]}
     *
     * crl.findRevCert(PEMCERT-NOTREVOKED) &rarr; null
     * 
     * crl.findRevCert(CERT-HEX) &rarr; null or {sn:...}
     */
    this.findRevCert = function(sCert) {
	var x = new X509(sCert);
	var hSN = x.getSerialNumberHex();
	return this.findRevCertBySN(hSN);
    };
    
    /**
     * get revokedCertificate associative array for serial number<br/>
     * @name findRevCertBySN
     * @memberOf X509CRL#
     * @function
     * @param {string} hexadecimal string of checking certificate serial number
     * @return {object} JSON object for revokedCertificate or null
     * @see X509CRL#getParam
     * @see X509CRL#findRevCert
     * @since jsrsasign 10.5.5 x509crl 1.0.3
     *
     * @description
     * This method will find revokedCertificate entry as JSON object
     * for a specified serial number. <br/>
     * When the serial number is not found in the entry, this returns null.<br/>
     * Before finding, {@link X509CRL#getParam} is called internally
     * to parse CRL.<br/>
     * NOTE: This method will just find an entry for a serial number.
     * You need to check whether CRL is proper one or not
     * for checking certificate such as signature validation or
     * name checking.
     *
     * @example
     * crl = new X509CRL(PEMCRL);
     * crl.findRevCertBySN("123a") &rarr; // revoked
     * {sn:"123a", date:"208025235959Z", ext: [{extname:"cRLReason",code:3}]}
     *
     * crl.findRevCertBySN("0000") &rarr; null // not revoked
     */
    this.findRevCertBySN = function(hSN) {
	if (this.parsed == null) this.getParam();
	if (this.parsed.revcert == null) return null;
	var revcert = this.parsed.revcert;
	for (var i = 0; i < revcert.length; i++) {
	    if (hSN == revcert[i].sn.hex) return revcert[i];
	}
	return null;
    };

    /**
     * get signature value as hexadecimal string<br/>
     * @name getSignatureValueHex
     * @memberOf X509CRL#
     * @function
     * @return {String} signature value hexadecimal string without BitString unused bits
     *
     * @description
     * This method will get signature value of CRL.
     *
     * @example
     * crl = new X509CRL("-----BEGIN X509 CRL...");
     * crl.getSignatureValueHex() &rarr "8a4c47913..."
     */
    this.getSignatureValueHex = function() {
	return _getVbyList(this.hex, 0, [2], "03", true);
    };

    /**
     * verifies signature value by public key<br/>
     * @name verifySignature
     * @memberOf X509CRL#
     * @function
     * @param {Object} pubKey public key object, pubkey PEM or PEM issuer cert
     * @return {Boolean} true if signature value is valid otherwise false
     * @see X509#verifySignature
     * @see KJUR.crypto.Signature
     *
     * @description
     * This method verifies signature value of hexadecimal string of 
     * X.509 CRL by specified public key.
     * The signature algorithm used to verify will refer
     * signatureAlgorithm field. 
     * (See {@link X509CRL#getSignatureAlgorithmField})
     *
     * @example
     * crl = new X509CRL("-----BEGIN X509 CRL...");
     * x.verifySignature(pubKey) &rarr; true, false or raising exception
     */
    this.verifySignature = function(pubKey) {
	var algName = this.getSignatureAlgorithmField();
	var hSigVal = this.getSignatureValueHex();
	var hTbsCertList = _getTLVbyList(this.hex, 0, [0], "30");
	
	var sig = new KJUR.crypto.Signature({alg: algName});
	sig.init(pubKey);
	sig.updateHex(hTbsCertList);
	return sig.verify(hSigVal);
    };

    /**
     * get JSON object for CRL parameters<br/>
     * @name getParam
     * @memberOf X509CRL#
     * @function
     * @return {Array} JSON object for CRL parameters
     * @see KJUR.asn1.x509.CRL
     *
     * @description
     * This method returns a JSON object of the CRL
     * parameters. 
     * Return value can be passed to
     * {@link KJUR.asn1.x509.CRL} constructor.
     * <br/>
     * NOTE1: From jsrsasign 10.5.16, optional argument can be applied.
     * It can have following members:
     * <ul>
     * <li>tbshex - if this is true, tbshex member with hex value of
     * tbsCertList will be added</li>
     * <li>nodnarray - if this is true, array member for subject and
     * issuer will be deleted to simplify it<li>
     * </ul>
     *
     * @example
     * crl = new X509CRL("-----BEGIN X509 CRL...");
     * crl.getParam() &rarr;
     * {version: 2,
     *  sigalg: "SHA256withRSA",
     *  issuer: {array:
     *    [[{type:"C",value:"JP",ds:"prn"}],[{type:"O",value:"T1",ds:"prn"}]]},
     *  thisupdate: "200820212434Z",
     *  nextupdate: "200910212434Z",
     *  revcert: [
     *   {sn:{hex:"123d..."},
     *    date:"061110000000Z",
     *    ext:[{extname:"cRLReason",code:4}]}],
     *  ext: [
     *   {extname:"authorityKeyIdentifier",kid:{hex: "03de..."}},
     *   {extname:"cRLNumber",num:{hex:"0211"}}],
     *  sighex: "3c5e..."}
     *
     * crl.getParam({tbshex: true}) &rarr; { ... , tbshex: "30..." }
     * crl.getParam({nodnarray: true}) &rarr; {issuer: {str: "/C=JP"}, ...}
     */
    this.getParam = function(option) {
	var result = {};

	var version = this.getVersion();
	if (version != null) result.version = version;
	
	result.sigalg = this.getSignatureAlgorithmField();
	result.issuer = this.getIssuer();
	result.thisupdate = this.getThisUpdate();

	var nextUpdate = this.getNextUpdate();
	if (nextUpdate != null) result.nextupdate = nextUpdate;

	var revCerts = this.getRevCertArray();
	if (revCerts != null) result.revcert = revCerts;

	var idxExt = _getIdxbyListEx(this.hex, 0, [0, "[0]"]);
	if (idxExt != -1) {
	    var hExtSeq = _getTLVbyListEx(this.hex, 0, [0, "[0]", 0]);
	    result.ext = _x509obj.getExtParamArray(hExtSeq);
	}

	result.sighex = this.getSignatureValueHex();

	this.parsed = result;

	// for options
	if (typeof option == "object") {
	    if (option.tbshex == true) {
		result.tbshex = _getTLVbyList(this.hex, 0, [0]);
	    }
	    if (option.nodnarray == true) {
		delete result.issuer.array;
	    }
	}

	return result;
    };

    if (typeof params == "string") {
	if (_isHex(params)) {
	    this.hex = params;
	} else if (params.match(/-----BEGIN X509 CRL/)) {
	    this.hex = pemtohex(params);
	}
	this._setPos();
    }
};

var graphene = require("graphene-pk11");
var Module = graphene.Module;

if (typeof KJUR === "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.crypto === "undefined" || !KJUR.crypto) KJUR.crypto = {};
if (typeof KJUR.crypto.adds === "undefined" || !KJUR.crypto.adds) KJUR.crypto.adds = {};

KJUR.crypto.adds.HSMSignature = function (params) {
  // const algSign = params.alg;  
  const prov = params.prov.slice(7);
  const modPath = params.provInfo.module;
  const slotPin = params.provInfo.slotPin;
  
  let mod;
  let session;
  let signOper;
  let alg;

  this.params = null;
  if (':SoftHSM:CloudHSM:'.indexOf(prov) === -1)
    throw new Error(`${prov}: provider not implemented`);

  this.setAlgorithm = function () {
    if (params.alg === "SHA256withRSA") alg = "SHA256_RSA_PKCS";
    else if (params.alg === "SHA512withRSA") alg = "SHA512_RSA_PKCS";
    else throw new Error("Signature algorithm no soported");
  };

  this.init = function (pvKey, pass) {
    this.setAlgorithm();

    mod = Module.load(modPath, prov); 

    mod.initialize();

    session = mod.getSlots(0).open();
    session.login(slotPin);

    let keyObject = session
      .find({ 'class': graphene.ObjectClass.PRIVATE_KEY, 'label': pvKey })
      .items(0);
    signOper = session.createSign(alg, keyObject);
  };

  this.updateHex = function (hex) {
    let co = Buffer.from(hex, "hex");
    signOper.update(co);
  };

  this.sign = function () {
    const signature = signOper.final();
    let hexsign = signature.toString("hex"); 

    session.logout();
    mod.finalize();

    return hexsign;
  };
};
extendClass(KJUR.crypto.adds.HSMSignature, KJUR.crypto.Signature);
